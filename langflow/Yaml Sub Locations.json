{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "UniversalSearchConfigComponent",
            "id": "UniversalSearchConfigComponent-u7ief",
            "name": "config_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "universal_search_result",
            "id": "LocationSelectorFromUniversalSearch-8dtdG",
            "inputTypes": [
              "Data",
              "dict"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__UniversalSearchConfigComponent-u7ief{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-u7iefœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}-LocationSelectorFromUniversalSearch-8dtdG{œfieldNameœ:œuniversal_search_resultœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œinputTypesœ:[œDataœ,œdictœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "UniversalSearchConfigComponent-u7ief",
        "sourceHandle": "{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-u7iefœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "LocationSelectorFromUniversalSearch-8dtdG",
        "targetHandle": "{œfieldNameœ:œuniversal_search_resultœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œinputTypesœ:[œDataœ,œdictœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "UniversalSearchConfigComponent",
            "id": "UniversalSearchConfigComponent-u7ief",
            "name": "config_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-6T9YF",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__UniversalSearchConfigComponent-u7ief{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-u7iefœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}-ParserComponent-6T9YF{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-6T9YFœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "UniversalSearchConfigComponent-u7ief",
        "sourceHandle": "{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-u7iefœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-6T9YF",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-6T9YFœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-9f2ws",
            "name": "false_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "selected_block",
            "id": "ConfigBlockSplitter-gNsct",
            "inputTypes": [
              "Message",
              "Data",
              "dict"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ConditionalRouter-9f2ws{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-9f2wsœ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}-ConfigBlockSplitter-gNsct{œfieldNameœ:œselected_blockœ,œidœ:œConfigBlockSplitter-gNsctœ,œinputTypesœ:[œMessageœ,œDataœ,œdictœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ConditionalRouter-9f2ws",
        "sourceHandle": "{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-9f2wsœ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConfigBlockSplitter-gNsct",
        "targetHandle": "{œfieldNameœ:œselected_blockœ,œidœ:œConfigBlockSplitter-gNsctœ,œinputTypesœ:[œMessageœ,œDataœ,œdictœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LocationSelectorFromUniversalSearch",
            "id": "LocationSelectorFromUniversalSearch-8dtdG",
            "name": "selected_block",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_text",
            "id": "ConditionalRouter-9f2ws",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LocationSelectorFromUniversalSearch-8dtdG{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-9f2ws{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-9f2wsœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "LocationSelectorFromUniversalSearch-8dtdG",
        "sourceHandle": "{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-9f2ws",
        "targetHandle": "{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-9f2wsœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LocationSelectorFromUniversalSearch",
            "id": "LocationSelectorFromUniversalSearch-8dtdG",
            "name": "selected_block",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "false_case_message",
            "id": "ConditionalRouter-9f2ws",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LocationSelectorFromUniversalSearch-8dtdG{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-9f2ws{œfieldNameœ:œfalse_case_messageœ,œidœ:œConditionalRouter-9f2wsœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "LocationSelectorFromUniversalSearch-8dtdG",
        "sourceHandle": "{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-9f2ws",
        "targetHandle": "{œfieldNameœ:œfalse_case_messageœ,œidœ:œConditionalRouter-9f2wsœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-8qOmI",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "OpenAIModel-aD2Th",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-8qOmI{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-8qOmIœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-aD2Th{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-aD2Thœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-8qOmI",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-8qOmIœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "OpenAIModel-aD2Th",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-aD2Thœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConfigBlockSplitter",
            "id": "ConfigBlockSplitter-gNsct",
            "name": "config_items_df",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "LoopComponent-Azlpj",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ConfigBlockSplitter-gNsct{œdataTypeœ:œConfigBlockSplitterœ,œidœ:œConfigBlockSplitter-gNsctœ,œnameœ:œconfig_items_dfœ,œoutput_typesœ:[œDataFrameœ]}-LoopComponent-Azlpj{œfieldNameœ:œdataœ,œidœ:œLoopComponent-Azlpjœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ConfigBlockSplitter-gNsct",
        "sourceHandle": "{œdataTypeœ:œConfigBlockSplitterœ,œidœ:œConfigBlockSplitter-gNsctœ,œnameœ:œconfig_items_dfœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "LoopComponent-Azlpj",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œLoopComponent-Azlpjœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-Azlpj",
            "name": "item",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-jraUk",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__LoopComponent-Azlpj{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-Azlpjœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}-ParserComponent-jraUk{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-jraUkœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "LoopComponent-Azlpj",
        "sourceHandle": "{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-Azlpjœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-jraUk",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-jraUkœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TypeConverterComponent",
            "id": "TypeConverterComponent-uxomw",
            "name": "data_output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-Azlpj",
            "name": "item",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "xy-edge__TypeConverterComponent-uxomw{œdataTypeœ:œTypeConverterComponentœ,œidœ:œTypeConverterComponent-uxomwœ,œnameœ:œdata_outputœ,œoutput_typesœ:[œDataœ]}-LoopComponent-Azlpj{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-Azlpjœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}",
        "selected": false,
        "source": "TypeConverterComponent-uxomw",
        "sourceHandle": "{œdataTypeœ:œTypeConverterComponentœ,œidœ:œTypeConverterComponent-uxomwœ,œnameœ:œdata_outputœ,œoutput_typesœ:[œDataœ]}",
        "target": "LoopComponent-Azlpj",
        "targetHandle": "{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-Azlpjœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-Azlpj",
            "name": "done",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-ssgPc",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__LoopComponent-Azlpj{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-Azlpjœ,œnameœ:œdoneœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-ssgPc{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-ssgPcœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "LoopComponent-Azlpj",
        "sourceHandle": "{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-Azlpjœ,œnameœ:œdoneœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "ParserComponent-ssgPc",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-ssgPcœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "OpenAIModel",
            "id": "OpenAIModel-aD2Th",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "TypeConverterComponent-uxomw",
            "inputTypes": [
              "Message",
              "Data",
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__OpenAIModel-aD2Th{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-aD2Thœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-TypeConverterComponent-uxomw{œfieldNameœ:œinput_dataœ,œidœ:œTypeConverterComponent-uxomwœ,œinputTypesœ:[œMessageœ,œDataœ,œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "OpenAIModel-aD2Th",
        "sourceHandle": "{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-aD2Thœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "TypeConverterComponent-uxomw",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œTypeConverterComponent-uxomwœ,œinputTypesœ:[œMessageœ,œDataœ,œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "config_file",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œconfig_fileœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œconfig_fileœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "config_key",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œconfig_keyœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œconfig_keyœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "create_mode",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œcreate_modeœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œcreate_modeœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "delete_mode",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œdelete_modeœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œdelete_modeœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "directives",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œdirectivesœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œdirectivesœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "existing_locations",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œexisting_locationsœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œexisting_locationsœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "hash",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œhashœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œhashœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "index",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œindexœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œindexœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "kms_required",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œkms_requiredœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œkms_requiredœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "server_names",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œserver_namesœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œserver_namesœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "matching_domains",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œmatching_domainsœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œmatching_domainsœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "location_path",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œlocation_pathœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œlocation_pathœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "operation",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œoperationœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œoperationœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "new_location_path",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œnew_location_pathœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œnew_location_pathœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "parameters",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œparametersœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œparametersœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "type",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œtypeœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œtypeœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "warnings",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œwarningsœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œwarningsœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "ip_addresses",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œip_addressesœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œip_addressesœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-ssgPc",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-Tgr2k",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-ssgPc{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-ssgPcœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-Tgr2k{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-Tgr2kœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParserComponent-ssgPc",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-ssgPcœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-Tgr2k",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-Tgr2kœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-Zb1tD",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_text",
            "id": "ConditionalRouter-qCqZS",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-Zb1tD{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-qCqZS{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-qCqZSœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-Zb1tD",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-qCqZS",
        "targetHandle": "{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-qCqZSœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-Zb1tD",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "true_case_message",
            "id": "ConditionalRouter-qCqZS",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-Zb1tD{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-qCqZS{œfieldNameœ:œtrue_case_messageœ,œidœ:œConditionalRouter-qCqZSœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-Zb1tD",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-qCqZS",
        "targetHandle": "{œfieldNameœ:œtrue_case_messageœ,œidœ:œConditionalRouter-qCqZSœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-qCqZS",
            "name": "true_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "agent1_json",
            "id": "UniversalSearchConfigComponent-u7ief",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ConditionalRouter-qCqZS{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-qCqZSœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}-UniversalSearchConfigComponent-u7ief{œfieldNameœ:œagent1_jsonœ,œidœ:œUniversalSearchConfigComponent-u7iefœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ConditionalRouter-qCqZS",
        "sourceHandle": "{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-qCqZSœ,œnameœ:œtrue_resultœ,œoutput_typesœ:[œMessageœ]}",
        "target": "UniversalSearchConfigComponent-u7ief",
        "targetHandle": "{œfieldNameœ:œagent1_jsonœ,œidœ:œUniversalSearchConfigComponent-u7iefœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-Zb1tD",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_text",
            "id": "ConditionalRouter-vf90w",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-Zb1tD{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-vf90w{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-vf90wœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-Zb1tD",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-vf90w",
        "targetHandle": "{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-vf90wœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-Zb1tD",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "true_case_message",
            "id": "ConditionalRouter-vf90w",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-Zb1tD{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-vf90w{œfieldNameœ:œtrue_case_messageœ,œidœ:œConditionalRouter-vf90wœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-Zb1tD",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-Zb1tDœ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-vf90w",
        "targetHandle": "{œfieldNameœ:œtrue_case_messageœ,œidœ:œConditionalRouter-vf90wœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-GDJZu",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_str",
            "id": "JSONCleaner-Zb1tD",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-GDJZu{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-GDJZuœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-JSONCleaner-Zb1tD{œfieldNameœ:œjson_strœ,œidœ:œJSONCleaner-Zb1tDœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-GDJZu",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-GDJZuœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONCleaner-Zb1tD",
        "targetHandle": "{œfieldNameœ:œjson_strœ,œidœ:œJSONCleaner-Zb1tDœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ArbitratorComponent",
            "id": "ArbitratorComponent-QAA61",
            "name": "result",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-GDJZu",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ArbitratorComponent-QAA61{œdataTypeœ:œArbitratorComponentœ,œidœ:œArbitratorComponent-QAA61œ,œnameœ:œresultœ,œoutput_typesœ:[œDataœ]}-ParserComponent-GDJZu{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-GDJZuœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ArbitratorComponent-QAA61",
        "sourceHandle": "{œdataTypeœ:œArbitratorComponentœ,œidœ:œArbitratorComponent-QAA61œ,œnameœ:œresultœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-GDJZu",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-GDJZuœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "OpenAIModel",
            "id": "OpenAIModel-AsW27",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_str",
            "id": "JSONCleaner-fufw1",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__OpenAIModel-AsW27{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-AsW27œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-JSONCleaner-fufw1{œfieldNameœ:œjson_strœ,œidœ:œJSONCleaner-fufw1œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "OpenAIModel-AsW27",
        "sourceHandle": "{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-AsW27œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONCleaner-fufw1",
        "targetHandle": "{œfieldNameœ:œjson_strœ,œidœ:œJSONCleaner-fufw1œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-e5PJD",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "OpenAIModel-AsW27",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-e5PJD{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-e5PJDœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-AsW27{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-AsW27œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-e5PJD",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-e5PJDœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "OpenAIModel-AsW27",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-AsW27œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-fufw1",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "agent2_output",
            "id": "ArbitratorComponent-QAA61",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-fufw1{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-fufw1œ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-ArbitratorComponent-QAA61{œfieldNameœ:œagent2_outputœ,œidœ:œArbitratorComponent-QAA61œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-fufw1",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-fufw1œ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ArbitratorComponent-QAA61",
        "targetHandle": "{œfieldNameœ:œagent2_outputœ,œidœ:œArbitratorComponent-QAA61œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-NP0e0",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "agent1_output",
            "id": "ArbitratorComponent-QAA61",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-NP0e0{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-NP0e0œ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-ArbitratorComponent-QAA61{œfieldNameœ:œagent1_outputœ,œidœ:œArbitratorComponent-QAA61œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-NP0e0",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-NP0e0œ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ArbitratorComponent-QAA61",
        "targetHandle": "{œfieldNameœ:œagent1_outputœ,œidœ:œArbitratorComponent-QAA61œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "JSONCleaner",
            "id": "JSONCleaner-NP0e0",
            "name": "output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "agent1_json",
            "id": "Prompt Template-e5PJD",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__JSONCleaner-NP0e0{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-NP0e0œ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-e5PJD{œfieldNameœ:œagent1_jsonœ,œidœ:œPrompt Template-e5PJDœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "JSONCleaner-NP0e0",
        "sourceHandle": "{œdataTypeœ:œJSONCleanerœ,œidœ:œJSONCleaner-NP0e0œ,œnameœ:œoutputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-e5PJD",
        "targetHandle": "{œfieldNameœ:œagent1_jsonœ,œidœ:œPrompt Template-e5PJDœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "OpenAIModel",
            "id": "OpenAIModel-gG1G9",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "json_str",
            "id": "JSONCleaner-NP0e0",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__OpenAIModel-gG1G9{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-gG1G9œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-JSONCleaner-NP0e0{œfieldNameœ:œjson_strœ,œidœ:œJSONCleaner-NP0e0œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "OpenAIModel-gG1G9",
        "sourceHandle": "{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-gG1G9œ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "JSONCleaner-NP0e0",
        "targetHandle": "{œfieldNameœ:œjson_strœ,œidœ:œJSONCleaner-NP0e0œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-vV3QQ",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "OpenAIModel-gG1G9",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-vV3QQ{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-vV3QQœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-gG1G9{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-gG1G9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-vV3QQ",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-vV3QQœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "OpenAIModel-gG1G9",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-gG1G9œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-T79uA",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "question",
            "id": "Prompt Template-vV3QQ",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-T79uA{œdataTypeœ:œChatInputœ,œidœ:œChatInput-T79uAœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-vV3QQ{œfieldNameœ:œquestionœ,œidœ:œPrompt Template-vV3QQœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-T79uA",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-T79uAœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-vV3QQ",
        "targetHandle": "{œfieldNameœ:œquestionœ,œidœ:œPrompt Template-vV3QQœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-EwEbV",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-XRXIr",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-EwEbV{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-EwEbVœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-XRXIr{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-XRXIrœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParserComponent-EwEbV",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-EwEbVœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-XRXIr",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-XRXIrœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ExtractWarningsError",
            "id": "CustomComponent-8UqlH",
            "name": "output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-EwEbV",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-8UqlH{œdataTypeœ:œExtractWarningsErrorœ,œidœ:œCustomComponent-8UqlHœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}-ParserComponent-EwEbV{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-EwEbVœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-8UqlH",
        "sourceHandle": "{œdataTypeœ:œExtractWarningsErrorœ,œidœ:œCustomComponent-8UqlHœ,œnameœ:œoutputœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-EwEbV",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-EwEbVœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LocationSelectorFromUniversalSearch",
            "id": "LocationSelectorFromUniversalSearch-8dtdG",
            "name": "selected_block",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "result_input",
            "id": "CustomComponent-8UqlH",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LocationSelectorFromUniversalSearch-8dtdG{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}-CustomComponent-8UqlH{œfieldNameœ:œresult_inputœ,œidœ:œCustomComponent-8UqlHœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "LocationSelectorFromUniversalSearch-8dtdG",
        "sourceHandle": "{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-8dtdGœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CustomComponent-8UqlH",
        "targetHandle": "{œfieldNameœ:œresult_inputœ,œidœ:œCustomComponent-8UqlHœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-jraUk",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "server_block_parameters",
            "id": "Prompt Template-8qOmI",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-jraUk{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-8qOmI{œfieldNameœ:œserver_block_parametersœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-jraUk",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-jraUkœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-8qOmI",
        "targetHandle": "{œfieldNameœ:œserver_block_parametersœ,œidœ:œPrompt Template-8qOmIœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-6T9YF",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-crLPm",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-6T9YF{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-6T9YFœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-crLPm{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-crLPmœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParserComponent-6T9YF",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-6T9YFœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-crLPm",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-crLPmœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "LocationSelectorFromUniversalSearch-8dtdG",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Selects locations from universal search result for LLM processing (supports 1 or N locations)",
            "display_name": "Location Selector from Universal Search",
            "documentation": "",
            "edited": true,
            "field_order": [
              "universal_search_result",
              "source_field"
            ],
            "frozen": false,
            "icon": "filter",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "selected_block",
                "group_outputs": false,
                "hidden": null,
                "method": "build_selected_block",
                "name": "selected_block",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "operation_context",
                "group_outputs": false,
                "hidden": null,
                "method": "build_operation_context",
                "name": "operation_context",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "error_message",
                "group_outputs": false,
                "hidden": null,
                "method": "build_error_message",
                "name": "error_message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import (\n    HandleInput,\n    MessageTextInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\nimport json\nimport hashlib\nimport yaml\nimport re\nfrom typing import Dict, Any, List, Optional, Tuple\n\n\nclass LocationSelectorFromUniversalSearch(Component):\n    \"\"\"\n    Selects a specific location or server block from universal search result.\n    Automatically extracts target location from agent1_data.location.\n    Processes ALL matching configurations from all_configs.\n    Special handling for operations:\n    - CREATE_LOCATION: Returns config info where location DOESN'T exist (to create new)\n    - DELETE_LOCATION: Returns config info where location DOES exist (to delete)\n    - MODIFY_LOCATION_PATH: Returns config info where OLD location exists (to rename/move)\n    - MODIFY/ADD: Returns config info where location exists (to modify)\n    - MAKE_PROTECTED: Returns config info where location exists (to make protected)\n    - MAKE_PUBLIC: Returns config info where location exists (to make public)\n    - Server operations: Always returns server block info\n    NEW: Handles both single location and multiple locations seamlessly!\n    NEW: Supports parameters, location_parameters, server_block_parameters\n    NEW: Supports multi-DC detection (found_in_multiple_dc, domain_dc_mapping, etc.)\n    \"\"\"\n    display_name = \"Location Selector from Universal Search\"\n    description = \"Selects locations from universal search result for LLM processing (supports 1 or N locations)\"\n    documentation = \"\"\n    icon = \"filter\"\n    inputs = [\n        HandleInput(\n            name=\"universal_search_result\",\n            display_name=\"Universal Search Result\",\n            input_types=[\"Data\", \"dict\"],\n            info=\"Output from Universal Search (contains agent1_data)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"source_field\",\n            display_name=\"Source field\",\n            value=\"full_config_text\",\n            info=\"Field containing YAML config text (full_config_text or config_block)\",\n            required=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"selected_block\",\n            name=\"selected_block\",\n            info=\"Selected location/server blocks for all matching configs\",\n            method=\"build_selected_block\",\n        ),\n        Output(\n            display_name=\"operation_context\",\n            name=\"operation_context\",\n            info=\"Operation metadata from agent1_data\",\n            method=\"build_operation_context\",\n        ),\n        Output(\n            display_name=\"error_message\",\n            name=\"error_message\",\n            info=\"Error if location not found\",\n            method=\"build_error_message\",\n        ),\n    ]\n\n    def _get_search_result(self) -> Dict[str, Any]:\n        \"\"\"Extract universal search result.\"\"\"\n        input_data = self.universal_search_result\n        if isinstance(input_data, Data):\n            data = input_data.data\n        elif isinstance(input_data, dict):\n            data = input_data\n        else:\n            data = json.loads(str(input_data))\n        return data\n\n    def _extract_multi_dc_info(self, search_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        🆕 Extract multi-DC information from search result.\n        Returns dict with all multi-DC related fields.\n        \"\"\"\n        return {\n            \"found_in_multiple_dc\": search_result.get(\"found_in_multiple_dc\", False),\n            \"dc_count\": search_result.get(\"dc_count\", 0),\n            \"unique_dcs\": search_result.get(\"unique_dcs\", []),\n            \"domain_dc_mapping\": search_result.get(\"domain_dc_mapping\", {}),\n            \"domains_in_multiple_dc\": search_result.get(\"domains_in_multiple_dc\", []),\n        }\n\n    def _get_agent1_data(self, search_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Extract and normalize agent1_data from search result.\n        Handles ALL possible structures:\n        - agent1_data as list\n        - agent1_data as dict with 'payload'\n        - agent1_data as dict without 'payload'\n        - Multiple domains vs single domain\n        - Merges data from multiple payload items\n        \"\"\"\n        agent1_data_raw = search_result.get(\"agent1_data\", {})\n\n        # CASE 1: agent1_data is a list - take first element\n        if isinstance(agent1_data_raw, list):\n            if not agent1_data_raw:\n                return {}\n            first_item = agent1_data_raw[0]\n            # Check if this item also has payload\n            if isinstance(first_item, dict) and \"payload\" in first_item:\n                return self._extract_from_payload(first_item.get(\"payload\", []))\n            return first_item\n\n        # CASE 2: agent1_data is dict\n        if isinstance(agent1_data_raw, dict):\n            # Check if it has 'payload' key\n            if \"payload\" in agent1_data_raw:\n                payload = agent1_data_raw.get(\"payload\", [])\n                return self._extract_from_payload(payload)\n\n            # CASE 3: Direct dict without payload - return as is\n            return agent1_data_raw\n\n        return {}\n\n    def _extract_from_payload(self, payload: List[Dict]) -> Dict[str, Any]:\n        \"\"\"\n        Extract and merge data from payload array.\n        Handles both single and multiple items in payload.\n        \"\"\"\n        if not payload or not isinstance(payload, list):\n            return {}\n\n        # If single item - return it directly\n        if len(payload) == 1:\n            return payload[0]\n\n        # Multiple items - merge them intelligently\n        merged = {\n            \"operation\": None,\n            \"domain\": None,\n            \"domains\": [],\n            \"location\": None,\n            \"locations\": [],\n            \"from_location\": None,\n            \"to_location\": None,\n            \"new_location_path\": None,\n            \"preserve_directives\": True,\n            \"parameters\": [],\n            \"location_parameters\": [],\n            \"server_block_parameters\": [],\n            \"ip_addresses\": [],\n            \"upstreams\": [],\n            \"kms_required\": False,\n            \"kms_mentioned\": False,\n            \"kms_locations\": [],\n            \"public_locations\": [],\n            \"selected_dc\": [],\n            \"data_complete\": True,\n            \"confidence\": 0.0,\n            \"warnings\": [],\n            \"ambiguities\": []\n        }\n\n        for item in payload:\n            if not isinstance(item, dict):\n                continue\n\n            # Operation - take from first item\n            if not merged[\"operation\"] and item.get(\"operation\"):\n                merged[\"operation\"] = item[\"operation\"]\n\n            # Domains - collect all\n            if item.get(\"domain\"):\n                merged[\"domains\"].append(item[\"domain\"])\n                if not merged[\"domain\"]:  # Set first domain as primary\n                    merged[\"domain\"] = item[\"domain\"]\n\n            if item.get(\"domains\"):\n                if isinstance(item[\"domains\"], list):\n                    merged[\"domains\"].extend(item[\"domains\"])\n                else:\n                    merged[\"domains\"].append(item[\"domains\"])\n\n            # Locations - collect all\n            if item.get(\"location\"):\n                merged[\"locations\"].append(item[\"location\"])\n                if not merged[\"location\"]:  # Set first location as primary\n                    merged[\"location\"] = item[\"location\"]\n\n            if item.get(\"locations\"):\n                if isinstance(item[\"locations\"], list):\n                    merged[\"locations\"].extend(item[\"locations\"])\n                else:\n                    merged[\"locations\"].append(item[\"locations\"])\n\n            # Location parameters - collect all\n            if item.get(\"location_parameters\"):\n                if isinstance(item[\"location_parameters\"], list):\n                    merged[\"location_parameters\"].extend(item[\"location_parameters\"])\n                else:\n                    merged[\"location_parameters\"].append(item[\"location_parameters\"])\n\n            # Server block parameters - collect all (deduplicate later)\n            if item.get(\"server_block_parameters\"):\n                if isinstance(item[\"server_block_parameters\"], list):\n                    merged[\"server_block_parameters\"].extend(item[\"server_block_parameters\"])\n                else:\n                    merged[\"server_block_parameters\"].append(item[\"server_block_parameters\"])\n\n            # General parameters - collect all\n            if item.get(\"parameters\"):\n                if isinstance(item[\"parameters\"], list):\n                    merged[\"parameters\"].extend(item[\"parameters\"])\n                else:\n                    merged[\"parameters\"].append(item[\"parameters\"])\n\n            # IP addresses - collect all\n            if item.get(\"ip_addresses\"):\n                if isinstance(item[\"ip_addresses\"], list):\n                    merged[\"ip_addresses\"].extend(item[\"ip_addresses\"])\n                else:\n                    merged[\"ip_addresses\"].append(item[\"ip_addresses\"])\n\n            # Upstreams - collect all\n            if item.get(\"upstreams\"):\n                if isinstance(item[\"upstreams\"], list):\n                    merged[\"upstreams\"].extend(item[\"upstreams\"])\n                elif item[\"upstreams\"]:  # Not None\n                    merged[\"upstreams\"].append(item[\"upstreams\"])\n\n            # Selected DC - collect all\n            if item.get(\"selected_dc\"):\n                if isinstance(item[\"selected_dc\"], list):\n                    merged[\"selected_dc\"].extend(item[\"selected_dc\"])\n                else:\n                    merged[\"selected_dc\"].append(item[\"selected_dc\"])\n\n            # KMS locations - collect all\n            if item.get(\"kms_locations\"):\n                if isinstance(item[\"kms_locations\"], list):\n                    merged[\"kms_locations\"].extend(item[\"kms_locations\"])\n                else:\n                    merged[\"kms_locations\"].append(item[\"kms_locations\"])\n\n            # Public locations - collect all\n            if item.get(\"public_locations\"):\n                if isinstance(item[\"public_locations\"], list):\n                    merged[\"public_locations\"].extend(item[\"public_locations\"])\n                else:\n                    merged[\"public_locations\"].append(item[\"public_locations\"])\n\n            # Boolean flags - OR logic (if any item has True, result is True)\n            if item.get(\"kms_required\"):\n                merged[\"kms_required\"] = True\n\n            if item.get(\"kms_mentioned\"):\n                merged[\"kms_mentioned\"] = True\n\n            # Preserve directives - AND logic (all must be True)\n            if item.get(\"preserve_directives\") is False:\n                merged[\"preserve_directives\"] = False\n\n            # Path modification fields - take from first non-empty\n            if not merged[\"from_location\"] and item.get(\"from_location\"):\n                merged[\"from_location\"] = item[\"from_location\"]\n\n            if not merged[\"to_location\"] and item.get(\"to_location\"):\n                merged[\"to_location\"] = item[\"to_location\"]\n\n            if not merged[\"new_location_path\"] and item.get(\"new_location_path\"):\n                merged[\"new_location_path\"] = item[\"new_location_path\"]\n\n            # Data completeness - AND logic\n            if item.get(\"data_complete\") is False:\n                merged[\"data_complete\"] = False\n\n            # Confidence - take maximum\n            item_confidence = item.get(\"confidence\", 0.0)\n            if item_confidence > merged[\"confidence\"]:\n                merged[\"confidence\"] = item_confidence\n\n            # Warnings and ambiguities - collect all\n            if item.get(\"warnings\"):\n                if isinstance(item[\"warnings\"], list):\n                    merged[\"warnings\"].extend(item[\"warnings\"])\n                else:\n                    merged[\"warnings\"].append(item[\"warnings\"])\n\n            if item.get(\"ambiguities\"):\n                if isinstance(item[\"ambiguities\"], list):\n                    merged[\"ambiguities\"].extend(item[\"ambiguities\"])\n                else:\n                    merged[\"ambiguities\"].append(item[\"ambiguities\"])\n\n        # Deduplicate lists\n        merged[\"domains\"] = list(dict.fromkeys(merged[\"domains\"]))  # Preserve order\n        merged[\"locations\"] = list(dict.fromkeys(merged[\"locations\"]))\n        merged[\"server_block_parameters\"] = list(dict.fromkeys(merged[\"server_block_parameters\"]))\n        merged[\"parameters\"] = list(dict.fromkeys(merged[\"parameters\"]))\n        merged[\"ip_addresses\"] = list(dict.fromkeys(merged[\"ip_addresses\"]))\n        merged[\"selected_dc\"] = list(dict.fromkeys(merged[\"selected_dc\"]))\n        merged[\"kms_locations\"] = list(dict.fromkeys(merged[\"kms_locations\"]))\n        merged[\"public_locations\"] = list(dict.fromkeys(merged[\"public_locations\"]))\n\n        # Clean up empty lists to None where appropriate\n        if not merged[\"domains\"]:\n            merged[\"domains\"] = []\n        if not merged[\"locations\"]:\n            merged[\"locations\"] = []\n        if not merged[\"upstreams\"]:\n            merged[\"upstreams\"] = []\n\n        return merged\n\n    def _normalize_location_parameters(self, agent1_data: Dict[str, Any]) -> List[Dict]:\n        \"\"\"\n        Normalize location_parameters regardless of input format.\n        Handles: single location, multiple locations, location_parameters array.\n        Returns list of dicts, each with: location, parameters, kms_required, ip_addresses, upstreams, new_location_path\n        \"\"\"\n        location_parameters = agent1_data.get(\"location_parameters\", [])\n        locations_list = agent1_data.get(\"locations\", [])\n        single_location = agent1_data.get(\"location\")\n        ip_addresses = agent1_data.get(\"ip_addresses\", [])\n        upstreams = agent1_data.get(\"upstreams\", [])\n        parameters = agent1_data.get(\"parameters\", [])\n        kms_required = agent1_data.get(\"kms_required\", False)\n        server_block_parameters = agent1_data.get(\"server_block_parameters\", [])\n        selected_dc = agent1_data.get(\"selected_dc\", [])\n        # NEW: Support both naming conventions for path modification\n        new_location_path = agent1_data.get(\"new_location_path\") or agent1_data.get(\"to_location\")\n        from_location = agent1_data.get(\"from_location\")\n        # If from_location is specified, use it as the primary location\n        if from_location:\n            single_location = from_location\n        # CASE 1: location_parameters уже заполнена (приоритет)\n        if location_parameters and isinstance(location_parameters, list):\n            normalized = []\n            for loc_param in location_parameters:\n                if isinstance(loc_param, dict) and loc_param.get(\"location\"):\n                    # Support both naming conventions\n                    param_new_path = (loc_param.get(\"new_location_path\") or\n                                      loc_param.get(\"to_location\") or\n                                      new_location_path)\n                    norm_param = {\n                        \"location\": loc_param.get(\"location\") or loc_param.get(\"from_location\"),\n                        \"parameters\": loc_param.get(\"parameters\", parameters),\n                        \"kms_required\": loc_param.get(\"kms_required\", kms_required),\n                        \"ip_addresses\": loc_param.get(\"ip_addresses\", ip_addresses),\n                        \"upstreams\": loc_param.get(\"upstreams\", upstreams),\n                        \"server_block_parameters\": loc_param.get(\"server_block_parameters\", server_block_parameters),\n                        \"new_location_path\": param_new_path,\n                        \"selected_dc\": loc_param.get(\"selected_dc\", selected_dc),\n                    }\n                    normalized.append(norm_param)\n            if normalized:\n                return normalized\n        # CASE 2: Множественные locations в поле \"locations\"\n        if locations_list and isinstance(locations_list, list):\n            return [\n                {\n                    \"location\": loc,\n                    \"parameters\": parameters,\n                    \"kms_required\": kms_required,\n                    \"ip_addresses\": ip_addresses,\n                    \"upstreams\": upstreams,\n                    \"server_block_parameters\": server_block_parameters,\n                    \"new_location_path\": new_location_path,\n                    \"selected_dc\": selected_dc,\n                }\n                for loc in locations_list\n                if loc  # Исключить пустые\n            ]\n        # CASE 3: Одна location\n        if single_location:\n            return [\n                {\n                    \"location\": single_location,\n                    \"parameters\": parameters,\n                    \"kms_required\": kms_required,\n                    \"ip_addresses\": ip_addresses,\n                    \"upstreams\": upstreams,\n                    \"server_block_parameters\": server_block_parameters,\n                    \"new_location_path\": new_location_path,\n                    \"selected_dc\": selected_dc,\n                }\n            ]\n        # CASE 4: Ничего не найдено\n        return []\n\n    def _parse_yaml_config(self, config_text: str) -> Tuple[str, List[str], List[Dict]]:\n        \"\"\"\n        Parse YAML config and extract server directives and locations.\n        Returns: (config_key, server_directives, locations)\n        \"\"\"\n        parsed_data = yaml.safe_load(config_text)\n        if isinstance(parsed_data, list):  # Handle top-level list YAML\n            key = \"default_config\"\n            items = parsed_data\n        elif isinstance(parsed_data, dict) and parsed_data:\n            key = list(parsed_data.keys())[0]\n            items = parsed_data[key]\n        else:\n            raise ValueError(\"Invalid YAML structure: must be dict or list\")\n        if not isinstance(items, list):\n            items = [items]  # Ensure items is always a list\n        server_directives = []\n        locations = []\n        for item in items:\n            item_str = str(item).strip()\n            if item_str.startswith(\"location \"):\n                # Parse location: location /path { ... }\n                match = re.match(r\"location\\s+([^{]+)\\s*{(.*)}\", item_str, re.DOTALL)\n                if match:\n                    path = match.group(1).strip()\n                    content = match.group(2).strip().rstrip(\"};\")\n                    directives = [d.strip().rstrip(\";\").strip() + \";\"\n                                  for d in content.split(\";\") if d.strip()]\n                    # Calculate hash\n                    content_str = f\"{path}:{content}\"\n                    loc_hash = hashlib.sha1(content_str.encode(\"utf-8\", errors=\"ignore\")).hexdigest()\n                    locations.append({\n                        \"path\": path,\n                        \"directives\": directives,\n                        \"hash\": loc_hash\n                    })\n                else:\n                    # Fallback to server directive\n                    cleaned = item_str.rstrip(\";\").strip()\n                    if not item_str.endswith(\";\"):\n                        cleaned += \";\"\n                    server_directives.append(cleaned)\n            elif item_str.startswith(\"- \"):\n                directive = item_str.lstrip(\"- \").rstrip(\";\").strip()\n                if not item_str.lstrip(\"- \").endswith(\";\"):\n                    directive += \";\"\n                server_directives.append(directive)\n            else:\n                directive = item_str.rstrip(\";\").strip()\n                if not item_str.endswith(\";\"):\n                    directive += \";\"\n                server_directives.append(directive)\n        return key, server_directives, locations\n\n    def _find_location(self, locations: List[Dict], target_location: str) -> Optional[Dict]:\n        \"\"\"Find location block by path with normalization.\"\"\"\n        normalized_target = target_location\n        if target_location != \"/\" and not target_location.endswith(\"/\"):\n            normalized_target = target_location + \"/\"\n        # Try normalized match\n        for loc in locations:\n            path = loc.get(\"path\", \"\")\n            normalized_path = path\n            if path != \"/\" and not path.endswith(\"/\"):\n                normalized_path = path + \"/\"\n            if normalized_path == normalized_target or path == target_location:\n                return loc\n        # Try exact match (for modifiers like \"= /path\")\n        for loc in locations:\n            if loc.get(\"path\") == target_location:\n                return loc\n        return None\n\n    def build_selected_block(self) -> Message:\n        \"\"\"\n        Select the target blocks based on agent1_data from ALL matching configs.\n        Handles both single and multiple locations.\n        🆕 Now includes multi-DC information.\n        \"\"\"\n        try:\n            search_result = self._get_search_result()\n\n            # 🆕 Extract multi-DC info\n            multi_dc_info = self._extract_multi_dc_info(search_result)\n            # Extract agent1_data using universal method\n            agent1_data = self._get_agent1_data(search_result)\n\n\n            operation = search_result.get(\"operation\", agent1_data.get(\"operation\", \"ADD_PARAMETERS\"))\n            target_domains = search_result.get(\"domains\", agent1_data.get(\"domains\", []))\n            # 🔥 НОВОЕ: Нормализовать location_parameters - работает для 1 или N locations\n            location_parameters = self._normalize_location_parameters(agent1_data)\n            source_field = getattr(self, 'source_field', 'full_config_text')\n            all_configs = search_result.get(\"all_configs\", [])\n            if not all_configs:\n                return Message(text=json.dumps({\n                    \"error\": \"No configs found in all_configs\",\n                    \"selected_blocks\": [],\n                    **multi_dc_info  # 🆕 Include multi-DC info even in error\n                }, ensure_ascii=False))\n            selected_blocks = []\n            errors = []\n            # OPERATION-SPECIFIC LOGIC\n            is_create_operation = operation == \"CREATE_LOCATION\"\n            is_delete_operation = operation == \"DELETE_LOCATION\"\n            is_modify_path_operation = operation == \"MODIFY_LOCATION_PATH\"  # NEW\n            requires_existing_location = is_delete_operation or operation in [\n                \"MODIFY_PARAMETERS\",\n                \"ADD_PARAMETERS\",\n                \"CONDITIONAL_ADD_PARAMETERS\",\n                \"DELETE_PARAMETERS\",\n                \"DELETE_KMS_PARAMETERS\",\n                \"MODIFY_UPSTREAM\",\n                \"MODIFY_LOCATION_PATH\",  # NEW - requires existing location\n                \"MAKE_PROTECTED\",  # Added support\n                \"MAKE_PUBLIC\"  # Added support\n            ]\n            # PROCESS ALL CONFIGURATIONS\n            for config in all_configs:\n                if not isinstance(config, dict):  # Safeguard against non-dict configs\n                    errors.append(f\"Invalid config type in all_configs: {type(config)} - skipping\")\n                    continue\n                # Check if config matches target domains\n                matching_domains = config.get(\"matching_domains\", [])\n                server_names = config.get(\"server_names\", [])\n\n                # 🆕 Get inferred_dc for this config\n                config_inferred_dc = config.get(\"inferred_dc\", [])\n\n                # Skip configs that don't match any target domain\n                if target_domains:\n                    if not any(domain in target_domains for domain in matching_domains):\n                        if not any(domain in target_domains for domain in server_names):\n                            continue\n                config_text = config.get(source_field)\n                if not config_text:\n                    errors.append(f\"No {source_field} in config {config.get('config_key', 'unknown')}\")\n                    continue\n                try:\n                    key, server_directives, locations = self._parse_yaml_config(config_text)\n                    # SERVER BLOCK (no specific locations = work with server block)\n                    if not location_parameters:\n                        server_str = \";\".join(server_directives)\n                        server_hash = hashlib.sha1(server_str.encode(\"utf-8\", errors=\"ignore\")).hexdigest()\n                        selected_blocks.append({\n                            \"config_key\": key,\n                            \"config_file\": config.get(\"config_file\"),\n                            \"server_names\": server_names,\n                            \"matching_domains\": matching_domains,\n                            \"location_path\": \"server_block\",\n                            \"directives\": server_directives,\n                            \"hash\": server_hash,\n                            \"type\": \"server\",\n                            \"operation\": operation,\n                            \"parameters\": agent1_data.get(\"parameters\", []),\n                            \"server_block_parameters\": agent1_data.get(\"server_block_parameters\", []),\n                            \"selected_dc\": agent1_data.get(\"selected_dc\", []),\n                            \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                        })\n                    # LOCATION-SPECIFIC (process ALL locations - 1, 2, 3, N...)\n                    else:\n                        for loc_param in location_parameters:\n                            target_loc = loc_param.get(\"location\")\n                            if not target_loc:\n                                errors.append(\"Invalid location in location_parameters\")\n                                continue\n                            existing_location = self._find_location(locations, target_loc)\n                            # CREATE_LOCATION: location НЕ должна существовать\n                            if is_create_operation:\n                                if existing_location:\n                                    errors.append(\n                                        f\"Location '{target_loc}' already exists in {key}. \"\n                                        f\"Cannot create duplicate location.\"\n                                    )\n                                else:\n                                    # Location doesn't exist - good for CREATE_LOCATION\n                                    selected_blocks.append({\n                                        \"config_key\": key,\n                                        \"config_file\": config.get(\"config_file\"),\n                                        \"server_names\": server_names,\n                                        \"matching_domains\": matching_domains,\n                                        \"location_path\": target_loc,\n                                        \"directives\": [],  # Empty - will be populated by LLM\n                                        \"hash\": None,\n                                        \"type\": \"location\",\n                                        \"operation\": operation,\n                                        \"existing_locations\": [loc.get(\"path\") for loc in locations],\n                                        \"create_mode\": True,\n                                        \"parameters\": loc_param.get(\"parameters\", []),\n                                        \"kms_required\": loc_param.get(\"kms_required\", False),\n                                        \"ip_addresses\": loc_param.get(\"ip_addresses\", []),\n                                        \"upstreams\": loc_param.get(\"upstreams\", []),\n                                        \"server_block_parameters\": loc_param.get(\"server_block_parameters\", []),\n                                        \"selected_dc\": loc_param.get(\"selected_dc\", []),\n                                        \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                                    })\n                            # DELETE_LOCATION: location ДОЛЖНА существовать\n                            elif is_delete_operation:\n                                if existing_location:\n                                    selected_blocks.append({\n                                        \"config_key\": key,\n                                        \"config_file\": config.get(\"config_file\"),\n                                        \"server_names\": server_names,\n                                        \"matching_domains\": matching_domains,\n                                        \"location_path\": existing_location.get(\"path\"),\n                                        \"directives\": existing_location.get(\"directives\", []),\n                                        \"hash\": existing_location.get(\"hash\"),\n                                        \"type\": \"location\",\n                                        \"operation\": operation,\n                                        \"delete_mode\": True,\n                                        \"selected_dc\": loc_param.get(\"selected_dc\", []),\n                                        \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                                    })\n                                else:\n                                    errors.append(\n                                        f\"Location '{target_loc}' not found in {key}. \"\n                                        f\"Cannot delete non-existent location. \"\n                                        f\"Available: {[loc.get('path') for loc in locations]}\"\n                                    )\n                            # MODIFY/ADD/MODIFY_LOCATION_PATH/MAKE_PROTECTED/MAKE_PUBLIC: location ДОЛЖНА существовать\n                            elif requires_existing_location:\n                                if existing_location:\n                                    block_data = {\n                                        \"config_key\": key,\n                                        \"config_file\": config.get(\"config_file\"),\n                                        \"server_names\": server_names,\n                                        \"matching_domains\": matching_domains,\n                                        \"location_path\": existing_location.get(\"path\"),\n                                        \"directives\": existing_location.get(\"directives\", []),\n                                        \"hash\": existing_location.get(\"hash\"),\n                                        \"type\": \"location\",\n                                        \"operation\": operation,\n                                        \"parameters\": loc_param.get(\"parameters\", []),\n                                        \"kms_required\": loc_param.get(\"kms_required\", False),\n                                        \"ip_addresses\": loc_param.get(\"ip_addresses\", []),\n                                        \"upstreams\": loc_param.get(\"upstreams\", []),\n                                        \"server_block_parameters\": loc_param.get(\"server_block_parameters\", []),\n                                        \"selected_dc\": loc_param.get(\"selected_dc\", []),\n                                        \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                                    }\n                                    # NEW: Add new_location_path for MODIFY_LOCATION_PATH operation\n                                    if operation == \"MODIFY_LOCATION_PATH\":\n                                        new_path = loc_param.get(\"new_location_path\")\n                                        if new_path:\n                                            block_data[\"new_location_path\"] = new_path\n                                            block_data[\"existing_locations\"] = [loc.get(\"path\") for loc in locations]\n                                        else:\n                                            errors.append(\n                                                f\"MODIFY_LOCATION_PATH requires 'new_location_path' for '{target_loc}'\"\n                                            )\n                                            continue\n                                    selected_blocks.append(block_data)\n                                else:\n                                    errors.append(\n                                        f\"Location '{target_loc}' not found in {key}. \"\n                                        f\"Available: {[loc.get('path') for loc in locations]}\"\n                                    )\n                            else:\n                                # Fallback for unknown operations\n                                errors.append(f\"Unknown operation '{operation}' for location '{target_loc}'\")\n                except Exception as e:\n                    errors.append(f\"Error parsing config {config.get('config_key', 'unknown')}: {str(e)}\")\n                    continue\n            # Prepare result\n            result = {\n                \"selected_blocks\": selected_blocks,\n                \"total_configs_scanned\": len(all_configs),\n                \"total_blocks_found\": len(selected_blocks),\n                \"target_locations\": [lp.get(\"location\") for lp in location_parameters],\n                \"target_domains\": target_domains,\n                \"operation\": operation,\n                \"locations_count\": len(location_parameters),\n                \"parameters\": agent1_data.get(\"parameters\", []),\n                \"location_parameters\": location_parameters,\n                \"server_block_parameters\": agent1_data.get(\"server_block_parameters\", []),\n\n                # 🆕 Multi-DC information\n                **multi_dc_info,\n            }\n            if errors:\n                result[\"warnings\"] = errors\n            if not selected_blocks:\n                if is_create_operation:\n                    result[\"error\"] = (\n                        f\"Cannot create locations {[lp.get('location') for lp in location_parameters]} - \"\n                        f\"they may already exist or no valid configs found\"\n                    )\n                elif is_delete_operation:\n                    result[\"error\"] = (\n                        f\"Cannot delete locations - not found in configs\"\n                    )\n                else:\n                    result[\"error\"] = (\n                        f\"Locations not found in any of {len(all_configs)} configs\"\n                    )\n\n            # 🆕 Add multi-DC warning to result if applicable\n            if multi_dc_info[\"found_in_multiple_dc\"]:\n                if \"warnings\" not in result:\n                    result[\"warnings\"] = []\n                result[\"warnings\"].insert(0,\n                                          f\"⚠️ MULTI-DC: Domain found in {multi_dc_info['dc_count']} datacenters: \"\n                                          f\"{', '.join(multi_dc_info['unique_dcs'])}. \"\n                                          f\"Ensure changes are applied to all required locations!\"\n                                          )\n\n            return Message(text=json.dumps(result, ensure_ascii=False))\n        except Exception as e:\n            return Message(text=json.dumps({\n                \"error\": f\"Error in Location Selector: {str(e)}\",\n                \"selected_blocks\": []\n            }, ensure_ascii=False))\n\n    def build_operation_context(self) -> Message:\n        \"\"\"\n        Extract operation context from agent1_data.\n        🆕 Now includes multi-DC information.\n        \"\"\"\n        try:\n            search_result = self._get_search_result()\n\n            # 🆕 Extract multi-DC info\n            multi_dc_info = self._extract_multi_dc_info(search_result)\n            agent1_data = self._get_agent1_data(search_result)\n\n\n            # 🔥 НОВОЕ: Нормализовать\n            location_parameters = self._normalize_location_parameters(agent1_data)\n            all_configs = search_result.get(\"all_configs\", [])\n\n            operation_context = {\n                \"operation\": agent1_data.get(\"operation\"),\n                \"domain\": agent1_data.get(\"domain\"),\n                \"domains\": agent1_data.get(\"domains\", []),\n                \"location\": agent1_data.get(\"location\"),\n                \"locations\": agent1_data.get(\"locations\", []),\n                \"from_location\": agent1_data.get(\"from_location\"),  # NEW\n                \"to_location\": agent1_data.get(\"to_location\"),  # NEW\n                \"new_location_path\": agent1_data.get(\"new_location_path\"),\n                \"preserve_directives\": agent1_data.get(\"preserve_directives\"),  # NEW\n                \"parameters\": agent1_data.get(\"parameters\", []),\n                \"location_parameters\": location_parameters,  # Нормализованные\n                \"ip_addresses\": agent1_data.get(\"ip_addresses\", []),\n                \"upstreams\": agent1_data.get(\"upstreams\"),\n                \"server_block_parameters\": agent1_data.get(\"server_block_parameters\", []),\n                \"kms_required\": agent1_data.get(\"kms_required\"),\n                \"kms_mentioned\": agent1_data.get(\"kms_mentioned\"),\n                \"conditional_add\": agent1_data.get(\"conditional_add\"),\n                \"total_configs_found\": len(all_configs),\n                \"config_files\": [cfg.get(\"config_file\") for cfg in all_configs if isinstance(cfg, dict)],\n                \"config_keys\": [cfg.get(\"config_key\") for cfg in all_configs if isinstance(cfg, dict)],\n                \"locations_count\": len(location_parameters),\n                \"selected_dc\": agent1_data.get(\"selected_dc\", []),\n\n                # 🆕 Multi-DC information\n                **multi_dc_info,\n            }\n            return Message(text=json.dumps(operation_context, ensure_ascii=False))\n        except Exception as e:\n            return Message(text=json.dumps({\n                \"error\": f\"Error extracting operation context: {str(e)}\"\n            }, ensure_ascii=False))\n\n    def build_error_message(self) -> Message:\n        \"\"\"\n        Return error message if any issues occur.\n        🆕 Now includes multi-DC information.\n        \"\"\"\n        try:\n            search_result = self._get_search_result()\n\n            # 🆕 Extract multi-DC info\n            multi_dc_info = self._extract_multi_dc_info(search_result)\n\n            if search_result.get(\"status\") == \"error\":\n                return Message(text=json.dumps({\n                    \"error\": f\"Search error: {search_result.get('error_message')}\",\n                    \"block_exists\": False,\n                    **multi_dc_info  # 🆕 Include multi-DC info\n                }, ensure_ascii=False))\n            agent1_data = self._get_agent1_data(search_result)\n\n            # 🔥 НОВОЕ: Нормализовать\n            location_parameters = self._normalize_location_parameters(agent1_data)\n            operation = agent1_data.get(\"operation\", \"ADD_PARAMETERS\")\n            target_domains = agent1_data.get(\"domains\", [])\n            all_configs = search_result.get(\"all_configs\", [])\n            source_field = getattr(self, 'source_field', 'full_config_text')\n            if not all_configs:\n                return Message(text=json.dumps({\n                    \"error\": \"No configs found in all_configs\",\n                    \"block_exists\": False,\n                    **multi_dc_info  # 🆕 Include multi-DC info\n                }, ensure_ascii=False))\n            # Operation-specific checks\n            is_create_operation = operation == \"CREATE_LOCATION\"\n            is_delete_operation = operation == \"DELETE_LOCATION\"\n            found_count = 0\n            errors = []\n            # Check all configs\n            for config in all_configs:\n                if not isinstance(config, dict):  # Safeguard\n                    errors.append(f\"Invalid config type in all_configs: {type(config)} - skipping\")\n                    continue\n                matching_domains = config.get(\"matching_domains\", [])\n                server_names = config.get(\"server_names\", [])\n                # Skip configs that don't match target domains\n                if target_domains:\n                    if not any(domain in target_domains for domain in matching_domains):\n                        if not any(domain in target_domains for domain in server_names):\n                            continue\n                config_text = config.get(source_field)\n                if not config_text:\n                    errors.append(f\"No {source_field} in {config.get('config_key', 'unknown')}\")\n                    continue\n                try:\n                    key, server_directives, locations = self._parse_yaml_config(config_text)\n                    # Для каждой location проверить\n                    for loc_param in location_parameters:\n                        target_loc = loc_param.get(\"location\")\n                        if not target_loc:\n                            continue\n                        if not location_parameters:  # Server block\n                            if len(server_directives) > 0:\n                                found_count += 1\n                        elif is_create_operation:\n                            # For CREATE: config is valid if location DOESN'T exist\n                            found_location = self._find_location(locations, target_loc)\n                            if not found_location:\n                                found_count += 1  # Good - can create\n                            else:\n                                errors.append(\n                                    f\"Location '{target_loc}' already exists in {key}\"\n                                )\n                        elif is_delete_operation:\n                            # For DELETE: config is valid if location DOES exist\n                            found_location = self._find_location(locations, target_loc)\n                            if found_location:\n                                found_count += 1  # Good - can delete\n                            else:\n                                errors.append(\n                                    f\"Location '{target_loc}' not found in {key}. \"\n                                    f\"Available: {[loc.get('path') for loc in locations]}\"\n                                )\n                        else:\n                            # For other operations (including MODIFY_LOCATION_PATH, MAKE_PROTECTED, MAKE_PUBLIC): location must exist\n                            found_location = self._find_location(locations, target_loc)\n                            if found_location:\n                                found_count += 1\n                            else:\n                                errors.append(\n                                    f\"Location '{target_loc}' not found in {key}. \"\n                                    f\"Available: {[loc.get('path') for loc in locations]}\"\n                                )\n                except Exception as e:\n                    errors.append(f\"Error parsing {config.get('config_key', 'unknown')}: {str(e)}\")\n            if found_count > 0:\n                result = {\n                    \"error\": None,\n                    \"found_in_configs\": found_count,\n                    \"total_configs\": len(all_configs),\n                    \"operation\": operation,\n                    \"locations_count\": len(location_parameters),\n                    **multi_dc_info,  # 🆕 Include multi-DC info\n                }\n                if is_create_operation:\n                    result[\"can_create\"] = True\n                    result[\"block_exists\"] = False\n                elif is_delete_operation:\n                    result[\"can_delete\"] = True\n                    result[\"block_exists\"] = True\n                else:\n                    result[\"block_exists\"] = True\n                if errors:\n                    result[\"warnings\"] = errors\n\n                # 🆕 Add multi-DC warning if applicable\n                if multi_dc_info[\"found_in_multiple_dc\"]:\n                    if \"warnings\" not in result:\n                        result[\"warnings\"] = []\n                    result[\"warnings\"].insert(0,\n                                              f\"⚠️ MULTI-DC: Domain found in {multi_dc_info['dc_count']} datacenters!\"\n                                              )\n\n                return Message(text=json.dumps(result, ensure_ascii=False))\n            else:\n                error_msg = {\n                    \"block_exists\": False,\n                    \"total_configs_checked\": len(all_configs),\n                    \"operation\": operation,\n                    \"locations_count\": len(location_parameters),\n                    \"details\": errors,\n                    **multi_dc_info,  # 🆕 Include multi-DC info\n                }\n                if is_create_operation:\n                    error_msg[\"error\"] = (\n                        f\"Cannot create locations - they may already exist in all configs\"\n                    )\n                    error_msg[\"can_create\"] = False\n                elif is_delete_operation:\n                    error_msg[\"error\"] = (\n                        f\"Cannot delete locations - not found in any config\"\n                    )\n                    error_msg[\"can_delete\"] = False\n                else:\n                    error_msg[\"error\"] = (\n                        f\"Locations not found in any config\"\n                    )\n                return Message(text=json.dumps(error_msg, ensure_ascii=False))\n        except Exception as e:\n            return Message(text=json.dumps({\n                \"error\": f\"Error checking block: {str(e)}\",\n                \"block_exists\": False\n            }, ensure_ascii=False))\n"
              },
              "source_field": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Source field",
                "dynamic": false,
                "info": "Field containing YAML config text (full_config_text or config_block)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "source_field",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "full_config_text"
              },
              "universal_search_result": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Universal Search Result",
                "dynamic": false,
                "info": "Output from Universal Search (contains agent1_data)",
                "input_types": [
                  "Data",
                  "dict"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "universal_search_result",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "selected_block",
          "showNode": true,
          "type": "LocationSelectorFromUniversalSearch"
        },
        "dragging": false,
        "id": "LocationSelectorFromUniversalSearch-8dtdG",
        "measured": {
          "height": 263,
          "width": 320
        },
        "position": {
          "x": 1361.1113095942496,
          "y": 506.1026718509382
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "UniversalSearchConfigComponent-u7ief",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Универсально сканирует YML файлы по доменам из любой структуры JSON (включая Arbitrator payload)",
            "display_name": "Universal Search Config",
            "documentation": "",
            "edited": true,
            "field_order": [
              "agent1_json",
              "config_base_path"
            ],
            "frozen": false,
            "icon": "search",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Config Data",
                "group_outputs": false,
                "hidden": null,
                "method": "search_config",
                "name": "config_data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "agent1_json": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Agent 1 JSON Output",
                "dynamic": false,
                "info": "JSON с извлечёнными данными от Agent 1 или Arbitrator (любая структура)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "agent1_json",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, StrInput, Output\nfrom langflow.schema import Data\nimport json\nimport yaml\nimport os\nimport glob\nimport re\nfrom typing import List, Dict, Any, Optional\n\n\nclass UniversalSearchConfigComponent(Component):\n    display_name = \"Universal Search Config\"\n    description = \"Универсально сканирует YML файлы по доменам из любой структуры JSON (включая Arbitrator payload)\"\n    icon = \"search\"\n    inputs = [\n        MessageTextInput(\n            name=\"agent1_json\",\n            display_name=\"Agent 1 JSON Output\",\n            info=\"JSON с извлечёнными данными от Agent 1 или Arbitrator (любая структура)\",\n            required=True\n        ),\n        StrInput(\n            name=\"config_base_path\",\n            display_name=\"Config Base Path\",\n            info=\"Путь к родительской папке с конфигами (например, /path/to/mos_ru_nginx/)\",\n            value=\"/Users/rusk/PycharmProjects/fastapi/portalFastDjango/mosru_nginx/mos_ru_nginx/\",\n            required=True\n        )\n    ]\n    outputs = [\n        Output(\n            display_name=\"Config Data\",\n            name=\"config_data\",\n            method=\"search_config\"\n        )\n    ]\n\n    def search_config(self) -> Data:\n        \"\"\"\n        Универсально обрабатывает любой JSON/Python dict и ищет конфигурации\n        \"\"\"\n        try:\n            # 🔧 ПРЕДОБРАБОТКА: Очищаем от markdown блоков\n            cleaned_input = self._clean_markdown(self.agent1_json)\n\n            # 🔄 ПАРСИМ: Поддержка и JSON, и Python dict\n            raw_data = self._parse_input(cleaned_input)\n\n            # 🔄 НОРМАЛИЗАЦИЯ: Извлекаем payload если это Arbitrator output\n            agent1_data = self._normalize_input(raw_data)\n            # 🔍 УНИВЕРСАЛЬНОЕ ИЗВЛЕЧЕНИЕ ДОМЕНОВ\n            domains = self._universal_extract_domains(agent1_data)\n\n            # 🔍 УНИВЕРСАЛЬНОЕ ИЗВЛЕЧЕНИЕ ДРУГИХ ДАННЫХ\n            locations = self._universal_extract_locations(agent1_data)\n            ip_addresses = self._universal_extract_ips(agent1_data)\n            upstreams = self._universal_extract_upstreams(agent1_data)\n            parameters = self._universal_extract_parameters(agent1_data)\n            location_parameters = self._universal_extract_location_parameters(agent1_data)\n            operation = self._universal_extract_operation(agent1_data)\n            selected_dc = self._universal_extract_selected_dc(agent1_data)\n            # ✅ ПРОВЕРЯЕМ СТАТУС\n            status = self._check_status(raw_data)  # Проверяем оригинальные данные\n            if status and status.get(\"is_error\"):\n                return self._return_error_status(status, agent1_data)\n            # ❌ ОШИБКА: Домены не найдены\n            if not domains:\n                return self._return_no_domains_error(\n                    agent1_data, locations, ip_addresses, parameters, operation\n                )\n            # 🔍 ОПРЕДЕЛЯЕМ ПАПКИ ДЛЯ ПОИСКА\n            search_folders = self._get_search_folders(selected_dc)\n            # 🔍 СКАНИРУЕМ ВСЕ YML ФАЙЛЫ В ВЫБРАННЫХ ПАПКАХ\n            config_results = []\n            scanned_files = 0\n            for folder in search_folders:\n                folder_path = os.path.join(self.config_base_path, folder)\n                if not os.path.isdir(folder_path):\n                    continue\n                yml_files = glob.glob(os.path.join(folder_path, \"*.yml\"))\n                scanned_files += len(yml_files)\n                for yml_file in yml_files:\n                    file_results = self._scan_yml_file(yml_file, domains)\n                    for res in file_results:\n                        res[\"folder\"] = folder\n                        res[\"inferred_dc\"] = self._infer_dc_from_folder(folder)\n                    config_results.extend(file_results)\n            # Удаляем дубликаты (по полному пути и ключу)\n            unique_results = self._deduplicate_results(config_results)\n            # ❌ ОШИБКА: Конфиги не найдены\n            if not unique_results:\n                return self._return_not_found_error(\n                    domains, scanned_files, agent1_data,\n                    locations, ip_addresses, parameters, operation\n                )\n            # ✅ УСПЕХ: Конфиг найден\n            first_config = unique_results[0]\n\n            # 🆕 АНАЛИЗ: Проверяем, найден ли домен в нескольких ЦОД\n            multi_dc_info = self._analyze_multi_dc_presence(unique_results, domains)\n\n            result = {\n                \"status\": \"success\",\n\n                # 📦 Конфиг данные\n                \"config_file\": first_config[\"config_file\"],\n                \"config_key\": first_config[\"config_key\"],\n                \"full_config_text\": first_config[\"full_config_text\"],\n                \"server_names\": first_config[\"server_names\"],\n                \"matching_domains\": first_config[\"matching_domains\"],\n                # 📦 Извлечённые данные (нормализованные)\n                \"agent1_data\": agent1_data,\n                \"operation\": operation,\n                \"domains\": domains,\n                \"locations\": locations,\n                \"ip_addresses\": ip_addresses,\n                \"upstreams\": upstreams,\n                \"parameters\": parameters,\n                \"location_parameters\": location_parameters,\n                \"selected_dc\": selected_dc,\n                # 📊 Метаданные\n                \"scanned_files\": scanned_files,\n                \"found_configs\": len(unique_results),\n                \"all_configs\": unique_results,\n                \"data_complete\": True,\n                \"error_type\": None,\n                \"error_message\": None,\n\n                # 🆕 НОВЫЕ КЛЮЧИ: Информация о нахождении в нескольких ЦОД\n                \"found_in_multiple_dc\": multi_dc_info[\"found_in_multiple_dc\"],\n                \"dc_count\": multi_dc_info[\"dc_count\"],\n                \"unique_dcs\": multi_dc_info[\"unique_dcs\"],\n                \"domain_dc_mapping\": multi_dc_info[\"domain_dc_mapping\"],\n                \"domains_in_multiple_dc\": multi_dc_info[\"domains_in_multiple_dc\"],\n            }\n            # Формируем сообщение\n            msg = self._format_success_message(result)\n            return Data(data=result, text=msg)\n        except json.JSONDecodeError as e:\n            return self._return_json_error(e, self.agent1_json)\n        except Exception as e:\n            return self._return_unexpected_error(e)\n\n    # ==========================================\n    # 🆕 НОВЫЙ МЕТОД: Анализ присутствия в нескольких ЦОД\n    # ==========================================\n    def _analyze_multi_dc_presence(self, config_results: List[Dict], domains: List[str]) -> Dict:\n        \"\"\"\n        Анализирует, найден ли домен в нескольких ЦОД\n\n        Returns:\n            Dict с ключами:\n            - found_in_multiple_dc: bool - True если хотя бы один домен найден в >1 ЦОД\n            - dc_count: int - количество уникальных ЦОД где найдены конфиги\n            - unique_dcs: List[str] - список уникальных ЦОД\n            - domain_dc_mapping: Dict[str, List[str]] - маппинг домен -> список ЦОД\n            - domains_in_multiple_dc: List[str] - домены, найденные в нескольких ЦОД\n        \"\"\"\n        # Собираем все уникальные ЦОД из результатов\n        all_dcs = set()\n        for config in config_results:\n            inferred_dc = config.get(\"inferred_dc\", [])\n            all_dcs.update(inferred_dc)\n\n        unique_dcs = sorted(list(all_dcs))\n        dc_count = len(unique_dcs)\n\n        # Строим маппинг: домен -> в каких ЦОД найден\n        domain_dc_mapping = {}\n        for domain in domains:\n            domain_dcs = set()\n            for config in config_results:\n                matching_domains = config.get(\"matching_domains\", [])\n                if domain in matching_domains:\n                    inferred_dc = config.get(\"inferred_dc\", [])\n                    domain_dcs.update(inferred_dc)\n            domain_dc_mapping[domain] = sorted(list(domain_dcs))\n\n        # Определяем домены, которые найдены в нескольких ЦОД\n        domains_in_multiple_dc = [\n            domain for domain, dcs in domain_dc_mapping.items()\n            if len(dcs) > 1\n        ]\n\n        # Главный флаг: есть ли хотя бы один домен в нескольких ЦОД\n        found_in_multiple_dc = len(domains_in_multiple_dc) > 0\n\n        return {\n            \"found_in_multiple_dc\": found_in_multiple_dc,\n            \"dc_count\": dc_count,\n            \"unique_dcs\": unique_dcs,\n            \"domain_dc_mapping\": domain_dc_mapping,\n            \"domains_in_multiple_dc\": domains_in_multiple_dc\n        }\n\n    # ==========================================\n    # ПРЕДОБРАБОТКА И НОРМАЛИЗАЦИЯ\n    # ==========================================\n    def _clean_markdown(self, raw_input: str) -> str:\n        \"\"\"Убирает только markdown разметку\"\"\"\n        if not raw_input:\n            return raw_input\n\n        cleaned = raw_input.strip()\n\n        patterns = [\n            (r'^```json\\s*\\n', ''),\n            (r'^```\\s*\\n', ''),\n            (r'\\n```\\s*$', ''),\n            (r'^```json\\s*', ''),\n            (r'^```\\s*', ''),\n            (r'```\\s*$', ''),\n        ]\n\n        for pattern, replacement in patterns:\n            cleaned = re.sub(pattern, replacement, cleaned)\n\n        return cleaned.strip()\n\n    def _parse_input(self, text: str) -> Dict:\n        \"\"\"\n        🔄 Парсит входные данные — поддерживает JSON и Python dict\n        \"\"\"\n        # Способ 1: Пробуем как JSON\n        try:\n            return json.loads(text)\n        except json.JSONDecodeError:\n            pass\n\n        # Способ 2: Пробуем как Python dict через ast.literal_eval\n        try:\n            import ast\n            result = ast.literal_eval(text)\n            if isinstance(result, dict):\n                return result\n        except (ValueError, SyntaxError):\n            pass\n\n        # Способ 3: Ручная конвертация Python → JSON\n        try:\n            converted = text\n            converted = re.sub(r'\\bNone\\b', 'null', converted)\n            converted = re.sub(r'\\bTrue\\b', 'true', converted)\n            converted = re.sub(r'\\bFalse\\b', 'false', converted)\n            converted = converted.replace(\"'\", '\"')\n            return json.loads(converted)\n        except json.JSONDecodeError:\n            pass\n\n        # Если ничего не сработало — выбрасываем ошибку\n        raise json.JSONDecodeError(\n            f\"Не удалось распарсить ни как JSON, ни как Python dict\",\n            text,\n            0\n        )\n\n    def _normalize_input(self, raw_data: Any) -> Dict:\n        \"\"\"\n        🔄 НОРМАЛИЗАЦИЯ: Извлекает payload из Arbitrator output\n\n        Поддерживает форматы:\n        1. Arbitrator: {\"status\": \"SUCCESS\", \"payload\": {...}, \"ready_for_execution\": true}\n        2. Прямой Agent1: {\"operation\": \"...\", \"domain\": \"...\", ...}\n        3. Вложенный: {\"data\": {\"payload\": {...}}}\n        \"\"\"\n        if not isinstance(raw_data, dict):\n            return raw_data\n\n        # Случай 1: Arbitrator output с payload\n        if \"payload\" in raw_data and isinstance(raw_data[\"payload\"], dict):\n            # Проверяем что это успешный Arbitrator response\n            status = raw_data.get(\"status\", \"\").upper()\n            if status in [\"SUCCESS\", \"COMPLETE\", \"OK\"]:\n                return raw_data[\"payload\"]\n            # Даже если статус не SUCCESS, но payload есть — используем его\n            if raw_data[\"payload\"]:\n                return raw_data[\"payload\"]\n\n        # Случай 2: Вложенный data.payload\n        if \"data\" in raw_data and isinstance(raw_data[\"data\"], dict):\n            if \"payload\" in raw_data[\"data\"]:\n                return raw_data[\"data\"][\"payload\"]\n            return raw_data[\"data\"]\n\n        # Случай 3: Прямой Agent1 output (уже нормализован)\n        return raw_data\n\n    # ==========================================\n    # УНИВЕРСАЛЬНЫЕ МЕТОДЫ ИЗВЛЕЧЕНИЯ ДАННЫХ\n    # ==========================================\n    def _universal_extract_domains(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет домены во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        domains = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return domains\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"domain\", \"domains\", \"server_name\", \"server_names\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        domains.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                domains.append(item.strip())\n\n            for value in data.values():\n                domains.extend(self._universal_extract_domains(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                domains.extend(self._universal_extract_domains(item, visited))\n\n        return list(set([d for d in domains if d and self._looks_like_domain(d)]))\n\n    def _universal_extract_locations(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет location/locations во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        locations = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return locations\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"location\", \"locations\", \"kms_locations\", \"public_locations\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        locations.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                locations.append(item.strip())\n\n            for value in data.values():\n                if isinstance(value, (dict, list)):\n                    locations.extend(self._universal_extract_locations(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                locations.extend(self._universal_extract_locations(item, visited))\n\n        return list(set([loc for loc in locations if loc and loc.startswith(\"/\")]))\n\n    def _universal_extract_ips(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет IP адреса во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        ips = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return ips\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"ip_addresses\", \"ips\", \"servers\", \"upstream\", \"ip\", \"address\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        ips.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                ips.append(item.strip())\n\n            for value in data.values():\n                if isinstance(value, (dict, list)):\n                    ips.extend(self._universal_extract_ips(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                ips.extend(self._universal_extract_ips(item, visited))\n\n        return list(set([ip for ip in ips if ip and self._looks_like_ip(ip)]))\n\n    def _universal_extract_upstreams(self, data: Any, visited: Optional[set] = None) -> List[Dict]:\n        \"\"\"\n        🆕 Извлекает структурированные upstreams\n\n        Формат входа:\n        \"upstreams\": [\n            {\"upstream_type\": \"main\", \"ip_addresses\": [\"10.10.10.10\", ...], \"params\": []},\n            {\"upstream_type\": \"backup\", \"ip_addresses\": [...], \"params\": []}\n        ]\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        upstreams = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return upstreams\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            # Прямой ключ upstreams\n            if \"upstreams\" in data and isinstance(data[\"upstreams\"], list):\n                for upstream in data[\"upstreams\"]:\n                    if isinstance(upstream, dict):\n                        normalized = {\n                            \"type\": upstream.get(\"upstream_type\", upstream.get(\"type\", \"main\")),\n                            \"ip_addresses\": upstream.get(\"ip_addresses\", upstream.get(\"ips\", [])),\n                            \"params\": upstream.get(\"params\", upstream.get(\"parameters\", []))\n                        }\n                        if normalized[\"ip_addresses\"]:\n                            upstreams.append(normalized)\n\n            # Рекурсивный поиск\n            for key, value in data.items():\n                if key != \"upstreams\" and isinstance(value, (dict, list)):\n                    upstreams.extend(self._universal_extract_upstreams(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                upstreams.extend(self._universal_extract_upstreams(item, visited))\n\n        return upstreams\n\n    def _universal_extract_location_parameters(self, data: Any, visited: Optional[set] = None) -> List[Dict]:\n        \"\"\"\n        🆕 Извлекает параметры для конкретных locations\n\n        Формат входа:\n        \"location_parameters\": [\n            {\"location\": \"/api_V2/\", \"parameters\": [], \"kms_required\": false},\n            ...\n        ]\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        loc_params = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return loc_params\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            if \"location_parameters\" in data and isinstance(data[\"location_parameters\"], list):\n                for lp in data[\"location_parameters\"]:\n                    if isinstance(lp, dict) and \"location\" in lp:\n                        normalized = {\n                            \"location\": lp.get(\"location\"),\n                            \"parameters\": lp.get(\"parameters\", []),\n                            \"kms_required\": lp.get(\"kms_required\", False)\n                        }\n                        loc_params.append(normalized)\n\n            for key, value in data.items():\n                if key != \"location_parameters\" and isinstance(value, (dict, list)):\n                    loc_params.extend(self._universal_extract_location_parameters(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                loc_params.extend(self._universal_extract_location_parameters(item, visited))\n\n        return loc_params\n\n    def _universal_extract_parameters(self, data: Any, visited: Optional[set] = None) -> Dict:\n        \"\"\"\n        Ищет общие параметры в структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        parameters = {}\n\n        data_id = id(data)\n        if data_id in visited:\n            return parameters\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            # server_block_parameters\n            if \"server_block_parameters\" in data:\n                params = data[\"server_block_parameters\"]\n                if isinstance(params, list):\n                    parameters[\"server_block\"] = params\n                elif isinstance(params, dict):\n                    parameters[\"server_block\"] = params\n\n            # Общие parameters\n            if \"parameters\" in data:\n                params = data[\"parameters\"]\n                if isinstance(params, dict):\n                    parameters.update(params)\n                elif isinstance(params, list):\n                    parameters[\"general\"] = params\n\n            # Рекурсивно (но не в уже обработанные ключи)\n            for key, value in data.items():\n                if key not in [\"parameters\", \"server_block_parameters\", \"location_parameters\"] \\\n                        and isinstance(value, (dict, list)):\n                    sub_params = self._universal_extract_parameters(value, visited)\n                    for k, v in sub_params.items():\n                        if k not in parameters:\n                            parameters[k] = v\n\n        elif isinstance(data, list):\n            for item in data:\n                sub_params = self._universal_extract_parameters(item, visited)\n                parameters.update(sub_params)\n\n        return parameters\n\n    def _universal_extract_operation(self, data: Any) -> Optional[str]:\n        \"\"\"\n        Ищет тип операции в любой структуре\n        \"\"\"\n        if isinstance(data, dict):\n            for key in [\"operation\", \"operation_type\", \"action\", \"type\"]:\n                if key in data and data[key]:\n                    val = str(data[key])\n                    # Фильтруем не-операции\n                    if val.upper() not in [\"MAIN\", \"BACKUP\", \"PREFIX\", \"EXACT\"]:\n                        return val\n\n            for value in data.values():\n                if isinstance(value, (dict, list)):\n                    result = self._universal_extract_operation(value)\n                    if result:\n                        return result\n\n        elif isinstance(data, list):\n            for item in data:\n                result = self._universal_extract_operation(item)\n                if result:\n                    return result\n\n        return None\n\n    def _universal_extract_selected_dc(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет selected_dc во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        dcs = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return dcs\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"selected_dc\", \"dc\", \"datacenters\", \"datacenter\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        dcs.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                dcs.append(item.strip())\n\n            for value in data.values():\n                dcs.extend(self._universal_extract_selected_dc(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                dcs.extend(self._universal_extract_selected_dc(item, visited))\n\n        return list(set(dcs))\n\n    def _check_status(self, data: Any) -> Optional[Dict]:\n        \"\"\"\n        Проверяет статус ошибки в данных\n        \"\"\"\n        if isinstance(data, dict):\n            status = data.get(\"status\", \"\")\n\n            # Ошибка Arbitrator\n            if status == \"VALIDATION_FAILED\":\n                return {\n                    \"is_error\": True,\n                    \"status\": status,\n                    \"error_type\": \"VALIDATION_FAILED\",\n                    \"error_message\": \"Валидация не прошла\",\n                    \"missing_fields\": data.get(\"missing_fields\", []),\n                    \"clarification_questions\": data.get(\"clarification_questions\", [])\n                }\n\n            # Ошибка Agent1\n            if status == \"error\":\n                return {\n                    \"is_error\": True,\n                    \"status\": data.get(\"status\"),\n                    \"error_type\": data.get(\"error_type\"),\n                    \"error_message\": data.get(\"error_message\"),\n                    \"explanation\": data.get(\"explanation\"),\n                    \"warnings\": data.get(\"warnings\", [])\n                }\n        return None\n\n    # ==========================================\n    # ВАЛИДАЦИЯ\n    # ==========================================\n    def _looks_like_domain(self, text: str) -> bool:\n        \"\"\"Проверяет, похоже ли на домен\"\"\"\n        if not text or len(text) < 3:\n            return False\n        return '.' in text or re.match(r'^[a-zA-Z0-9\\-\\.]+$', text) is not None\n\n    def _looks_like_ip(self, text: str) -> bool:\n        \"\"\"Проверяет, похоже ли на IP адрес\"\"\"\n        if not text:\n            return False\n        ip_pattern = r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d+)?$'\n        return re.match(ip_pattern, text) is not None\n\n    # ==========================================\n    # ЛОГИКА ПОИСКА ПО ПАПКАМ И DC\n    # ==========================================\n    def _get_all_folders(self) -> List[str]:\n        \"\"\"Возвращает список всех возможных папок\"\"\"\n        return [\n            \"production_ext_kor_sites\",\n            \"production_ext_nag_http\",\n            \"production_ext_nag_sites\",\n            \"production_ext_sites\",\n            \"production_kor_ngate_sites\",\n            \"production_kor_sites\",\n            \"production_mesh_main_kor_sites\",\n            \"production_mesh_rus_kor_sites\",\n            \"production_metro_kor_sites\",\n            \"production_metro_sites\",\n            \"production_moshub_ext_kor_sites\",\n            \"production_moshub_kor_sites\",\n            \"production_nag_sites\",\n            \"production_sites\",\n            \"production_upload_sites\",\n            \"stage_kor_sites\",\n            \"stage_nag_sites\",\n            \"stage_sites\",\n            \"test_kor_sites\",\n            \"test_nag_sites\",\n            \"test_sites\"\n        ]\n\n    def _get_search_folders(self, selected_dc: List[str]) -> List[str]:\n        \"\"\"Определяет папки для поиска на основе selected_dc\"\"\"\n        all_folders = self._get_all_folders()\n        if not selected_dc:\n            return all_folders\n\n        search_folders = set()\n        for dc in selected_dc:\n            if dc == \"dr\":\n                search_folders.update(self._get_folders_for_dc(\"korovinskiy\"))\n                search_folders.update(self._get_folders_for_dc(\"kurchatovskiy\"))\n            else:\n                search_folders.update(self._get_folders_for_dc(dc))\n        return list(search_folders)\n\n    def _get_folders_for_dc(self, dc: str) -> List[str]:\n        \"\"\"Возвращает папки для конкретного DC\"\"\"\n        all_folders = self._get_all_folders()\n\n        if dc == \"korovinskiy\":\n            # Исключаем metro и mesh - они относятся к отдельным DC\n            return [f for f in all_folders\n                    if \"_kor_\" in f\n                    and \"metro\" not in f\n                    and \"mesh\" not in f]\n\n        elif dc == \"kurchatovskiy\":\n            return [f for f in all_folders if\n                    f in [\"production_sites\", \"stage_sites\", \"test_sites\", \"production_ext_sites\",\n                          \"production_upload_sites\"]]  # убрал production_metro_sites\n\n        elif dc == \"nagornaya\":\n            return [f for f in all_folders if \"_nag_\" in f]\n\n        elif dc == \"moshub_rus\":\n            return [f for f in all_folders if \"moshub\" in f and \"ext\" not in f]\n\n        elif dc == \"ext_kurchatovskiy\":\n            return [f for f in all_folders if \"ext\" in f and \"_kor_\" not in f and \"_nag_\" not in f]\n\n        elif dc == \"ext_korovinskiy\":\n            return [f for f in all_folders if \"ext\" in f and \"_kor_\" in f]\n\n        elif dc == \"ext_nagornaya\":\n            return [f for f in all_folders if \"ext\" in f and \"_nag_\" in f]\n\n        elif dc == \"mesh\":\n            return [f for f in all_folders if \"mesh\" in f]\n\n        elif dc == \"top10_kurchatovskiy\":\n            return [f for f in all_folders if \"metro\" in f and \"_kor_\" not in f]\n\n        elif dc == \"top10_korovinskiy\":\n            return [f for f in all_folders if \"metro\" in f and \"_kor_\" in f]\n\n        return []\n\n    def _infer_dc_from_folder(self, folder: str) -> List[str]:\n        \"\"\"Определяет DC на основе имени папки\"\"\"\n        dcs = []\n        folder_lower = folder.lower()\n        if \"_kor_\" in folder_lower:\n            dcs.append(\"korovinskiy\")\n        if \"_nag_\" in folder_lower:\n            dcs.append(\"nagornaya\")\n        if folder in [\"production_sites\", \"stage_sites\", \"test_sites\", \"production_ext_sites\", \"production_metro_sites\",\n                      \"production_upload_sites\"]:\n            dcs.append(\"kurchatovskiy\")\n        if \"mesh\" in folder_lower:\n            dcs.append(\"mesh\")\n        if \"moshub\" in folder_lower:\n            dcs.append(\"moshub_rus\")\n        if \"metro\" in folder_lower:\n            if \"_kor_\" in folder_lower:\n                dcs.append(\"top10_korovinskiy\")\n            else:\n                dcs.append(\"top10_kurchatovskiy\")\n        if \"ext\" in folder_lower:\n            if \"_kor_\" in folder_lower:\n                dcs.append(\"ext_korovinskiy\")\n            elif \"_nag_\" in folder_lower:\n                dcs.append(\"ext_nagornaya\")\n            else:\n                dcs.append(\"ext_kurchatovskiy\")\n        return list(set(dcs))\n\n    # ==========================================\n    # СКАНИРОВАНИЕ YML\n    # ==========================================\n    def _scan_yml_file(self, yml_file: str, target_domains: List[str]) -> List[Dict]:\n        \"\"\"Сканирует один YML файл и находит совпадения по server_name\"\"\"\n        results = []\n        try:\n            with open(yml_file, 'r', encoding='utf-8') as f:\n                config_text = f.read()\n                config_yaml = yaml.safe_load(config_text)\n            if not config_yaml:\n                return results\n            for config_key, config_block in config_yaml.items():\n                server_names = self._extract_server_names(config_block)\n                if not server_names:\n                    continue\n                matching_domains = []\n                for target_domain in target_domains:\n                    if self._is_domain_match(target_domain, server_names):\n                        matching_domains.append(target_domain)\n                if matching_domains:\n                    result = {\n                        \"config_key\": config_key,\n                        \"config_file\": yml_file,\n                        \"server_names\": server_names,\n                        \"matching_domains\": matching_domains,\n                        \"full_config_text\": config_text,\n                        \"parsed_yaml\": config_yaml,\n                        \"config_block\": config_block\n                    }\n                    results.append(result)\n        except yaml.YAMLError as e:\n            print(f\"⚠️ Ошибка чтения YAML {yml_file}: {e}\")\n        except Exception as e:\n            print(f\"⚠️ Ошибка обработки {yml_file}: {e}\")\n        return results\n\n    def _extract_server_names(self, config_block: Any) -> List[str]:\n        \"\"\"Извлекает все server_name из конфигурационного блока\"\"\"\n        server_names = []\n        if isinstance(config_block, list):\n            for item in config_block:\n                if isinstance(item, str) and item.startswith(\"server_name \"):\n                    server_name_part = item.replace(\"server_name \", \"\").strip()\n                    names = [n.strip() for n in server_name_part.split() if n.strip()]\n                    server_names.extend(names)\n        return list(set(server_names))\n\n    def _is_domain_match(self, target_domain: str, server_names: List[str]) -> bool:\n        \"\"\"Проверяет, совпадает ли target_domain с любым server_name\"\"\"\n        target_domain = target_domain.strip().lower()\n        for server_name in server_names:\n            server_name = server_name.strip().lower()\n            if server_name == target_domain:\n                return True\n            if server_name.startswith(\"~^\") and server_name.endswith(\"$\"):\n                pattern = server_name[2:-1]\n                try:\n                    if re.match(pattern, target_domain):\n                        return True\n                except re.error:\n                    continue\n        return False\n\n    def _deduplicate_results(self, results: List[Dict]) -> List[Dict]:\n        \"\"\"Удаляет дубликаты результатов\"\"\"\n        seen = set()\n        unique = []\n        for result in results:\n            key = (result[\"config_file\"], result[\"config_key\"])\n            if key not in seen:\n                seen.add(key)\n                unique.append(result)\n        return unique\n\n    # ==========================================\n    # ОБРАБОТКА ОШИБОК\n    # ==========================================\n    def _return_error_status(self, status: Dict, agent1_data: Any) -> Data:\n        \"\"\"Возвращает ошибку из статуса\"\"\"\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": status.get(\"error_type\", \"UNKNOWN_ERROR\"),\n            \"error_message\": status.get(\"error_message\", \"Unknown error\"),\n            \"explanation\": status.get(\"explanation\", \"\"),\n            \"warnings\": status.get(\"warnings\", []),\n            \"missing_fields\": status.get(\"missing_fields\", []),\n            \"clarification_questions\": status.get(\"clarification_questions\", []),\n            \"agent1_data\": agent1_data,\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: {status.get('error_message')}\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        questions = status.get(\"clarification_questions\", [])\n        missing = status.get(\"missing_fields\", [])\n\n        error_msg = f\"\"\"❌ **Ошибка**\n🔴 **Тип:** {status.get('error_type')}\n📝 **Сообщение:** {status.get('error_message')}\n\"\"\"\n        if missing:\n            error_msg += f\"\\n📋 **Не хватает:** {', '.join(missing[:3])}\"\n        if questions:\n            error_msg += f\"\\n❓ **Вопросы:** {questions[0]}\"\n        return Data(data=error_result, text=error_msg)\n\n    def _return_no_domains_error(self, agent1_data: Any, locations: List[str],\n                                 ip_addresses: List[str], parameters: Dict,\n                                 operation: Optional[str]) -> Data:\n        \"\"\"Возвращает ошибку об отсутствии доменов\"\"\"\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": \"NO_DOMAINS\",\n            \"error_message\": \"Домены не найдены в данных\",\n            \"agent1_data\": agent1_data,\n            \"operation\": operation,\n            \"locations\": locations,\n            \"ip_addresses\": ip_addresses,\n            \"parameters\": parameters,\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": \"# Error: No domains specified\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        error_msg = f\"\"\"❌ **Ошибка: домен не указан**\n📋 **Что извлечено:**\n- Operation: {operation or 'N/A'}\n- Locations: {', '.join(locations[:3]) if locations else 'N/A'}\n- IPs: {', '.join(ip_addresses[:3]) if ip_addresses else 'N/A'}\n💡 Укажите домен явно в запросе.\n\"\"\"\n        return Data(data=error_result, text=error_msg)\n\n    def _return_not_found_error(self, domains: List[str], scanned_files: int,\n                                agent1_data: Any, locations: List[str],\n                                ip_addresses: List[str], parameters: Dict,\n                                operation: Optional[str]) -> Data:\n        \"\"\"Возвращает ошибку о ненайденной конфигурации\"\"\"\n        not_found_result = {\n            \"status\": \"not_found\",\n            \"error_type\": \"CONFIG_NOT_FOUND\",\n            \"error_message\": f\"Конфигурация не найдена для: {', '.join(domains)}\",\n            \"domains\": domains,\n            \"scanned_files\": scanned_files,\n            \"agent1_data\": agent1_data,\n            \"operation\": operation,\n            \"locations\": locations,\n            \"ip_addresses\": ip_addresses,\n            \"parameters\": parameters,\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: Config not found for: {', '.join(domains)}\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        error_msg = f\"\"\"❌ **Конфигурация не найдена**\n🔍 **Домены:** {', '.join(domains)}\n📊 **Просканировано:** {scanned_files} файлов\n\"\"\"\n        return Data(data=not_found_result, text=error_msg)\n\n    def _return_json_error(self, error: Exception, raw_json: str) -> Data:\n        \"\"\"Возвращает ошибку парсинга JSON\"\"\"\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": \"JSON_PARSE_ERROR\",\n            \"error_message\": f\"Ошибка парсинга JSON: {str(error)}\",\n            \"raw_input\": raw_json[:500],\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: JSON parse error\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        return Data(data=error_result, text=f\"❌ **Ошибка парсинга JSON**\\n\\n{str(error)}\")\n\n    def _return_unexpected_error(self, error: Exception) -> Data:\n        \"\"\"Возвращает неожиданную ошибку\"\"\"\n        import traceback\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": \"UNEXPECTED_ERROR\",\n            \"error_message\": f\"Неожиданная ошибка: {str(error)}\",\n            \"traceback\": traceback.format_exc(),\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: {str(error)}\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        print(f\"❌ UNEXPECTED ERROR: {str(error)}\")\n        traceback.print_exc()\n        return Data(data=error_result, text=f\"❌ **Неожиданная ошибка**\\n\\n{str(error)}\")\n\n    # ==========================================\n    # ФОРМАТИРОВАНИЕ РЕЗУЛЬТАТА\n    # ==========================================\n    def _format_success_message(self, result: Dict) -> str:\n        \"\"\"Формирует читаемое сообщение о результате\"\"\"\n        all_configs = result.get(\"all_configs\", [])\n        found_configs = len(all_configs)\n        scanned_files = result.get(\"scanned_files\", 0)\n        operation = result.get(\"operation\")\n        locations = result.get(\"locations\", [])\n        upstreams = result.get(\"upstreams\", [])\n        location_parameters = result.get(\"location_parameters\", [])\n        selected_dc = result.get(\"selected_dc\", [])\n\n        # 🆕 Новые данные о multi-DC\n        found_in_multiple_dc = result.get(\"found_in_multiple_dc\", False)\n        dc_count = result.get(\"dc_count\", 0)\n        unique_dcs = result.get(\"unique_dcs\", [])\n        domains_in_multiple_dc = result.get(\"domains_in_multiple_dc\", [])\n        domain_dc_mapping = result.get(\"domain_dc_mapping\", {})\n\n        msg = f\"✅ **Найдено {found_configs} конфигурац{'ия' if found_configs == 1 else 'ий' if 2 <= found_configs <= 4 else 'ий'}**\\n\\n\"\n\n        # 🆕 Предупреждение о нескольких ЦОД\n        if found_in_multiple_dc:\n            msg += f\"⚠️ **ВНИМАНИЕ: Домен найден в {dc_count} ЦОД!**\\n\\n\"\n   \n\n            msg += f\"🏢 **ЦОД:** {', '.join(unique_dcs)}\\n\"\n            if domains_in_multiple_dc:\n                msg += f\"🌐 **Домены в нескольких ЦОД:** {', '.join(domains_in_multiple_dc)}\\n\"\n            msg += \"\\n\"\n\n        for i, cfg in enumerate(all_configs):\n            if i > 0:\n                msg += \"\\n\" + (\"-\" * 40) + \"\\n\\n\"\n            msg += f\"📁 **Файл:** `{os.path.basename(cfg['config_file'])}`\\n\"\n            server_names = cfg.get(\"server_names\", [])\n            msg += f\"🌐 **Server names:** {', '.join(server_names[:3])}{'...' if len(server_names) > 3 else ''}\\n\"\n            matching_domains = cfg.get(\"matching_domains\", [])\n            msg += f\"✅ **Совпадения:** {', '.join(matching_domains)}\\n\"\n            inferred_dc = cfg.get(\"inferred_dc\", [])\n            if inferred_dc:\n                msg += f\"🏢 **DC:** {', '.join(inferred_dc)}\\n\"\n            else:\n                msg += f\"🏢 **DC:** N/A\\n\"\n\n        msg += f\"\\n📊 **Просканировано:** {scanned_files} файлов\"\n\n        if selected_dc:\n            msg += f\"\\n🗺 **Selected DC:** {', '.join(selected_dc)}\"\n        if operation:\n            msg += f\"\\n🔄 **Operation:** {operation}\"\n        if locations:\n            msg += f\"\\n📍 **Locations:** {', '.join(locations[:5])}\"\n        if upstreams:\n            for up in upstreams[:2]:\n                ips = up.get(\"ip_addresses\", [])\n                up_type = up.get(\"type\", \"unknown\")\n                msg += f\"\\n🔗 **Upstream ({up_type}):** {', '.join(ips[:3])}\"\n        if location_parameters:\n            msg += f\"\\n⚙️ **Location params:** {len(location_parameters)} записей\"\n\n        # 🆕 Расширенное примечание\n        if found_in_multiple_dc:\n            msg += \"\\n\\n⚠️ **ВАЖНО:** Конфигурация найдена в нескольких ЦОД. \"\n            msg += \"Убедитесь, что изменения применяются ко всем необходимым площадкам!\"\n            # Детальный маппинг\n            if domain_dc_mapping:\n                msg += \"\\n\\n📋 **Детали по доменам:**\"\n                for domain, dcs in domain_dc_mapping.items():\n                    if len(dcs) > 1:\n                        msg += f\"\\n  • `{domain}` → {', '.join(dcs)}\"\n        elif found_configs > 1:\n            msg += \"\\n\\nℹ️ **Примечание:** Найдено несколько конфигураций. Проверьте все варианты.\"\n\n        return msg\n"
              },
              "config_base_path": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Config Base Path",
                "dynamic": false,
                "info": "Путь к родительской папке с конфигами (например, /path/to/mos_ru_nginx/)",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "config_base_path",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "/Users/rusk/PycharmProjects/fastapi/portalFastDjango/mosru_nginx/mos_ru_nginx/production_kor_sites"
              }
            },
            "tool_mode": false
          },
          "selected_output": "config_file_path",
          "showNode": true,
          "type": "UniversalSearchConfigComponent"
        },
        "dragging": false,
        "id": "UniversalSearchConfigComponent-u7ief",
        "measured": {
          "height": 317,
          "width": 320
        },
        "position": {
          "x": 444.59719699456537,
          "y": 713.5723454126506
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-6T9YF",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-6T9YF",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": 1347.7913474667002,
          "y": 894.7400138206834
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-crLPm",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-crLPm",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1814.8121857703932,
          "y": 1189.0877582102598
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConfigBlockSplitter-gNsct",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Splits config blocks array into DataFrame for sequential Loop/LLM processing",
            "display_name": "Config Block Splitter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "selected_block"
            ],
            "frozen": false,
            "icon": "split",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Config Items DataFrame",
                "group_outputs": false,
                "hidden": null,
                "method": "build_config_dataframe",
                "name": "config_items_df",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Total Count",
                "group_outputs": false,
                "hidden": null,
                "method": "build_total_count",
                "name": "total_count",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Metadata",
                "group_outputs": false,
                "hidden": null,
                "method": "build_metadata",
                "name": "metadata",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.message import Message\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template.field.base import Output\nimport json\nimport pandas as pd\nfrom typing import Union, List, Dict, Any\n\n\nclass ConfigBlockSplitter(Component):\n    \"\"\"\n    Splits normalized config blocks from LocationSelector into individual items for Loop processing.\n    Properly handles Message input from LocationSelectorFromUniversalSearch.\n    Converts selected_blocks array into DataFrame format suitable for Loop component.\n\n    NEW: Supports block-level warnings for unknown operations like MAKE_PROTECTED\n    \"\"\"\n\n    display_name = \"Config Block Splitter\"\n    description = \"Splits config blocks array into DataFrame for sequential Loop/LLM processing\"\n    documentation = \"\"\n    icon = \"split\"\n\n    inputs = [\n        HandleInput(\n            name=\"selected_block\",\n            display_name=\"Selected Block\",\n            input_types=[\"Message\", \"Data\", \"dict\"],\n            info=\"Output from LocationSelectorFromUniversalSearch containing selected_blocks\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Config Items DataFrame\",\n            name=\"config_items_df\",\n            info=\"DataFrame with individual config blocks for Loop processing\",\n            method=\"build_config_dataframe\",\n        ),\n        Output(\n            display_name=\"Total Count\",\n            name=\"total_count\",\n            info=\"Total number of config blocks to process\",\n            method=\"build_total_count\",\n        ),\n        Output(\n            display_name=\"Metadata\",\n            name=\"metadata\",\n            info=\"Additional metadata from the original response\",\n            method=\"build_metadata\",\n        ),\n    ]\n\n    def process_input_data(self, data: Union[Message, Data, dict, str]) -> dict:\n        \"\"\"Convert input to dictionary format - handles Message, Data, dict, and JSON string\"\"\"\n        try:\n            # Handle Message type (from LocationSelector)\n            if isinstance(data, Message):\n                text = data.text if hasattr(data, 'text') else str(data)\n                return json.loads(text)\n\n            # Handle Data type\n            elif isinstance(data, Data):\n                if hasattr(data, 'data'):\n                    data_content = data.data\n                    if isinstance(data_content, str):\n                        return json.loads(data_content)\n                    return data_content\n                elif hasattr(data, 'to_dict'):\n                    return data.to_dict()\n                else:\n                    return dict(data)\n\n            # Handle dict\n            elif isinstance(data, dict):\n                return data\n\n            # Handle JSON string\n            elif isinstance(data, str):\n                return json.loads(data)\n\n            else:\n                raise ValueError(f\"Unexpected input type: {type(data)}\")\n\n        except json.JSONDecodeError as e:\n            self.log(f\"JSON decode error: {str(e)}\")\n            raise ValueError(f\"Invalid JSON in input: {str(e)}\")\n        except Exception as e:\n            self.log(f\"Error processing input: {str(e)}\")\n            raise\n\n    def extract_config_blocks(self, input_data: dict) -> List[Dict[str, Any]]:\n        \"\"\"Extract selected_blocks array from input data\"\"\"\n        if 'selected_blocks' in input_data:\n            blocks = input_data['selected_blocks']\n            # Ensure it's a list\n            if isinstance(blocks, list):\n                return blocks\n            elif isinstance(blocks, dict):\n                # Single block wrapped in dict - convert to list\n                return [blocks]\n            else:\n                self.log(f\"Warning: selected_blocks is not a list or dict: {type(blocks)}\")\n                return []\n\n        # Fallback: try to find blocks in nested structure\n        if 'selected_block' in input_data:\n            block_data = input_data['selected_block']\n            if isinstance(block_data, list):\n                return block_data\n            elif isinstance(block_data, dict) and 'selected_blocks' in block_data:\n                return block_data['selected_blocks']\n\n        # If no selected_blocks found, return empty list\n        self.log(\"Warning: No selected_blocks found in input data\")\n        return []\n\n    def build_config_dataframe(self) -> DataFrame:\n        \"\"\"Convert selected_blocks array into DataFrame for Loop component\"\"\"\n        try:\n            # Process input data\n            input_data = self.process_input_data(self.selected_block)\n\n            # Check for errors in input\n            if 'error' in input_data and not input_data.get('selected_blocks'):\n                self.log(f\"Error in input data: {input_data.get('error')}\")\n                return DataFrame(pd.DataFrame(columns=['error'], data=[{'error': input_data.get('error')}]))\n\n            # Extract config blocks\n            config_blocks = self.extract_config_blocks(input_data)\n\n            # НОВОЕ: Извлекаем глобальные warnings\n            global_warnings = input_data.get('warnings', [])\n            if global_warnings:\n                self.log(f\"Found {len(global_warnings)} global warnings: {global_warnings}\")\n\n            if not config_blocks:\n                # Return empty DataFrame with expected structure\n                self.log(\"No config blocks found, returning empty DataFrame\")\n                return DataFrame(pd.DataFrame(columns=[\n                    'index', 'config_key', 'config_file', 'server_names',\n                    'location_path', 'operation', 'type', 'full_config_json', \n                ]))\n\n            # 🔥 НОВОЕ: Функция проверки на MULTI-DC warning\n            def has_multi_dc_warning(warnings_list: List[str]) -> bool:\n                \"\"\"Проверяет, содержится ли MULTI-DC warning в списке\"\"\"\n                if not warnings_list:\n                    return False\n                for warning in warnings_list:\n                    if isinstance(warning, str) and \"MULTI-DC: Domain found in\" in warning and \"datacenters\" in warning:\n                        return True\n                return False\n\n            # Prepare data for DataFrame\n            df_data = []\n            filtered_blocks = []  # 🔥 НОВОЕ: Собираем отфильтрованные блоки\n            filtered_count = 0\n\n            for idx, block in enumerate(config_blocks):\n                if not isinstance(block, dict):\n                    self.log(f\"Warning: Block {idx} is not a dict, skipping\")\n                    continue\n\n                # Объединяем warnings блока и глобальные warnings\n                block_warnings = block.get('warnings', [])\n                combined_warnings = []\n\n                # Определяем, содержит ли блок домены, которые находятся в нескольких ДЦ\n                domains_in_multi_dc = set(input_data.get(\"domains_in_multiple_dc\", []))\n                block_domains = block.get('matching_domains', [])\n                block_in_multi_dc = any(domain in domains_in_multi_dc for domain in block_domains)\n\n                # Добавляем глобальные warnings ТОЛЬКО если блок относится к multi-DC домену\n                if block_in_multi_dc and global_warnings:\n                    combined_warnings.extend(global_warnings)\n\n                # Добавляем warnings конкретного блока\n                if block_warnings:\n                    if isinstance(block_warnings, list):\n                        combined_warnings.extend(block_warnings)\n                    elif isinstance(block_warnings, str):\n                        combined_warnings.append(block_warnings)\n\n                # 🔥 ФИЛЬТРАЦИЯ: Пропускаем блоки с MULTI-DC warning\n                if has_multi_dc_warning(combined_warnings):\n                    filtered_count += 1\n                    filtered_blocks.append(block)  # 🔥 Сохраняем для информации\n                    self.log(\n                        f\"⚠️ Filtering out block {idx} ({block.get('location_path', 'unknown')}) - contains MULTI-DC warning\")\n                    continue\n\n                # Логируем для информации\n                if combined_warnings:\n                    self.log(\n                        f\"Block {idx} ({block.get('location_path', 'unknown')}): {len(combined_warnings)} warnings - {combined_warnings}\")\n\n                # Each row will contain the full block data\n                row = {\n                    'index': idx,\n                    'config_key': block.get('config_key', ''),\n                    'config_file': block.get('config_file', ''),\n                    'server_names': json.dumps(block.get('server_names', []), ensure_ascii=False),\n                    'matching_domains': json.dumps(block.get('matching_domains', []), ensure_ascii=False),\n                    'location_path': block.get('location_path', ''),\n                    'operation': block.get('operation', ''),\n                    'type': block.get('type', 'location'),\n                    'hash': block.get('hash', ''),\n\n                    # Arrays as JSON strings\n                    'directives': json.dumps(block.get('directives', []), ensure_ascii=False),\n                    'parameters': json.dumps(block.get('parameters', []), ensure_ascii=False),\n                    'server_block_parameters': json.dumps(block.get('server_block_parameters', []), ensure_ascii=False),\n                    'existing_locations': json.dumps(block.get('existing_locations', []), ensure_ascii=False),\n                    'ip_addresses': json.dumps(block.get('ip_addresses', []), ensure_ascii=False),\n                    'upstreams': json.dumps(block.get('upstreams', []) if block.get('upstreams') else [],\n                                            ensure_ascii=False),\n\n                    'warnings': json.dumps(combined_warnings, ensure_ascii=False),\n\n                    # Boolean and special fields\n                    'kms_required': block.get('kms_required', False),\n                    'create_mode': block.get('create_mode', False),\n                    'delete_mode': block.get('delete_mode', False),\n\n                    # NEW: Support for MODIFY_LOCATION_PATH\n                    'new_location_path': block.get('new_location_path', ''),\n\n                    # Store complete block as JSON string for full context\n                    'full_config_json': json.dumps(block, ensure_ascii=False),\n                    \n                }\n                df_data.append(row)\n\n            # 🔥 НОВОЕ: Логируем статистику фильтрации\n            if filtered_count > 0:\n                self.log(\n                    f\"✅ Filtered out {filtered_count} blocks with MULTI-DC warnings. Remaining: {len(df_data)} blocks\")\n\n            # 🔥 НОВОЕ: Если все блоки отфильтрованы, создаём информативную строку\n            if not df_data:\n                self.log(\"No valid blocks after filtering, returning informative DataFrame\")\n\n                # Формируем список отфильтрованных доменов для информации\n                filtered_domains = []\n                for block in filtered_blocks:\n                    filtered_domains.extend(block.get('matching_domains', []))\n                filtered_domains = list(set(filtered_domains))  # Убираем дубликаты\n\n                # Создаём информативную строку вместо ошибки\n                info_row = {\n                    'index': 0,\n                    'config_key': 'FILTERED',\n                    'config_file': 'N/A',\n                    'server_names': json.dumps([], ensure_ascii=False),\n                    'matching_domains': json.dumps(filtered_domains, ensure_ascii=False),\n                    'location_path': 'N/A',\n                    'operation': input_data.get('operation', 'SKIP_MULTI_DC'),\n                    'type': 'filtered',\n                    'hash': '',\n                    'directives': json.dumps([], ensure_ascii=False),\n                    'parameters': json.dumps([], ensure_ascii=False),\n                    'server_block_parameters': json.dumps([], ensure_ascii=False),\n                    'existing_locations': json.dumps([], ensure_ascii=False),\n                    'ip_addresses': json.dumps([], ensure_ascii=False),\n                    'upstreams': json.dumps([], ensure_ascii=False),\n                    'warnings': json.dumps([\n                        f\"All {filtered_count} blocks filtered due to MULTI-DC warnings\",\n                        f\"Affected domains: {', '.join(filtered_domains)}\"\n                    ], ensure_ascii=False),\n                    'kms_required': False,\n                    'create_mode': False,\n                    'delete_mode': False,\n                    'new_location_path': '',\n                    'full_config_json': json.dumps({\n                        \"status\": \"filtered\",\n                        \"reason\": \"MULTI-DC domains detected\",\n                        \"filtered_count\": filtered_count,\n                        \"filtered_domains\": filtered_domains,\n                        \"original_operation\": input_data.get('operation', ''),\n                        \"message\": \"These domains exist in multiple datacenters. Manual intervention required.\"\n                    }, ensure_ascii=False)\n                }\n\n                df = pd.DataFrame([info_row])\n                self.log(f\"Returning informative DataFrame for {filtered_count} filtered blocks\")\n                return DataFrame(df)\n\n            # Create DataFrame\n            df = pd.DataFrame(df_data)\n\n            self.log(f\"Successfully created DataFrame with {len(df)} rows (filtered {filtered_count} MULTI-DC blocks)\")\n\n            # Return as langflow DataFrame\n            return DataFrame(df)\n\n        except Exception as e:\n            error_msg = f\"Error building DataFrame: {str(e)}\"\n            self.log(error_msg)\n            # Return DataFrame with error information\n            return DataFrame(pd.DataFrame(columns=['error'], data=[{'error': error_msg}]))\n\n    def build_total_count(self) -> Data:\n        \"\"\"Return total count of config blocks\"\"\"\n        try:\n            input_data = self.process_input_data(self.selected_block)\n            config_blocks = self.extract_config_blocks(input_data)\n\n            count_data = {\n                \"total_blocks\": len(config_blocks),\n                \"has_data\": len(config_blocks) > 0,\n                \"operation\": input_data.get(\"operation\", \"\"),\n                \"target_domains\": input_data.get(\"target_domains\", []),\n                \"locations_count\": input_data.get(\"locations_count\", 0),\n                \"warnings\": input_data.get(\"warnings\", [])\n            }\n\n            return Data(data=count_data)\n\n        except Exception as e:\n            error_msg = f\"Error getting total count: {str(e)}\"\n            self.log(error_msg)\n            return Data(data={\"total_blocks\": 0, \"has_data\": False, \"error\": error_msg})\n\n    def build_metadata(self) -> Data:\n        \"\"\"Extract and return metadata from the original response\"\"\"\n        try:\n            input_data = self.process_input_data(self.selected_block)\n\n            # Extract metadata fields\n            metadata = {\n                \"total_configs_scanned\": input_data.get(\"total_configs_scanned\", 0),\n                \"total_blocks_found\": input_data.get(\"total_blocks_found\", 0),\n                \"target_locations\": input_data.get(\"target_locations\", []),\n                \"target_domains\": input_data.get(\"target_domains\", []),\n                \"operation\": input_data.get(\"operation\", \"\"),\n                \"locations_count\": input_data.get(\"locations_count\", 0),\n                \"warnings\": input_data.get(\"warnings\", [])\n            }\n\n            # Add error if present\n            if 'error' in input_data:\n                metadata['error'] = input_data['error']\n\n            return Data(data=metadata)\n\n        except Exception as e:\n            error_msg = f\"Error extracting metadata: {str(e)}\"\n            self.log(error_msg)\n            return Data(data={\"error\": error_msg})"
              },
              "selected_block": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Selected Block",
                "dynamic": false,
                "info": "Output from LocationSelectorFromUniversalSearch containing selected_blocks",
                "input_types": [
                  "Message",
                  "Data",
                  "dict"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "selected_block",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "config_items_df",
          "showNode": true,
          "type": "ConfigBlockSplitter"
        },
        "dragging": false,
        "id": "ConfigBlockSplitter-gNsct",
        "measured": {
          "height": 181,
          "width": 320
        },
        "position": {
          "x": 2420.3520461833923,
          "y": 828.5194283138335
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-9f2ws",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "logic",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "https://docs.langflow.org/components-logic#conditional-router-if-else-component",
            "edited": false,
            "field_order": [
              "input_text",
              "operator",
              "match_text",
              "case_sensitive",
              "true_case_message",
              "false_case_message",
              "max_iterations",
              "default_route"
            ],
            "frozen": false,
            "icon": "split",
            "key": "ConditionalRouter",
            "last_updated": "2025-11-28T06:12:00.551Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "group_outputs": true,
                "method": "true_response",
                "name": "true_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "group_outputs": true,
                "method": "false_response",
                "name": "false_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "case_sensitive": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Case Sensitive",
                "dynamic": false,
                "info": "If true, the comparison will be case sensitive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "case_sensitive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    documentation: str = \"https://docs.langflow.org/components-logic#conditional-router-if-else-component\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\n                \"equals\",\n                \"not equals\",\n                \"contains\",\n                \"starts with\",\n                \"ends with\",\n                \"regex\",\n                \"less than\",\n                \"less than or equal\",\n                \"greater than\",\n                \"greater than or equal\",\n            ],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=True,\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"true_case_message\",\n            display_name=\"Case True\",\n            info=\"The message to pass if the condition is True.\",\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"false_case_message\",\n            display_name=\"Case False\",\n            info=\"The message to pass if the condition is False.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\", group_outputs=True),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\", group_outputs=True),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n            try:\n                input_num = float(input_text)\n                match_num = float(match_text)\n                if operator == \"less than\":\n                    return input_num < match_num\n                if operator == \"less than or equal\":\n                    return input_num <= match_num\n                if operator == \"greater than\":\n                    return input_num > match_num\n                if operator == \"greater than or equal\":\n                    return input_num >= match_num\n            except ValueError:\n                return False  # Invalid number format for comparison\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        \"\"\"Handles cycle iteration counting and branch exclusion.\n\n        Uses two complementary mechanisms:\n        1. stop() - ACTIVE/INACTIVE state for cycle management (gets reset each iteration)\n        2. exclude_branch_conditionally() - Persistent exclusion for conditional routing\n\n        When max_iterations is reached, breaks the cycle by allowing the default_route to execute.\n        \"\"\"\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n\n            # Check if max iterations reached and we're trying to stop the default route\n            if current_iteration >= self.max_iterations and route_to_stop == self.default_route:\n                # Clear ALL conditional exclusions to allow default route to execute\n                if self._id in self.graph.conditional_exclusion_sources:\n                    previous_exclusions = self.graph.conditional_exclusion_sources[self._id]\n                    self.graph.conditionally_excluded_vertices -= previous_exclusions\n                    del self.graph.conditional_exclusion_sources[self._id]\n\n                # Switch which route to stop - stop the NON-default route to break the cycle\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n\n                # Call stop to break the cycle\n                self.stop(route_to_stop)\n                # Don't apply conditional exclusion when breaking cycle\n                return\n\n            # Normal case: Use BOTH mechanisms\n            # 1. stop() for cycle management (marks INACTIVE, updates run manager, gets reset)\n            self.stop(route_to_stop)\n\n            # 2. Conditional exclusion for persistent routing (doesn't get reset except by this router)\n            self.graph.exclude_branch_conditionally(self._id, output_name=route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        # Check if we should force output due to max_iterations on default route\n        current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n        force_output = current_iteration >= self.max_iterations and self.default_route == \"true_result\"\n\n        if result or force_output:\n            self.status = self.true_case_message\n            if not force_output:  # Only stop the other branch if not forcing due to max iterations\n                self.iterate_and_stop_once(\"false_result\")\n            return self.true_case_message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        if not result:\n            self.status = self.false_case_message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.false_case_message\n\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "external_options": {},
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "false_case_message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Case False",
                "dynamic": false,
                "info": "The message to pass if the condition is False.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "false_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\"error\""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "external_options": {},
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex",
                  "less than",
                  "less than or equal",
                  "greater than",
                  "greater than or equal"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "contains"
              },
              "true_case_message": {
                "_input_type": "MessageInput",
                "advanced": true,
                "display_name": "Case True",
                "dynamic": false,
                "info": "The message to pass if the condition is True.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "true_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-9f2ws",
        "measured": {
          "height": 509,
          "width": 320
        },
        "position": {
          "x": 1887.1184605609835,
          "y": 497.6740792465955
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-8qOmI",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "index",
                "operation",
                "config_key",
                "config_file",
                "location_path",
                "type",
                "directives",
                "parameters",
                "server_block_parameters",
                "ip_addresses",
                "kms_required",
                "create_mode",
                "delete_mode",
                "new_location_path",
                "existing_locations",
                "matching_domains",
                "server_names",
                "hash",
                "warnings"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "braces",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"braces\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "config_file": {
                "advanced": false,
                "display_name": "config_file",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "config_file",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "config_key": {
                "advanced": false,
                "display_name": "config_key",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "config_key",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "create_mode": {
                "advanced": false,
                "display_name": "create_mode",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "create_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "delete_mode": {
                "advanced": false,
                "display_name": "delete_mode",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "delete_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "directives": {
                "advanced": false,
                "display_name": "directives",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "directives",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "existing_locations": {
                "advanced": false,
                "display_name": "existing_locations",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "existing_locations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "hash": {
                "advanced": false,
                "display_name": "hash",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "hash",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "index": {
                "advanced": false,
                "display_name": "index",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "index",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "ip_addresses": {
                "advanced": false,
                "display_name": "ip_addresses",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "ip_addresses",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "kms_required": {
                "advanced": false,
                "display_name": "kms_required",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "kms_required",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "location_path": {
                "advanced": false,
                "display_name": "location_path",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "location_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "matching_domains": {
                "advanced": false,
                "display_name": "matching_domains",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "matching_domains",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "new_location_path": {
                "advanced": false,
                "display_name": "new_location_path",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "new_location_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "operation": {
                "advanced": false,
                "display_name": "operation",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "operation",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "parameters": {
                "advanced": false,
                "display_name": "parameters",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "parameters",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "server_block_parameters": {
                "advanced": false,
                "display_name": "server_block_parameters",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "server_block_parameters",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "server_names": {
                "advanced": false,
                "display_name": "server_names",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "server_names",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "## NGINX YAML Configuration Agent v5.0 (Loop-Compatible Processor)\n\nYou are an nginx YAML configuration expert that modifies EXISTING YAML configuration files based on validated user requests.\n\n**CRITICAL**: You work with EXISTING configurations only. You do NOT create new config files.\n**CRITICAL**: You must preserve original spacing, ordering, and formatting of all existing directives.\n**CRITICAL**: Do NOT add any extra parameters unless explicitly provided in the input.\n\n---\n\n## INPUT DATA FORMAT (FROM PARSER)\n\nYou will receive data in the following format with these variables:\n\n- Index: {index}\n- Operation: {operation}\n- Config Key: {config_key}\n- Config File: {config_file}\n- Location Path: {location_path}\n- Type: {type}\n- Directives: {directives}\n- Parameters: {parameters}\n- Server block parameters: {server_block_parameters}\n- IP Addresses: {ip_addresses}\n- KMS Required: {kms_required}\n- Create Mode: {create_mode}\n- Delete Mode: {delete_mode}\n- New Location Path: {new_location_path}\n- Existing Locations: {existing_locations}\n- Matching Domains: {matching_domains}\n- Server Names: {server_names}\n- Hash: {hash}\n- Warnings: {warnings}\n\n\n**Field Descriptions:**\n- **Index**: Sequential number for loop processing\n- **Operation**: CREATE_LOCATION, ADD_PARAMETERS, MODIFY_PARAMETERS, DELETE_PARAMETERS, DELETE_LOCATION, MODIFY_LOCATION_PATH, MAKE_PROTECTED, MAKE_PUBLIC\n- **Config Key**: Configuration identifier (e.g., \"dchelper.mos.ru_9443\")\n- **Config File**: Full path to config file\n- **Location Path**: Target location (e.g., \"/api_V2/\")\n- **Type**: \"location\" or \"server\"\n- **Directives**: Current directives array (empty [] for new locations)\n- **Parameters**: Parameters to add/modify (empty [] if none)\n- **IP Addresses**: Array of IPs for upstream generation\n- **KMS Required**: True/False - whether to add KMS protection\n- **Create Mode**: True if creating new entity\n- **Delete Mode**: True if deleting entity\n- **New Location Path**: New path for MODIFY_LOCATION_PATH operation\n- **Existing Locations**: List of locations already present\n- **Matching Domains**: Array of matching domain names\n- **Server Names**: Array of server_name values\n- **Hash**: MD5 hash of current state (None for new)\n- **Warnings**: Array of warning messages from previous stages\n\n---\n\n## OPERATION PROCESSING\n\n### 1. CREATE_LOCATION\n\n**When**: Create Mode = True, Operation = CREATE_LOCATION\n\n**Steps**:\n1. Generate upstream name from Config Key and Location Path:\n   - Extract domain from Config Key (part before underscore and port)\n   - Convert domain: replace dots with underscores\n   - Convert location: remove leading slash, replace slashes with underscores\n   - Remove trailing slash and underscore\n   - Format: domain_converted + \"_\" + location_converted\n   - Example: \"dchelper.mos.ru_9443\" + \"/api_V2/\" → \"dchelper_mos_ru_api_v2\"\n\n2. Build location block:\n   - First line: \"location \" + location_path + \" {{\"\n   - Second line (indented 4 spaces): \"proxy_pass http://\" + upstream_name + \"/;\"\n   - Additional parameters (if provided) - each indented 4 spaces with semicolon\n   - Last line: \"}}\"\n\n3. Add parameters (if provided):\n   - Each parameter from Parameters array gets indented with 4 spaces\n   - Append \";\" if missing\n   - Place after proxy_pass directive\n\n4. Add KMS parameters (if KMS Required = True AND Parameters is empty):\n   - Default KMS: \"allow 10.0.0.0/8;\" and \"deny all;\"\n   - Place after proxy_pass\n   - Do NOT add if Parameters already provided\n\n**Output Format**:\n```json\n{{\n  \"status\": \"success\",\n  \"operation_type\": \"CREATE_LOCATION\",\n  \"config_key\": \"value_from_input\",\n  \"location_path\": \"value_from_input\",\n  \"updated_directives\": [\n    \"location /path/ {{ proxy_pass http://upstream_name/; }}\"\n  ],\n  \"hash\": \"md5_hash_value\",\n  \"changes_made\": [\n    \"Created new location /path/ with proxy_pass directive.\"\n  ],\n  \"explanation\": \"Created new location with details...\",\n  \"warnings\": [],\n  \"ready_to_save\": true\n}}\n```\n\n### 2. ADD_PARAMETERS\n\n**When**: Operation = ADD_PARAMETERS, Create Mode = False\n\n**Logic**: Add parameter ONLY if directive name does not exist\n\n**Steps**:\n1. Parse Directives array to extract existing directive names (first word)\n2. For each parameter in Parameters:\n   - Extract directive name (first word before space)\n   - Check if name exists in Directives\n   - If NOT exists: add with \";\" appended\n   - If exists: skip (add to warnings)\n\n### 3. MODIFY_PARAMETERS\n\n**When**: Operation = MODIFY_PARAMETERS\n\n**Logic**: Replace if value differs, add if missing, skip if identical\n\n**Steps**:\n1. For each parameter in Parameters:\n   - Extract directive name (first word)\n   - Find matching directive in Directives by name\n   - If found with different value: replace\n   - If found with same value: skip\n   - If not found: add\n\n### 4. DELETE_PARAMETERS\n\n**When**: Operation = DELETE_PARAMETERS\n\n**Logic**: Remove by exact string match\n\n**Steps**:\n1. For each parameter in Parameters:\n   - Find exact match in Directives (full string comparison)\n   - Remove if found\n   - Warn if not found\n\n### 5. DELETE_LOCATION\n\n**When**: Delete Mode = True, Operation = DELETE_LOCATION\n\n**Output**:\n```json\n{{\n  \"status\": \"success\",\n  \"operation_type\": \"DELETE_LOCATION\",\n  \"config_key\": \"value_from_input\",\n  \"location_path\": \"value_from_input\",\n  \"updated_directives\": [],\n  \"hash\": \"\",\n  \"changes_made\": [\"Deleted location completely.\"],\n  \"explanation\": \"Removed entire location block with all its directives.\",\n  \"warnings\": [],\n  \"ready_to_save\": true\n}}\n```\n\n### 6. MODIFY_LOCATION_PATH\n\n**When**: Operation = MODIFY_LOCATION_PATH, New Location Path is not empty\n\n**Steps**:\n1. Change location path from Location Path to New Location Path\n2. Preserve all existing Directives\n3. Update proxy_pass if it contains location reference\n\n### 7. MAKE_PROTECTED\n\n**When**: Operation = MAKE_PROTECTED\n\n**Logic**: Add KMS parameters using MODIFY_PARAMETERS logic\n\n**Default KMS** (if Parameters is empty):\n- \"allow 10.0.0.0/8;\"\n- \"deny all;\"\n\n### 8. MAKE_PUBLIC\n\n**When**: Operation = MAKE_PUBLIC\n\n**Logic**: Remove all KMS-related directives\n\n**KMS Directive Names to remove**: allow, deny, auth_request, satisfy, limit_except\n\n---\n\n## PARAMETER HANDLING RULES\n\n1. **Semicolon Management**:\n   - Input Parameters may or may not have trailing semicolon\n   - Always append \";\" before adding to Directives if missing\n   - Example: \"proxy_buffer_size 32k\" → \"proxy_buffer_size 32k;\"\n\n2. **Directive Name Matching**:\n   - Name equals first word before whitespace\n   - Case-sensitive comparison\n   - \"proxy_buffer_size 16k\" and \"proxy_buffer_size 32k\" have same name\n\n3. **No Extra Additions**:\n   - Do NOT add proxy_set_header directives unless in Parameters\n   - Do NOT add any \"standard\" configurations\n   - Only add what is explicitly provided\n\n4. **KMS Logic**:\n   - Add default KMS only if: KMS Required = True AND Parameters is empty array\n   - If Parameters provided, use those instead of defaults\n\n---\n\n## OUTPUT FORMAT\n\n**Success Response**:\n```json\n{{\n  \"status\": \"success\",\n  \"operation_type\": \"OPERATION_NAME\",\n  \"config_key\": \"config_key_value\",\n  \"location_path\": \"location_path_value\",\n  \"updated_directives\": [\"array\", \"of\", \"directives\"],\n  \"hash\": \"md5_hash_string\",\n  \"changes_made\": [\"list\", \"of\", \"changes\"],\n  \"explanation\": \"Detailed explanation of what was done\",\n  \"warnings\": [\"any\", \"warnings\"],\n  \"ready_to_save\": true\n}}\n```\n\n**Error Response**:\n```json\n{{\n  \"status\": \"error\",\n  \"operation_type\": \"OPERATION_NAME\",\n  \"error_type\": \"PREREQUISITE_ERROR\",\n  \"error_message\": \"Error details\",\n  \"config_key\": \"config_key_value\",\n  \"location_path\": \"location_path_value\",\n  \"explanation\": \"Cannot proceed due to specific reason\",\n  \"warnings\": [\"warning\", \"messages\"],\n  \"ready_to_save\": false\n}}\n```\n\n---\n\n## VALIDATION CHECKLIST\n\nBefore returning response, verify:\n\n- All Parameters have trailing semicolon\n- CREATE_LOCATION: First element starts with \"location\"\n- CREATE_LOCATION: Last element is closing brace\n- CREATE_LOCATION: All directives indented with 4 spaces\n- No extra directives added beyond input\n- Hash updated if changes made\n- changes_made array not empty if modifications made\n- ready_to_save equals false if no actual changes\n- Warnings from input preserved in output\n\n---\n\n## HASH CALCULATION\n\nCalculate MD5 hash of joined updated_directives string.\nEmpty directives results in hash: d41d8cd98f00b204e9800998ecf8427e\n\n---\n\n## EXAMPLES\n\n### Example 1: CREATE_LOCATION (Empty Parameters)\n\n**Input Variables**:\n- Index: 5\n- Operation: CREATE_LOCATION\n- Config Key: dchelper.mos.ru_9443\n- Location Path: /api_V2/\n- Directives: []\n- Parameters: []\n- KMS Required: False\n- Create Mode: True\n\n**Expected Output**:\n```json\n{{\n  \"status\": \"success\",\n  \"operation_type\": \"CREATE_LOCATION\",\n  \"config_key\": \"dchelper.mos.ru_9443\",\n  \"location_path\": \"/api_V2/\",\n  \"updated_directives\": [\n    \"location /api_V2/ {{ proxy_pass http://dchelper_mos_ru_api_v2/; }}\"\n  ],\n  \"hash\": \"d41d8cd98f00b204e9800998ecf8427e\",\n  \"changes_made\": [\n    \"Created new location /api_V2/ with proxy_pass directive.\"\n  ],\n  \"explanation\": \"Created new location /api_V2/ with proxy_pass directive. No additional parameters were provided, so only the proxy_pass directive was added. The upstream name was generated as 'dchelper_mos_ru_api_v2' based on the domain and location path.\",\n  \"warnings\": [],\n  \"ready_to_save\": true\n}}\n```\n\n### Example 2: CREATE_LOCATION (With Parameters)\n\n**Input Variables**:\n- Operation: CREATE_LOCATION\n- Config Key: api.mos.ru_9443\n- Location Path: /v1/\n- Parameters: [\"proxy_buffer_size 32k\", \"proxy_buffers 4 32k\"]\n- KMS Required: False\n- Create Mode: True\n\n**Expected Output**:\n```json\n{{\n  \"status\": \"success\",\n  \"operation_type\": \"CREATE_LOCATION\",\n  \"config_key\": \"api.mos.ru_9443\",\n  \"location_path\": \"/v1/\",\n  \"updated_directives\": [\n    \"location /v1/ {{ proxy_pass http://api_mos_ru_v1/; proxy_buffer_size 32k; proxy_buffers 4 32k; }}\"\n  ],\n  \"hash\": \"generated_hash\",\n  \"changes_made\": [\n    \"Created new location /v1/ with proxy_pass and 2 additional parameters.\"\n  ],\n  \"explanation\": \"Created new location /v1/ with proxy_pass directive and added 2 custom parameters: proxy_buffer_size, proxy_buffers.\",\n  \"warnings\": [],\n  \"ready_to_save\": true\n}}\n```\n\n---\n\n## NOW PROCESS THE INPUT\n\nUsing the variables provided above, process the operation and return valid JSON response following all rules."
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "type": {
                "advanced": false,
                "display_name": "type",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "type",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "warnings": {
                "advanced": false,
                "display_name": "warnings",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "warnings",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-8qOmI",
        "measured": {
          "height": 1835,
          "width": 320
        },
        "position": {
          "x": 4433.624778690419,
          "y": 166.84352953768484
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "OpenAIModel-aD2Th",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "category": "openai",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates text using OpenAI LLMs.",
            "display_name": "OpenAI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout"
            ],
            "frozen": false,
            "icon": "OpenAI",
            "key": "OpenAIModel",
            "last_updated": "2025-11-03T16:58:41.808Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.000001,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "TOKEN"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import (\n    OPENAI_CHAT_MODEL_NAMES,\n    OPENAI_REASONING_MODEL_NAMES,\n)\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\nfrom langflow.logging import logger\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES,\n            value=OPENAI_CHAT_MODEL_NAMES[0],\n            combobox=True,\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            show=True,\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        IntInput(\n            name=\"max_retries\",\n            display_name=\"Max Retries\",\n            info=\"The maximum number of retries to make when generating.\",\n            advanced=True,\n            value=5,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"The timeout for requests to OpenAI completion API.\",\n            advanced=True,\n            value=700,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        logger.debug(f\"Executing request with model: {self.model_name}\")\n        parameters = {\n            \"api_key\": SecretStr(self.api_key).get_secret_value() if self.api_key else None,\n            \"model_name\": self.model_name,\n            \"max_tokens\": self.max_tokens or None,\n            \"model_kwargs\": self.model_kwargs or {},\n            \"base_url\": self.openai_api_base or \"https://api.openai.com/v1\",\n            \"max_retries\": self.max_retries,\n            \"timeout\": self.timeout,\n        }\n\n        # TODO: Revisit if/once parameters are supported for reasoning models\n        unsupported_params_for_reasoning_models = [\"temperature\", \"seed\"]\n\n        if self.model_name not in OPENAI_REASONING_MODEL_NAMES:\n            parameters[\"temperature\"] = self.temperature if self.temperature is not None else 0.1\n            parameters[\"seed\"] = self.seed\n        else:\n            params_str = \", \".join(unsupported_params_for_reasoning_models)\n            logger.debug(f\"{self.model_name} is a reasoning model, {params_str} are not configurable. Ignoring.\")\n\n        output = ChatOpenAI(**parameters)\n        if self.json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_REASONING_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = False\n            build_config[\"seed\"][\"show\"] = False\n            # Hide system_message for o1 models - currently unsupported\n            if field_value.startswith(\"o1\") and \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = False\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_CHAT_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = True\n            build_config[\"seed\"][\"show\"] = True\n            if \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = True\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4.1-mini",
                  "gpt-4.1-nano",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "gpt-5",
                  "gpt-5-mini",
                  "gpt-5-nano",
                  "gpt-5-chat-latest",
                  "o1",
                  "o3-mini",
                  "o3",
                  "o3-pro",
                  "o4-mini",
                  "o4-mini-high"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "local_huggingface/Qwen3-32B"
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://localhost:8000/v1"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are the NGINX YAML Configuration Processor.  \nFollow ENGINE_RULES from the input exactly.  \nNever invent directives. Only modify existing YAML according to parameters.  \nAlways return valid JSON.\n\n"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.05
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 2400
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "OpenAIModel"
        },
        "dragging": false,
        "id": "OpenAIModel-aD2Th",
        "measured": {
          "height": 661,
          "width": 320
        },
        "position": {
          "x": 4942.367775027644,
          "y": 743.3476983754149
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TypeConverterComponent-uxomw",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert between different types (Message, Data, DataFrame)",
            "display_name": "Type Convert",
            "documentation": "https://docs.langflow.org/components-processing#type-convert",
            "edited": false,
            "field_order": [
              "input_data",
              "output_type"
            ],
            "frozen": false,
            "icon": "repeat",
            "key": "TypeConverterComponent",
            "last_updated": "2025-12-09T19:29:41.312Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data Output",
                "group_outputs": false,
                "hidden": null,
                "method": "convert_to_data",
                "name": "data_output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, Output, TabInput\nfrom langflow.schema import Data, DataFrame, Message\n\n\ndef convert_to_message(v) -> Message:\n    \"\"\"Convert input to Message type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        Message: Converted Message object\n    \"\"\"\n    return v if isinstance(v, Message) else v.to_message()\n\n\ndef convert_to_data(v: DataFrame | Data | Message | dict) -> Data:\n    \"\"\"Convert input to Data type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        Data: Converted Data object\n    \"\"\"\n    if isinstance(v, dict):\n        return Data(v)\n    if isinstance(v, Message):\n        return v.to_data()\n    return v if isinstance(v, Data) else v.to_data()\n\n\ndef convert_to_dataframe(v: DataFrame | Data | Message | dict) -> DataFrame:\n    \"\"\"Convert input to DataFrame type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        DataFrame: Converted DataFrame object\n    \"\"\"\n    if isinstance(v, dict):\n        return DataFrame([v])\n    return v if isinstance(v, DataFrame) else v.to_dataframe()\n\n\nclass TypeConverterComponent(Component):\n    display_name = \"Type Convert\"\n    description = \"Convert between different types (Message, Data, DataFrame)\"\n    documentation: str = \"https://docs.langflow.org/components-processing#type-convert\"\n    icon = \"repeat\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Input\",\n            input_types=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Accept Message, Data or DataFrame as input\",\n            required=True,\n        ),\n        TabInput(\n            name=\"output_type\",\n            display_name=\"Output Type\",\n            options=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Select the desired output data type\",\n            real_time_refresh=True,\n            value=\"Message\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message Output\",\n            name=\"message_output\",\n            method=\"convert_to_message\",\n        )\n    ]\n\n    def update_outputs(self, frontend_node: dict, field_name: str, field_value: Any) -> dict:\n        \"\"\"Dynamically show only the relevant output based on the selected output type.\"\"\"\n        if field_name == \"output_type\":\n            # Start with empty outputs\n            frontend_node[\"outputs\"] = []\n\n            # Add only the selected output type\n            if field_value == \"Message\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Message Output\",\n                        name=\"message_output\",\n                        method=\"convert_to_message\",\n                    ).to_dict()\n                )\n            elif field_value == \"Data\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Data Output\",\n                        name=\"data_output\",\n                        method=\"convert_to_data\",\n                    ).to_dict()\n                )\n            elif field_value == \"DataFrame\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"DataFrame Output\",\n                        name=\"dataframe_output\",\n                        method=\"convert_to_dataframe\",\n                    ).to_dict()\n                )\n\n        return frontend_node\n\n    def convert_to_message(self) -> Message:\n        \"\"\"Convert input to Message type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_message(input_value)\n        self.status = result\n        return result\n\n    def convert_to_data(self) -> Data:\n        \"\"\"Convert input to Data type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_data(input_value)\n        self.status = result\n        return result\n\n    def convert_to_dataframe(self) -> DataFrame:\n        \"\"\"Convert input to DataFrame type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_dataframe(input_value)\n        self.status = result\n        return result\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "Accept Message, Data or DataFrame as input",
                "input_types": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "output_type": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Output Type",
                "dynamic": false,
                "info": "Select the desired output data type",
                "name": "output_type",
                "options": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Data"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TypeConverterComponent"
        },
        "dragging": false,
        "id": "TypeConverterComponent-uxomw",
        "measured": {
          "height": 261,
          "width": 320
        },
        "position": {
          "x": 5408.3976308494375,
          "y": 1950.1095068785849
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-jraUk",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "ParserComponent",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "- Index: {index}\n- Operation: {operation}\n- Config Key: {config_key}\n- Config File: {config_file}\n- Location Path: {location_path}\n- Type: {type}\n- Directives: {directives}\n- Parameters: {parameters}\n- Server block parameters: {server_block_parameters}\n- IP Addresses: {ip_addresses}\n- KMS Required: {kms_required}\n- Create Mode: {create_mode}\n- Delete Mode: {delete_mode}\n- New Location Path: {new_location_path}\n- Existing Locations: {existing_locations}\n- Matching Domains: {matching_domains}\n- Server Names: {server_names}\n- Hash: {hash}\n- Warnings: {warnings}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-jraUk",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": 3503.624123453639,
          "y": 790.6737580394465
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LoopComponent-Azlpj",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "category": "logic",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.",
            "display_name": "Loop",
            "documentation": "https://docs.langflow.org/components-logic#loop",
            "edited": false,
            "field_order": [
              "data"
            ],
            "frozen": false,
            "icon": "infinity",
            "key": "LoopComponent",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": true,
                "cache": true,
                "display_name": "Item",
                "group_outputs": true,
                "method": "item_output",
                "name": "item",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Done",
                "group_outputs": true,
                "method": "done_output",
                "name": "done",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template.field.base import Output\n\n\nclass LoopComponent(Component):\n    display_name = \"Loop\"\n    description = (\n        \"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.\"\n    )\n    documentation: str = \"https://docs.langflow.org/components-logic#loop\"\n    icon = \"infinity\"\n\n    inputs = [\n        HandleInput(\n            name=\"data\",\n            display_name=\"Inputs\",\n            info=\"The initial list of Data objects or DataFrame to iterate over.\",\n            input_types=[\"DataFrame\"],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Item\", name=\"item\", method=\"item_output\", allows_loop=True, group_outputs=True),\n        Output(display_name=\"Done\", name=\"done\", method=\"done_output\", group_outputs=True),\n    ]\n\n    def initialize_data(self) -> None:\n        \"\"\"Initialize the data list, context index, and aggregated list.\"\"\"\n        if self.ctx.get(f\"{self._id}_initialized\", False):\n            return\n\n        # Ensure data is a list of Data objects\n        data_list = self._validate_data(self.data)\n\n        # Store the initial data and context variables\n        self.update_ctx(\n            {\n                f\"{self._id}_data\": data_list,\n                f\"{self._id}_index\": 0,\n                f\"{self._id}_aggregated\": [],\n                f\"{self._id}_initialized\": True,\n            }\n        )\n\n    def _validate_data(self, data):\n        \"\"\"Validate and return a list of Data objects.\"\"\"\n        if isinstance(data, DataFrame):\n            return data.to_data_list()\n        if isinstance(data, Data):\n            return [data]\n        if isinstance(data, list) and all(isinstance(item, Data) for item in data):\n            return data\n        msg = \"The 'data' input must be a DataFrame, a list of Data objects, or a single Data object.\"\n        raise TypeError(msg)\n\n    def evaluate_stop_loop(self) -> bool:\n        \"\"\"Evaluate whether to stop item or done output.\"\"\"\n        current_index = self.ctx.get(f\"{self._id}_index\", 0)\n        data_length = len(self.ctx.get(f\"{self._id}_data\", []))\n        return current_index > data_length\n\n    def item_output(self) -> Data:\n        \"\"\"Output the next item in the list or stop if done.\"\"\"\n        self.initialize_data()\n        current_item = Data(text=\"\")\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n        else:\n            # Get data list and current index\n            data_list, current_index = self.loop_variables()\n            if current_index < len(data_list):\n                # Output current item and increment index\n                try:\n                    current_item = data_list[current_index]\n                except IndexError:\n                    current_item = Data(text=\"\")\n            self.aggregated_output()\n            self.update_ctx({f\"{self._id}_index\": current_index + 1})\n\n        # Now we need to update the dependencies for the next run\n        self.update_dependency()\n        return current_item\n\n    def update_dependency(self):\n        item_dependency_id = self.get_incoming_edge_by_target_param(\"item\")\n        if item_dependency_id not in self.graph.run_manager.run_predecessors[self._id]:\n            self.graph.run_manager.run_predecessors[self._id].append(item_dependency_id)\n\n    def done_output(self) -> DataFrame:\n        \"\"\"Trigger the done output when iteration is complete.\"\"\"\n        self.initialize_data()\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n            self.start(\"done\")\n\n            aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n\n            return DataFrame(aggregated)\n        self.stop(\"done\")\n        return DataFrame([])\n\n    def loop_variables(self):\n        \"\"\"Retrieve loop variables from context.\"\"\"\n        return (\n            self.ctx.get(f\"{self._id}_data\", []),\n            self.ctx.get(f\"{self._id}_index\", 0),\n        )\n\n    def aggregated_output(self) -> list[Data]:\n        \"\"\"Return the aggregated list once all items are processed.\"\"\"\n        self.initialize_data()\n\n        # Get data list and aggregated list\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n        loop_input = self.item\n        if loop_input is not None and not isinstance(loop_input, str) and len(aggregated) <= len(data_list):\n            aggregated.append(loop_input)\n            self.update_ctx({f\"{self._id}_aggregated\": aggregated})\n        return aggregated\n"
              },
              "data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "The initial list of Data objects or DataFrame to iterate over.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "LoopComponent"
        },
        "dragging": false,
        "id": "LoopComponent-Azlpj",
        "measured": {
          "height": 241,
          "width": 320
        },
        "position": {
          "x": 2906.7271155390376,
          "y": 848.2313917087927
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-ssgPc",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "ParserComponent",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-ssgPc",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": 3515.459669070119,
          "y": 1264.4685340514768
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-Tgr2k",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "id": "ChatOutput-Tgr2k",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 3997.4489598272075,
          "y": 1703.4500626798447
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "OpenAIModel-gG1G9",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "category": "openai",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates text using OpenAI LLMs.",
            "display_name": "OpenAI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout"
            ],
            "frozen": false,
            "icon": "OpenAI",
            "key": "OpenAIModel",
            "last_updated": "2025-11-03T16:58:41.808Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.000001,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "TOKEN"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import (\n    OPENAI_CHAT_MODEL_NAMES,\n    OPENAI_REASONING_MODEL_NAMES,\n)\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\nfrom langflow.logging import logger\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES,\n            value=OPENAI_CHAT_MODEL_NAMES[0],\n            combobox=True,\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            show=True,\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        IntInput(\n            name=\"max_retries\",\n            display_name=\"Max Retries\",\n            info=\"The maximum number of retries to make when generating.\",\n            advanced=True,\n            value=5,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"The timeout for requests to OpenAI completion API.\",\n            advanced=True,\n            value=700,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        logger.debug(f\"Executing request with model: {self.model_name}\")\n        parameters = {\n            \"api_key\": SecretStr(self.api_key).get_secret_value() if self.api_key else None,\n            \"model_name\": self.model_name,\n            \"max_tokens\": self.max_tokens or None,\n            \"model_kwargs\": self.model_kwargs or {},\n            \"base_url\": self.openai_api_base or \"https://api.openai.com/v1\",\n            \"max_retries\": self.max_retries,\n            \"timeout\": self.timeout,\n        }\n\n        # TODO: Revisit if/once parameters are supported for reasoning models\n        unsupported_params_for_reasoning_models = [\"temperature\", \"seed\"]\n\n        if self.model_name not in OPENAI_REASONING_MODEL_NAMES:\n            parameters[\"temperature\"] = self.temperature if self.temperature is not None else 0.1\n            parameters[\"seed\"] = self.seed\n        else:\n            params_str = \", \".join(unsupported_params_for_reasoning_models)\n            logger.debug(f\"{self.model_name} is a reasoning model, {params_str} are not configurable. Ignoring.\")\n\n        output = ChatOpenAI(**parameters)\n        if self.json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_REASONING_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = False\n            build_config[\"seed\"][\"show\"] = False\n            # Hide system_message for o1 models - currently unsupported\n            if field_value.startswith(\"o1\") and \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = False\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_CHAT_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = True\n            build_config[\"seed\"][\"show\"] = True\n            if \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = True\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4.1-mini",
                  "gpt-4.1-nano",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "gpt-5",
                  "gpt-5-mini",
                  "gpt-5-nano",
                  "gpt-5-chat-latest",
                  "o1",
                  "o3-mini",
                  "o3",
                  "o3-pro",
                  "o4-mini",
                  "o4-mini-high"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "local_huggingface/Qwen3-32B"
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://localhost:8000/v1"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are an expert in nginx configuration.  IMPORTANT RULES: 1. Always follow the instructions STEP BY STEP. 2. Respond STRICTLY in the specified format. 3. Do not invent data — if something is missing, write “NOT SPECIFIED.” 4. Be specific in your questions to the client. 5. For small domains such as test.ru or school.mos.ru, use the exact data from the request.  CONTEXT: You work in a chain of agents, each agent doing their part of the job. Your task is to perform ONLY your part, clearly and in a structured manner."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.05
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 600
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "OpenAIModel"
        },
        "id": "OpenAIModel-gG1G9",
        "measured": {
          "height": 661,
          "width": 320
        },
        "position": {
          "x": -4898.684352948809,
          "y": 750.2649622876356
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-vV3QQ",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "question"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "braces",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"braces\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "question": {
                "advanced": false,
                "display_name": "question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "# NGINX Configuration Expert System v3.2 (CORRECTED - Only Plural Fields)\n\nYou are an expert NGINX configuration parser. Your task is to extract ALL information from CLIENT REQUEST with 100% accuracy and output structured JSON.\n\n---\n\n## ⚠️ CRITICAL RULES (READ FIRST)\n\n1. **Extract ONLY from CLIENT REQUEST** — Do NOT invent information\n2. **One operation per domain = One JSON object** — Use arrays only for multiple domains\n3. **Always validate before output** — Check completeness, format, required fields\n4. **When in doubt = data_complete: false** — Never guess critical values\n\n---\n\n## 🏢 DATACENTER (ЦОД) SELECTION\n\n### Available Datacenters\n\n| ID | Name (RU) | Name (EN) | Description |\n|----|-----------|-----------|-------------|\n| `korovinskiy` | ЦОД Коровинский | DC Korovinskiy | Main datacenter |\n| `kurchatovskiy` | ЦОД Курчатовский | DC Kurchatovskiy | Main datacenter |\n| `nagornaya` | ЦОД Нагорная | DC Nagornaya | Main datacenter |\n| `dr` | DR | Disaster Recovery | Creates configs in BOTH Korovinskiy AND Kurchatovskiy |\n| `moshub_rus` | moshub rus | MosHub RUS | MosHub Russian segment |\n| `ext_kurchatovskiy` | EXT Курчатовский | EXT Kurchatovskiy | External farm Kurchatovskiy |\n| `ext_korovinskiy` | EXT Коровинский | EXT Korovinskiy | External farm Korovinskiy |\n| `ext_nagornaya` | EXT Нагорная | EXT Nagornaya | External farm Nagornaya |\n| `mesh` | МЭШ | MESH | Moscow Electronic School |\n| `top10_kurchatovskiy` | top 10 Курчатовский | Top 10 Kurchatovskiy | Top 10 Kurchatovskiy |\n| `top10_korovinskiy` | top 10 Коровинский | Top 10 Korovinskiy | Top 10 Korovinskiy |\n\n### DC Synonyms Recognition\n\n| User Input (variations) | Normalized DC ID |\n|------------------------|------------------|\n| коровинский, коровинском, коровинск, korovinskiy, korov | `korovinskiy` |\n| курчатовский, курчатовском, курчатов, kurchatovskiy, kurch | `kurchatovskiy` |\n| нагорная, нагорной, nagornaya, nagor | `nagornaya` |\n| dr, дисастер, disaster recovery | `dr` |\n| moshub, мосхаб, moshub rus | `moshub_rus` |\n| ext курчатовский, экст курчат, ext kurch | `ext_kurchatovskiy` |\n| ext коровинский, экст коров, ext korov | `ext_korovinskiy` |\n| ext нагорная, экст нагор, ext nagor | `ext_nagornaya` |\n| мэш, mesh, меш | `mesh` |\n| top 10 курчатовский, топ 10 курч, top10 kurch | `top10_kurchatovskiy` |\n| top 10 коровинский, топ 10 коров, top10 korov | `top10_korovinskiy` |\n\n### DC Field Rules\n\n| Scenario | `selected_dc` Value |\n|----------|---------------------|\n| DC explicitly specified | Array with one or more DC IDs |\n| DR specified | `[\"korovinskiy\", \"kurchatovskiy\"]` |\n| DC NOT specified | `[]` (empty array) |\n\n---\n\n## 🎯 RULE PRIORITY (Highest to Lowest)\n\n| Priority | Category | Description |\n|----------|----------|-------------|\n| 1 | Security | Validate IPs, domains, deny dangerous patterns |\n| 2 | Required Fields | upstreams for CREATE_LOCATION, domains for all ops |\n| 3 | Output Format | Single object vs array rules |\n| 4 | Parameters | Correct placement (location vs server_block) |\n| 5 | Completeness | Mark missing data appropriately |\n\n---\n\n## 📖 KEY CONCEPTS\n\n### Server Block vs Location\n\n| Term | Scope | Example |\n|------|-------|---------|\n| `server_block` | Entire domain/server (outside location blocks) | `gzip on;` at server level |\n| `location` | Specific URL path | `gzip on;` inside `location /api {{}}` |\n\n### When to Use What\n\n| User Says | Use Field |\n|-----------|-----------|\n| \"для всего конфига\", \"на уровне домена\", \"for entire config\" | `server_block_parameters` |\n| \"для /api\", \"в локейшене\", \"for location\" | `location_parameters` |\n| \"добавить параметр\" (без указания места) | Ask for clarification or use context |\n\n---\n\n## 🔧 OPERATIONS REFERENCE\n\n| Operation | Trigger Words (RU/EN) | Required Fields |\n|-----------|----------------------|-----------------|\n| `CREATE_LOCATION` | создать, create location | domains, locations, **upstreams** |\n| `DELETE_LOCATION` | удалить локейшн, delete location | domains, locations |\n| `ADD_PARAMETERS` | добавить, внести параметры, add | domains, locations OR server_block |\n| `MODIFY_PARAMETERS` | изменить, поправить, modify, change | domains, locations, parameters |\n| `DELETE_PARAMETERS` | удалить параметры, remove params | domains, locations, parameters |\n| `MODIFY_UPSTREAM` | изменить апстрим, change upstream | domains, locations, upstreams |\n| `MODIFY_LOCATION_PATH` | изменить путь, rename location | domains, from_location, to_location |\n| `MAKE_PROTECTED` | добавить в КМС, protect, enable KMS | domains, locations |\n| `MAKE_PUBLIC` | убрать из КМС, make public | domains, locations |\n| `UNCLEAR` | Cannot determine | — |\n\n---\n\n## 📝 SYNONYMS DICTIONARY\n\n| User Input (variations) | Normalized Term |\n|------------------------|-----------------|\n| апстрим, upstream, бэкенд, backend, сервер | `upstream` |\n| локейшн, локация, location, путь, path, endpoint | `location` |\n| домен, сайт, хост, domain, host, site | `domain` |\n| убрать, удалить, remove, delete, drop | `DELETE_*` |\n| добавить, создать, add, create, new | `ADD_*/CREATE_*` |\n| изменить, поменять, поправить, modify, change, update | `MODIFY_*` |\n| КМС, KMS, защита, protection, auth | KMS-related |\n| Да, Yes, включить, enable, on | `on` |\n| Нет, No, выключить, disable, off | `off` |\n| цод, цоде, дата-центр, datacenter, dc, конфиг в | datacenter reference |\n\n---\n\n## 🌐 LOCATION TYPES\n\n| Syntax | Type | Field Value |\n|--------|------|-------------|\n| `location = /exact` | Exact match | `location_match: \"exact\"` |\n| `location /prefix` | Prefix match | `location_match: \"prefix\"` |\n| `location ~ \\.php$` | Regex (case-sensitive) | `location_match: \"regex\"` |\n| `location ~* \\.jpg$` | Regex (case-insensitive) | `location_match: \"regex_insensitive\"` |\n| `location ^~ /images` | Prefix priority | `location_match: \"prefix_priority\"` |\n\n---\n\n## 🔗 UPSTREAM PARSING RULES\n\n### Format Recognition\n\n| Input Pattern | Interpretation |\n|---------------|----------------|\n| `main 1.1.1.1:80,2.2.2.2:80 backup 3.3.3.3:80` | main: [1.1.1.1:80, 2.2.2.2:80], backup: [3.3.3.3:80] |\n| `1.1.1.1:80,2.2.2.2:80 3.3.3.3:80` | Ambiguous — assume first=main, second=backup |\n| `main backup 1.1.1.1:80,2.2.2.2:80` | Both main AND backup use same IPs |\n| `1.1.1.1:80 weight=5` | IP with additional params |\n\n### Upstream Output Structure\n\n\n\"upstreams\": [\n  {{\n    \"upstream_type\": \"main\",\n    \"ip_addresses\": [\"10.0.0.1:80\", \"10.0.0.2:80\"],\n    \"params\": [\"weight=5\", \"max_fails=3\"]\n  }},\n  {{\n    \"upstream_type\": \"backup\", \n    \"ip_addresses\": [\"10.0.0.3:80\"]\n  }}\n]\n\n\n### Direct Proxy Pass (No Upstream)\n\nIf request specifies direct IP in proxy_pass (not upstream name):\n- Use `MODIFY_PARAMETERS` with `proxy_pass:http://IP:port/`\n- Do NOT use `MODIFY_UPSTREAM`\n\n---\n\n## ✅ VALIDATION RULES\n\n### IP Address Validation\n\n\nIPv4:        ^\\d{{1,3}}\\.\\d{{1,3}}\\.\\d{{1,3}}\\.\\d{{1,3}}$\nIPv4+Port:   ^\\d{{1,3}}\\.\\d{{1,3}}\\.\\d{{1,3}}\\.\\d{{1,3}}:\\d{{1,5}}$\nCIDR:        ^\\d{{1,3}}\\.\\d{{1,3}}\\.\\d{{1,3}}\\.\\d{{1,3}}/\\d{{1,2}}$\nPort Range:  1-65535\n\n\n### Domain Validation\n\n\nValid:    example.mos.ru, sub.domain.com\nInvalid:  http://example.com (no protocol)\nInvalid:  example (must have TLD)\n\n\n### Location Validation\n\n\nValid:    /, /api, /api/v1, /api_v2/\nInvalid:  api (must start with /)\nInvalid:  /api v2 (no spaces)\n\n\n---\n\n## 📊 OUTPUT SCHEMA\n\n\n{{\n  \"operation\": \"OPERATION_TYPE\",\n  \n  \"selected_dc\": [\"korovinskiy\"] or [],\n  \n  \"domains\": [\"domain1.ru\", \"domain2.ru\"],\n  \n  \"locations\": [\"/path1\", \"/path2\"],\n  \"location_match\": \"prefix|exact|regex|regex_insensitive|prefix_priority\",\n  \n  \"from_location\": \"/old-path or null\",\n  \"to_location\": \"/new-path or null\",\n  \n  \"preserve_directives\": true,\n  \n  \"parameters\": [],\n  \n  \"location_parameters\": [\n    {{\n      \"location\": \"/path\",\n      \"parameters\": [\"param1:value1\", \"param2:value2\"],\n      \"kms_required\": false\n    }}\n  ],\n  \n  \"server_block_parameters\": [\"gzip:on\", \"client_max_body_size:100m\"],\n  \n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main|backup\",\n      \"ip_addresses\": [\"ip:port\"],\n      \"params\": [\"weight=5\"]\n    }}\n  ],\n  \n  \"ssl\": {{\n    \"enabled\": false,\n    \"certificate\": null,\n    \"certificate_key\": null\n  }},\n  \n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \n  \"data_complete\": true,\n  \"missing\": null,\n  \n  \"confidence\": 0.95,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n## OUTPUT FORMAT RULES\n\n| Scenario | Output Format |\n|----------|---------------|\n| One domain, one operation | Single JSON object with `domains: [\"single.domain\"]` |\n| Multiple domains OR different DCs per domain | Array of JSON objects |\n| Same domain, multiple locations, same operation | Single object with `locations: [\"/path1\", \"/path2\"]` |\n\n**KEY RULE:** \n- **Always use arrays** for `domains` and `locations`\n- Even with 1 domain: `domains: [\"example.com\"]`\n- Even with 1 location: `locations: [\"/\"]`\n- Each unique (domain + DC) combination = separate JSON object\n\n---\n\n## 🚫 ANTI-PATTERNS (What NOT to Do)\n\n### ❌ Multiple Objects for Same Domain + Operation\n\n**REQUEST:** \"enable kms for /api, /api_v2 on domain test.ru\"\n\n❌ WRONG:\n\n[\n  {{\"operation\": \"MAKE_PROTECTED\", \"domains\": [\"test.ru\"], \"locations\": [\"/api\"]}},\n  {{\"operation\": \"MAKE_PROTECTED\", \"domains\": [\"test.ru\"], \"locations\": [\"/api_v2\"]}}\n]\n\n\n✅ CORRECT:\n\n{{\n  \"operation\": \"MAKE_PROTECTED\",\n  \"domains\": [\"test.ru\"],\n  \"locations\": [\"/api\", \"/api_v2\"],\n  \"location_parameters\": [\n    {{\"location\": \"/api\", \"parameters\": [], \"kms_required\": true}},\n    {{\"location\": \"/api_v2\", \"parameters\": [], \"kms_required\": true}}\n  ]\n}}\n\n\n### ❌ Wrong Parameter Placement\n\n**REQUEST:** \"добавьте gzip on для всего конфига домена test.ru\"\n\n❌ WRONG:\n\n{{\n  \"location_parameters\": [{{\"location\": \"/\", \"parameters\": [\"gzip:on\"]}}]\n}}\n\n\n✅ CORRECT:\n\n{{\n  \"locations\": [],\n  \"server_block_parameters\": [\"gzip:on\"]\n}}\n\n\n### ❌ Missing Upstreams for CREATE_LOCATION\n\n**REQUEST:** \"создайте локейшн /api для домена test.ru\"\n\n❌ WRONG:\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"upstreams\": [],\n  \"data_complete\": true\n}}\n\n\n✅ CORRECT:\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"upstreams\": [],\n  \"data_complete\": false,\n  \"missing\": \"upstreams required for CREATE_LOCATION\"\n}}\n\n\n### ❌ Duplicates in Arrays\n\n❌ WRONG: `\"kms_locations\": [\"/api\", \"/api_v2\", \"/api\", \"/api_v2\"]`\n✅ CORRECT: `\"kms_locations\": [\"/api\", \"/api_v2\"]`\n\n### ❌ Using Empty Strings Instead of Empty Arrays\n\n❌ WRONG: `\"domains\": \"\", \"locations\": \"\"`\n✅ CORRECT: `\"domains\": [], \"locations\": []`\n\n### ❌ Losing Additional Parameters\n\n**REQUEST:** \"main 1.1.1.1:80 weight=5 max_fails=3\"\n\n❌ WRONG:\n\n{{\n  \"upstreams\": [{{\"ip_addresses\": [\"1.1.1.1:80\"]}}]\n}}\n\n\n✅ CORRECT:\n\n{{\n  \"upstreams\": [{{\n    \"ip_addresses\": [\"1.1.1.1:80\"],\n    \"params\": [\"weight=5\", \"max_fails=3\"]\n  }}]\n}}\n\n\n### ❌ Merging Different Domains with Different DCs\n\n**REQUEST:** \"dchelper.mos.ru коровинский aip.mos.ru нагорная gzip on\"\n\n❌ WRONG (merged into one object):\n\n{{\n  \"selected_dc\": [\"korovinskiy\", \"nagornaya\"],\n  \"domains\": [\"dchelper.mos.ru\"],\n  …\n}}\n\n\n✅ CORRECT (separate objects per domain+DC pair):\n\n\n{{\"domains\": [\"dchelper.mos.ru\"], \"selected_dc\": [\"korovinskiy\"], …}},\n{{\"domains\": [\"aip.mos.ru\"], \"selected_dc\": [\"nagornaya\"], …}}\n\n\n\n---\n\n## 📋 EXAMPLES\n\n### Example 1: Upstream Change with DC Specified (Korovinskiy)\n\n**Request:** \"Измените апстримы для локейшена / у домена aip.mos.ru в цод коровинском main 10.10.10.10,10.10.10.11,10.10.10.12\"\n\n\n{{\n  \"operation\": \"MODIFY_UPSTREAM\",\n  \"selected_dc\": [\"korovinskiy\"],\n  \"domains\": [\"aip.mos.ru\"],\n  \"locations\": [\"/\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"10.10.10.10\", \"10.10.10.11\", \"10.10.10.12\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 2: Upstream Change with DC Specified (Kurchatovskiy)\n\n**Request:** \"Измените апстримы для локейшена / у домена aip.mos.ru конфиг в курчатовском main 10.10.10.10,10.10.10.11,10.10.10.12\"\n\n\n{{\n  \"operation\": \"MODIFY_UPSTREAM\",\n  \"selected_dc\": [\"kurchatovskiy\"],\n  \"domains\": [\"aip.mos.ru\"],\n  \"locations\": [\"/\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"10.10.10.10\", \"10.10.10.11\", \"10.10.10.12\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 3: DR (Disaster Recovery) - Both DCs\n\n**Request:** \"создать локейшн /api для домена test.ru в DR main 1.1.1.1:80\"\n\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"selected_dc\": [\"korovinskiy\", \"kurchatovskiy\"],\n  \"domains\": [\"test.ru\"],\n  \"locations\": [\"/api\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/api\", \"parameters\": [], \"kms_required\": false}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"1.1.1.1:80\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 4: No DC Specified (Empty Array)\n\n**Request:** \"Change upstreams for location / domain school.mos.ru main 10.10.10.10:80,10.10.10.11:80 backup 10.10.10.12:80\"\n\n\n{{\n  \"operation\": \"MODIFY_UPSTREAM\",\n  \"selected_dc\": [],\n  \"domains\": [\"school.mos.ru\"],\n  \"locations\": [\"/\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"10.10.10.10:80\", \"10.10.10.11:80\"],\n      \"params\": []\n    }},\n    {{\n      \"upstream_type\": \"backup\",\n      \"ip_addresses\": [\"10.10.10.12:80\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 5: External Farm (EXT Kurchatovskiy)\n\n**Request:** \"добавить локейшн /external для api.mos.ru в EXT Курчатовский main 192.168.1.1:8080\"\n\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"selected_dc\": [\"ext_kurchatovskiy\"],\n  \"domains\": [\"api.mos.ru\"],\n  \"locations\": [\"/external\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/external\", \"parameters\": [], \"kms_required\": false}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"192.168.1.1:8080\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 6: MESH Datacenter\n\n**Request:** \"enable kms for /api domain mesh.mos.ru в МЭШ\"\n\n\n{{\n  \"operation\": \"MAKE_PROTECTED\",\n  \"selected_dc\": [\"mesh\"],\n  \"domains\": [\"mesh.mos.ru\"],\n  \"locations\": [\"/api\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/api\", \"parameters\": [], \"kms_required\": true}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": true,\n  \"kms_locations\": [\"/api\"],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 7: Top 10 Datacenter\n\n**Request:** \"изменить апстримы для / домена top.mos.ru в top 10 Коровинский main 10.0.0.1:80\"\n\n\n{{\n  \"operation\": \"MODIFY_UPSTREAM\",\n  \"selected_dc\": [\"top10_korovinskiy\"],\n  \"domains\": [\"top.mos.ru\"],\n  \"locations\": [\"/\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"10.0.0.1:80\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 8: Multiple Locations with KMS (No DC)\n\n**Request:** \"enable kms for locations /api,/api_v2 domain c2222-tech-fair.mos.ru\"\n\n\n{{\n  \"operation\": \"MAKE_PROTECTED\",\n  \"selected_dc\": [],\n  \"domains\": [\"c2222-tech-fair.mos.ru\"],\n  \"locations\": [\"/api\", \"/api_v2\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/api\", \"parameters\": [], \"kms_required\": true}},\n    {{\"location\": \"/api_v2\", \"parameters\": [], \"kms_required\": true}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": true,\n  \"kms_locations\": [\"/api\", \"/api_v2\"],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 9: Create Locations with Shared Upstreams (No DC)\n\n**Request:** \"create locations /a /b domain test.ru main backup 1.1.1.1:80,2.2.2.2:80\"\n\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"selected_dc\": [],\n  \"domains\": [\"test.ru\"],\n  \"locations\": [\"/a\", \"/b\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/a\", \"parameters\": [], \"kms_required\": false}},\n    {{\"location\": \"/b\", \"parameters\": [], \"kms_required\": false}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"1.1.1.1:80\", \"2.2.2.2:80\"],\n      \"params\": []\n    }},\n    {{\n      \"upstream_type\": \"backup\",\n      \"ip_addresses\": [\"1.1.1.1:80\", \"2.2.2.2:80\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.95,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 10: Add Parameters with Allow/Deny (Nagornaya DC)\n\n**Request:** \"domain fmon-edu.mos.ru for location /test/ add parameters allow 10.15.166.0/25; allow 10.113.0.0/16; deny all; proxy_set_header Host $host; в цод Нагорная\"\n\n\n{{\n  \"operation\": \"ADD_PARAMETERS\",\n  \"selected_dc\": [\"nagornaya\"],\n  \"domains\": [\"fmon-edu.mos.ru\"],\n  \"locations\": [\"/test/\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\n      \"location\": \"/test/\",\n      \"parameters\": [\n        \"allow:10.15.166.0/25\",\n        \"allow:10.113.0.0/16\",\n        \"deny:all\",\n        \"proxy_set_header:Host $host\"\n      ],\n      \"kms_required\": false\n    }}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 11: Server Block Parameters (No DC)\n\n**Request:** \"для домена api.mos.ru добавить на уровне конфига: gzip on, client_max_body_size 50m\"\n\n\n{{\n  \"operation\": \"ADD_PARAMETERS\",\n  \"selected_dc\": [],\n  \"domains\": [\"api.mos.ru\"],\n  \"locations\": [],\n  \"location_match\": null,\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [\"gzip:on\", \"client_max_body_size:50m\"],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 12: CREATE_LOCATION Without Upstreams (Incomplete)\n\n**Request:** \"домен aip.mos.ru создайте локейшен /api_v6\"\n\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"selected_dc\": [],\n  \"domains\": [\"aip.mos.ru\"],\n  \"locations\": [\"/api_v6\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/api_v6\", \"parameters\": [], \"kms_required\": false}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": false,\n  \"missing\": \"upstreams required for CREATE_LOCATION\",\n  \"confidence\": 0.90,\n  \"warnings\": [\"No upstream servers specified for new location\"],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 13: MosHub RUS Datacenter\n\n**Request:** \"добавить /hub для домена hub.mos.ru в moshub rus main 10.20.30.40:80\"\n\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"selected_dc\": [\"moshub_rus\"],\n  \"domains\": [\"hub.mos.ru\"],\n  \"locations\": [\"/hub\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\"location\": \"/hub\", \"parameters\": [], \"kms_required\": false}}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [\n    {{\n      \"upstream_type\": \"main\",\n      \"ip_addresses\": [\"10.20.30.40:80\"],\n      \"params\": []\n    }}\n  ],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 14: Multiple Domains (Array Output)\n\n**Request:** \"domain1.ru добавить /api в коровинском, domain2.ru удалить /old в курчатовском\"\n\n\n\n  {{\n    \"operation\": \"CREATE_LOCATION\",\n    \"selected_dc\": [\"korovinskiy\"],\n    \"domains\": [\"domain1.ru\"],\n    \"locations\": [\"/api\"],\n    \"location_match\": \"prefix\",\n    \"from_location\": null,\n    \"to_location\": null,\n    \"preserve_directives\": true,\n    \"parameters\": [],\n    \"location_parameters\": [\n      {{\"location\": \"/api\", \"parameters\": [], \"kms_required\": false}}\n    ],\n    \"server_block_parameters\": [],\n    \"upstreams\": [],\n    \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n    \"kms_mentioned\": false,\n    \"kms_locations\": [],\n    \"public_locations\": [],\n    \"data_complete\": false,\n    \"missing\": \"upstreams required for CREATE_LOCATION\",\n    \"confidence\": 0.85,\n    \"warnings\": [],\n    \"ambiguities\": []\n  }},\n  {{\n    \"operation\": \"DELETE_LOCATION\",\n    \"selected_dc\": [\"kurchatovskiy\"],\n    \"domains\": [\"domain2.ru\"],\n    \"locations\": [\"/old\"],\n    \"location_match\": \"prefix\",\n    \"from_location\": null,\n    \"to_location\": null,\n    \"preserve_directives\": true,\n    \"parameters\": [],\n    \"location_parameters\": [],\n    \"server_block_parameters\": [],\n    \"upstreams\": [],\n    \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n    \"kms_mentioned\": false,\n    \"kms_locations\": [],\n    \"public_locations\": [],\n    \"data_complete\": true,\n    \"missing\": null,\n    \"confidence\": 0.95,\n    \"warnings\": [],\n    \"ambiguities\": []\n  }},\n  {{\n    \"operation\": \"DELETE_LOCATION\",\n    \"selected_dc\": [\"nagornaya\"],\n    \"domains\": [\"domain2.ru\"],\n    \"locations\": [\"= /old\"],\n    \"location_match\": \"prefix\",\n    \"from_location\": null,\n    \"to_location\": null,\n    \"preserve_directives\": true,\n    \"parameters\": [],\n    \"location_parameters\": [],\n    \"server_block_parameters\": [],\n    \"upstreams\": [],\n    \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n    \"kms_mentioned\": false,\n    \"kms_locations\": [],\n    \"public_locations\": [],\n    \"data_complete\": true,\n    \"missing\": null,\n    \"confidence\": 0.95,\n    \"warnings\": [],\n    \"ambiguities\": []\n  }}\n\n---\n\n### Example 15: Modify Location Path (No DC)\n\n**Request:** \"переименовать локейшн /api в /api/ для домена test.ru\"\n\n\n{{\n  \"operation\": \"MODIFY_LOCATION_PATH\",\n  \"selected_dc\": [],\n  \"domains\": [\"test.ru\"],\n  \"locations\": [],\n  \"location_match\": \"prefix\",\n  \"from_location\": \"/api\",\n  \"to_location\": \"/api/\",\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 16: Direct Proxy Pass Modification (No DC)\n\n**Request:** \"изменить proxy_pass на http://10.206.100.17:8000/ для локейшн / домена api.mos.ru\"\n\n\n{{\n  \"operation\": \"MODIFY_PARAMETERS\",\n  \"selected_dc\": [],\n  \"domains\": [\"api.mos.ru\"],\n  \"locations\": [\"/\"],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [\n    {{\n      \"location\": \"/\",\n      \"parameters\": [\"proxy_pass:http://10.206.100.17:8000/\"],\n      \"kms_required\": false\n    }}\n  ],\n  \"server_block_parameters\": [],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": false,\n  \"kms_locations\": [],\n  \"public_locations\": [],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.99,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n### Example 17: Make Public No Location Specified (Default Parameters)\n\n**Request:** \"домен dchelper.mos.ru убрать из КМС\"\n\n\n{{\n  \"operation\": \"MAKE_PUBLIC\",\n  \"selected_dc\": [],\n  \"domains\": [\"dchelper.mos.ru\"],\n  \"locations\": [],\n  \"location_match\": \"prefix\",\n  \"from_location\": null,\n  \"to_location\": null,\n  \"preserve_directives\": true,\n  \"parameters\": [],\n  \"location_parameters\": [],\n  \"server_block_parameters\": [\"allow:10.0.0.0/8\", \"deny:all\"],\n  \"upstreams\": [],\n  \"ssl\": {{\"enabled\": false, \"certificate\": null, \"certificate_key\": null}},\n  \"kms_mentioned\": true,\n  \"kms_locations\": [],\n  \"public_locations\": [\"/\"],\n  \"data_complete\": true,\n  \"missing\": null,\n  \"confidence\": 0.98,\n  \"warnings\": [],\n  \"ambiguities\": []\n}}\n\n\n---\n\n## 🧠 MANDATORY REASONING PROCESS\n\nBefore outputting JSON, you MUST think through these steps:\n\n\n<thinking>\n1. DATACENTER IDENTIFICATION\n   - Is DC explicitly mentioned? (цод, datacenter, конфиг в)\n   - DC keywords found: [list keywords]\n   - Determined DC: [DC_ID or empty if not specified]\n\n2. OPERATION IDENTIFICATION\n   - What action is requested? (create/delete/modify/protect/etc.)\n   - Key trigger words found: [list words]\n   - Determined operation: [OPERATION_TYPE]\n\n3. DOMAIN EXTRACTION  \n   - Single domain or multiple?\n   - Domain value: [extracted domain(s)]\n   - Validation: [valid/invalid]\n   - Output: domains: [array]\n\n4. LOCATION EXTRACTION\n   - Single location or multiple?\n   - Location value(s): [extracted location(s)]\n   - Location type: [prefix/exact/regex]\n   - Output: locations: [array]\n   \n5. PARAMETER CLASSIFICATION\n   - Location-level params: [list]\n   - Server-block params: [list]\n   - Reasoning: [why this classification]\n\n6. UPSTREAM PARSING (if applicable)\n   - Main servers: [IPs]\n   - Backup servers: [IPs]\n   - Additional params: [weight, etc.]\n\n7. COMPLETENESS CHECK\n   - Required fields present: [yes/no]\n   - Missing information: [list what's missing]\n   - data_complete value: [true/false]\n\n8. CONFIDENCE ASSESSMENT\n   - Ambiguities found: [list]\n   - Warnings: [list]\n   - Confidence score: [0.0-1.0]\n\n9. COHERENCE CHECK (НОВАЯ ПРОВЕРКА)\n   - Запрос говорит \"Удалить X, Добавить Y\" для тех же путей?\n   - Если ДА → это MODIFY_PARAMETERS, а не DELETE+CREATE\n   - Если пути те же → единая операция модификации\n   - Если пути разные → возможны раздельные операции\n</thinking>\n\n\nThen output ONLY the JSON.\n\n---\n\n## 🔒 ERROR HANDLING\n\n| Error Type | Action |\n|------------|--------|\n| Invalid IP format | `data_complete: false`, `missing: \"invalid IP format: X.X.X.X\"` |\n| Missing required field | `data_complete: false`, `missing: \"[field] required for [operation]\"` |\n| Conflicting instructions | Add to `ambiguities`, reduce confidence |\n| Unknown nginx directive | Include as-is, add to `warnings` |\n| Typo detected | Add to `warnings`: \"possible typo: 'gzp' → 'gzip'\" |\n| Unknown DC | Add to `warnings`: \"unknown datacenter specified\", use closest match or empty |\n\n---\n\n## 🔄 CONTEXT AWARENESS\n\nIf request references previous context:\n\n| User Says | Action |\n|-----------|--------|\n| \"тот же домен\", \"same domain\" | Use domain from context if available, else `data_complete: false` |\n| \"эти же апстримы\", \"same upstreams\" | Use upstreams from context if available |\n| \"как раньше\", \"as before\" | Request clarification, set `data_complete: false` |\n| \"тот же цод\", \"same dc\" | Use DC from context if available |\n\n---\n\n## ✅ DATA_COMPLETE RULES\n\nSet `data_complete: true` when:\n- ✅ Operation identified\n- ✅ domains array present (even if empty for server_block operations)\n- ✅ locations array present (can be empty for server_block operations)\n- ✅ For CREATE_LOCATION: upstreams array has at least main upstream with IPs\n- ✅ For MAKE_PROTECTED/MAKE_PUBLIC: KMS params auto-generated (empty is OK)\n- ✅ For ADD_PARAMETERS: at least one parameter specified\n- ✅ selected_dc can be empty (not required)\n\nSet `data_complete: false` when:\n- ❌ Missing domains array or empty when required\n- ❌ Missing locations array for location-specific operations\n- ❌ CREATE_LOCATION without upstreams\n- ❌ ADD_PARAMETERS without any parameters\n- ❌ Ambiguous request that can't be resolved\n\n---\n\n## 🚀 FINAL CHECKLIST BEFORE OUTPUT\n\n1. ☐ Is datacenter correctly identified (or empty if not specified)?\n2. ☐ Is operation correctly identified?\n3. ☐ Are domains and locations in array format (even if single value)?\n4. ☐ Are parameters in correct section (location vs server_block)?\n5. ☐ Are upstreams properly parsed with main/backup?\n6. ☐ Is data_complete correctly set?\n7. ☐ Are there no duplicate entries in arrays?\n8. ☐ Is the output valid JSON?\n9. ☐ Is confidence score reasonable?\n\n---\n\n## NOW ANALYZE\n\n**CLIENT REQUEST:**\n{question}\n\n---\n\n**Output ONLY valid JSON (single object or array of objects):**\n"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "id": "Prompt Template-vV3QQ",
        "measured": {
          "height": 359,
          "width": 320
        },
        "position": {
          "x": -5350.777270842005,
          "y": 998.9905369893274
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONCleaner-NP0e0",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.",
            "display_name": "JSON Cleaner",
            "documentation": "",
            "edited": false,
            "field_order": [
              "json_str",
              "remove_control_chars",
              "normalize_unicode",
              "validate_json"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "JSONCleaner",
            "legacy": true,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Cleaned JSON String",
                "group_outputs": false,
                "method": "clean_json",
                "name": "output",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "replacement": [
              "processing.ParserComponent"
            ],
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport unicodedata\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass JSONCleaner(Component):\n    icon = \"braces\"\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n    legacy = True\n    replacement = [\"processing.ParserComponent\"]\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with `pip install json_repair`.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        start = json_str.find(\"{\")\n        end = json_str.rfind(\"}\")\n        if start == -1 or end == -1:\n            msg = \"Invalid JSON string: Missing '{' or '}'\"\n            raise ValueError(msg)\n        try:\n            json_str = json_str[start : end + 1]\n\n            if remove_control_chars:\n                json_str = self._remove_control_characters(json_str)\n            if normalize_unicode:\n                json_str = self._normalize_unicode(json_str)\n            if validate_json:\n                json_str = self._validate_json(json_str)\n\n            cleaned_json_str = repair_json(json_str)\n            result = str(cleaned_json_str)\n\n            self.status = result\n            return Message(text=result)\n        except Exception as e:\n            msg = f\"Error cleaning JSON string: {e}\"\n            raise ValueError(msg) from e\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return s.translate(self.translation_table)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def _validate_json(self, s: str) -> str:\n        \"\"\"Validate the JSON string.\"\"\"\n        try:\n            json.loads(s)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON string: {e}\"\n            raise ValueError(msg) from e\n        return s\n\n    def __init__(self, *args, **kwargs):\n        # Create a translation table that maps control characters to None\n        super().__init__(*args, **kwargs)\n        self.translation_table = str.maketrans(\"\", \"\", \"\".join(chr(i) for i in range(32)) + chr(127))\n"
              },
              "json_str": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "The JSON string to be cleaned.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "json_str",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "normalize_unicode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Normalize Unicode",
                "dynamic": false,
                "info": "Normalize Unicode characters in the JSON string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "normalize_unicode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "remove_control_chars": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Remove Control Characters",
                "dynamic": false,
                "info": "Remove control characters from the JSON string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "remove_control_chars",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "validate_json": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Validate JSON",
                "dynamic": false,
                "info": "Validate the JSON string to ensure it is well-formed.",
                "list": false,
                "list_add_label": "Add More",
                "name": "validate_json",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONCleaner"
        },
        "id": "JSONCleaner-NP0e0",
        "measured": {
          "height": 440,
          "width": 320
        },
        "position": {
          "x": -4455.366745314168,
          "y": 919.187537173947
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "OpenAIModel-AsW27",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "category": "openai",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates text using OpenAI LLMs.",
            "display_name": "OpenAI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout"
            ],
            "frozen": false,
            "icon": "OpenAI",
            "key": "OpenAIModel",
            "last_updated": "2025-11-03T16:58:41.808Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.000001,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "TOKEN"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import (\n    OPENAI_CHAT_MODEL_NAMES,\n    OPENAI_REASONING_MODEL_NAMES,\n)\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\nfrom langflow.logging import logger\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES,\n            value=OPENAI_CHAT_MODEL_NAMES[0],\n            combobox=True,\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            show=True,\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        IntInput(\n            name=\"max_retries\",\n            display_name=\"Max Retries\",\n            info=\"The maximum number of retries to make when generating.\",\n            advanced=True,\n            value=5,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"The timeout for requests to OpenAI completion API.\",\n            advanced=True,\n            value=700,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        logger.debug(f\"Executing request with model: {self.model_name}\")\n        parameters = {\n            \"api_key\": SecretStr(self.api_key).get_secret_value() if self.api_key else None,\n            \"model_name\": self.model_name,\n            \"max_tokens\": self.max_tokens or None,\n            \"model_kwargs\": self.model_kwargs or {},\n            \"base_url\": self.openai_api_base or \"https://api.openai.com/v1\",\n            \"max_retries\": self.max_retries,\n            \"timeout\": self.timeout,\n        }\n\n        # TODO: Revisit if/once parameters are supported for reasoning models\n        unsupported_params_for_reasoning_models = [\"temperature\", \"seed\"]\n\n        if self.model_name not in OPENAI_REASONING_MODEL_NAMES:\n            parameters[\"temperature\"] = self.temperature if self.temperature is not None else 0.1\n            parameters[\"seed\"] = self.seed\n        else:\n            params_str = \", \".join(unsupported_params_for_reasoning_models)\n            logger.debug(f\"{self.model_name} is a reasoning model, {params_str} are not configurable. Ignoring.\")\n\n        output = ChatOpenAI(**parameters)\n        if self.json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_REASONING_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = False\n            build_config[\"seed\"][\"show\"] = False\n            # Hide system_message for o1 models - currently unsupported\n            if field_value.startswith(\"o1\") and \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = False\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_CHAT_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = True\n            build_config[\"seed\"][\"show\"] = True\n            if \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = True\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4.1-mini",
                  "gpt-4.1-nano",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "gpt-5",
                  "gpt-5-mini",
                  "gpt-5-nano",
                  "gpt-5-chat-latest",
                  "o1",
                  "o3-mini",
                  "o3",
                  "o3-pro",
                  "o4-mini",
                  "o4-mini-high"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "local_huggingface/Qwen3-32B"
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://localhost:8000/v1"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a validation expert for nginx configuration requests. Your job is to verify data completeness, detect risks, and generate specific clarification questions."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.05
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 600
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "OpenAIModel"
        },
        "id": "OpenAIModel-AsW27",
        "measured": {
          "height": 661,
          "width": 320
        },
        "position": {
          "x": -3236.1635012489924,
          "y": 813.7525583109743
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-e5PJD",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "agent1_json",
                "original_question"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "braces",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "agent1_json": {
                "advanced": false,
                "display_name": "agent1_json",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "agent1_json",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"braces\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "original_question": {
                "advanced": false,
                "display_name": "original_question",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "original_question",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "# NGINX Configuration Validation Expert v4.1 (BUG FIXES)\n\nYou are a validation expert for NGINX configuration requests. Your task is to validate Agent 1's output against the original request and NGINX syntax rules.\n\n---\n\n## ⚠️ CRITICAL RULES (READ FIRST)\n\n1. **ACTUALLY READ the input JSON** — Do not assume fields are missing without checking!\n2. **location OR locations** — Either one is valid, not both required\n3. **Warnings ≠ Missing fields** — Warnings don't block COMPLETE status\n4. **Skip proxy_pass validation** — Always mark as valid\n5. **Check upstreams array properly** — Look inside the array structure\n\n---\n\n## 🚨 COMMON VALIDATION BUGS TO AVOID\n\n### Bug 1: Ignoring `locations` array\n\n❌ WRONG: location is null → missing_fields: [\"location\"]\n✅ RIGHT: location is null BUT locations = [\"/a\", \"/b\"] → data is PRESENT\n\n\n### Bug 2: Not parsing `upstreams` structure  \n\n❌ WRONG: upstreams exists → assume empty\n✅ RIGHT: Check if upstreams[*].ip_addresses has values\n\n\n### Bug 3: Treating warnings as blockers\n\n❌ WRONG: Same IPs in main/backup → validation_status: \"INCOMPLETE\"\n✅ RIGHT: Same IPs in main/backup → Add warning, but status: \"COMPLETE\"\n\n\n### Bug 4: Wrong fields for MODIFY_LOCATION_PATH\n\n❌ WRONG: Check location/locations for MODIFY_LOCATION_PATH\n✅ RIGHT: Check from_location and to_location ONLY\n\n\n### Bug 5: Ignoring `domains` array when `domain` is null\n\nInput: {{\"domain\": null, \"domains\": [\"aip.mos.ru\", \"dchelper.mos.ru\"]}}\n\n❌ WRONG: domain is null → missing_fields: [\"domain: required\"]\n✅ RIGHT: domain is null BUT domains = [\"aip.mos.ru\", \"dchelper.mos.ru\"] → PRESENT\n\n\n### Bug 6: Ignoring `server_block_parameters` for location check\n\nInput: {{\n  \"operation\": \"ADD_PARAMETERS\",\n  \"location\": null,\n  \"locations\": [],\n  \"server_block_parameters\": [\"gzip:on\"]\n}}\n\n❌ WRONG: location is null and locations empty → missing_fields: [\"location required\"]\n✅ RIGHT: server_block_parameters has values → server-block level operation, location NOT required\n\n❌ WRONG: parameters is empty → missing_fields: [\"parameters\"]\n✅ RIGHT: parameters is empty BUT location_parameters has values → data is PRESENT\n---\n\n## 🎯 VALIDATION PRIORITY\n\n| Priority | Check | Action on Failure |\n|----------|-------|-------------------|\n| 1 | Security risks | Set HIGH_RISK |\n| 2 | Required fields (ACTUALLY CHECK!) | Set INCOMPLETE |\n| 3 | Syntax errors | Set INCOMPLETE |\n| 4 | Consistency/Best practices | Add warnings ONLY |\n\n---\n\n## 📊 DATA PRESENCE CHECK ALGORITHM\n\n### Step 1: Parse Input Correctly\n\n```python\ndef parse_agent1_output(json_input):\n    \"\"\"\n    CRITICAL: Actually extract values, don't assume!\n    \"\"\"\n    return {{\n        \"operation\": json_input.get(\"operation\"),\n        \"domain\": json_input.get(\"domain\"),  # Can be string or null\n        \"domains\": json_input.get(\"domains\", []),  # Can be array or empty\n        \"location\": json_input.get(\"location\"),  # Can be string or null\n        \"locations\": json_input.get(\"locations\", []),  # Can be array or empty\n        \"from_location\": json_input.get(\"from_location\"),\n        \"to_location\": json_input.get(\"to_location\"),\n        \"upstreams\": json_input.get(\"upstreams\", []),  # PARSE THIS PROPERLY!\n        \"parameters\": json_input.get(\"parameters\", []),\n        \"location_parameters\": json_input.get(\"location_parameters\", []),\n        \"server_block_parameters\": json_input.get(\"server_block_parameters\", []),\n        \"kms_mentioned\": json_input.get(\"kms_mentioned\", False),\n        \"kms_locations\": json_input.get(\"kms_locations\", []),\n    }}\n```\n\n### Step 2: Check Field Presence\n\n```python\ndef is_field_present(value):\n    \"\"\"\n    Returns True if field has actual data\n    \"\"\"\n    if value is None:\n        return False\n    if isinstance(value, str) and value.strip() == \"\":\n        return False\n    if isinstance(value, list) and len(value) == 0:\n        return False\n    return True\n\ndef has_domain(data):\n    \"\"\"\n    CRITICAL: Check BOTH domain AND domains!\n    Returns True if EITHER has value.\n    \"\"\"\n    # Check single domain field\n    domain = data.get(\"domain\")\n    if domain is not None and domain.strip() != \"\":\n        return True\n    \n    # Check domains array\n    domains = data.get(\"domains\", [])\n    if domains and len(domains) > 0:\n        return True\n    \n    return False\n\n# Examples:\n# {{\"domain\": \"example.ru\", \"domains\": []}} → True (domain is set)\n# {{\"domain\": null, \"domains\": [\"a.ru\", \"b.ru\"]}} → True (domains has items)\n# {{\"domain\": null, \"domains\": []}} → False (neither has value)\n# {{\"domain\": \"\", \"domains\": []}} → False (empty string = not present)\n\ndef has_location(data):\n    # CRITICAL: Check BOTH fields!\n    return is_field_present(data[\"location\"]) or is_field_present(data[\"locations\"])\n\ndef has_upstreams(data):\n    # CRITICAL: Check inside the array!\n    upstreams = data.get(\"upstreams\", [])\n    if not upstreams:\n        return False\n    for upstream in upstreams:\n        ip_addresses = upstream.get(\"ip_addresses\", [])\n        if ip_addresses and len(ip_addresses) > 0:\n            return True\n    return False\n\n\ndef has_from_to_location(data):\n    return is_field_present(data[\"from_location\"]) and is_field_present(data[\"to_location\"])\n\n```\n### Step 3: Required Fields by Operation\n\n```python\ndef get_missing_fields(data):\n    operation = data[\"operation\"]\n    missing = []\n    \n    # ALL operations need domain\n    if not has_domain(data):\n        missing.append(\"domain: No domain or domains specified\")\n    \n    # Operation-specific checks\n    if operation == \"MODIFY_LOCATION_PATH\":\n        # Special case: needs from_location and to_location, NOT location/locations\n        if not is_field_present(data[\"from_location\"]):\n            missing.append(\"from_location: Source path required\")\n        if not is_field_present(data[\"to_location\"]):\n            missing.append(\"to_location: Target path required\")\n        # DO NOT check location or locations here!\n        \n    elif operation in [\"DELETE_LOCATION\", \"CREATE_LOCATION\", \"MODIFY_UPSTREAM\",\n                       \"ADD_PARAMETERS\", \"MODIFY_PARAMETERS\", \"DELETE_PARAMETERS\",\n                       \"MAKE_PROTECTED\", \"MAKE_PUBLIC\"]:\n        # These need location OR locations (not both)\n        if not has_location(data):\n            # Exception: server_block level operations may have null location\n            if operation == \"ADD_PARAMETERS\" and is_field_present(data[\"server_block_parameters\"]):\n                pass  # OK - server block level, no location needed\n            elif operation in [\"MAKE_PROTECTED\", \"MAKE_PUBLIC\"] and is_field_present(data[\"kms_locations\"]):\n                pass  # OK - using kms_locations instead\n            else:\n                missing.append(\"location: Neither location nor locations specified\")\n    \n    # CREATE_LOCATION needs upstreams\n    if operation == \"CREATE_LOCATION\":\n        if not has_upstreams(data):\n            missing.append(\"upstreams: IP addresses required for new location(s)\")\n    \n    # MODIFY_UPSTREAM needs upstreams\n    if operation == \"MODIFY_UPSTREAM\":\n        if not has_upstreams(data):\n            missing.append(\"upstreams: New upstream configuration required\")\n    \n    # ADD/MODIFY_PARAMETERS need actual parameters (unless KMS-only)\n    if operation in [\"ADD_PARAMETERS\", \"MODIFY_PARAMETERS\"]:\n        has_params = (is_field_present(data[\"parameters\"]) or \n                      is_field_present(data[\"location_parameters\"]) or\n                      is_field_present(data[\"server_block_parameters\"]))\n        is_kms_only = data[\"kms_mentioned\"] and is_field_present(data[\"kms_locations\"])\n        if not has_params and not is_kms_only:\n            missing.append(\"parameters: No parameters specified to add/modify\")\n    \n    return missing\n```\n\n---\n\n## 📋 FIELD PRESENCE TRUTH TABLE\n\n| Field | NOT Present (Empty) | IS Present (Valid) |\n|-------|--------------------|--------------------|\n| `domain` | `null`, `\"\"` | `\"example.ru\"` |\n| `domains` | `[]` | `[\"a.ru\", \"b.ru\"]` |\n| `location` | `null`, `\"\"` | `\"/\"`, `\"/api\"` |\n| `locations` | `[]` | `[\"/api\", \"/v2\"]` |\n| `from_location` | `null`, `\"\"` | `\"/old-path\"` |\n| `to_location` | `null`, `\"\"` | `\"/new-path\"` |\n| `upstreams` | `[]` | `[{{\"upstream_type\": \"main\", \"ip_addresses\": [\"1.1.1.1:80\"]}}]` |\n| `parameters` | `[]` | `[\"gzip:on\"]` |\n| `location_parameters` | `[]` | `[{{\"location\": \"/\", \"parameters\": [\"x:y\"]}}]` |\n| `server_block_parameters` | `[]` | `[\"gzip:on\"]` |\n\n### Combined Field Logic\n\n| Scenario | domain | domains | Result |\n|----------|--------|---------|--------|\n| Single domain | `\"example.ru\"` | `[]` | ✅ VALID |\n| Multiple domains | `null` | `[\"a.ru\", \"b.ru\"]` | ✅ VALID |\n| Both set | `\"example.ru\"` | `[\"a.ru\"]` | ✅ VALID (use both) |\n| Neither set | `null` | `[]` | ❌ MISSING |\n\n| Scenario | location | locations | server_block_params | Result |\n|----------|----------|-----------|---------------------|--------|\n| Single location | `\"/api\"` | `[]` | `[]` | ✅ VALID |\n| Multiple locations | `null` | `[\"/a\", \"/b\"]` | `[]` | ✅ VALID |\n| Server block level | `null` | `[]` | `[\"gzip:on\"]` | ✅ VALID |\n| Neither | `null` | `[]` | `[]` | ❌ MISSING |\n\n---\n\n## 🔄 OPERATION-SPECIFIC VALIDATION\n\n### CREATE_LOCATION\n\n**Required:** domain + (location OR locations) + upstreams with IPs\n\n\n# Validation\n```python\ndef validate_create_location(data):\n    errors = []\n    \n    # Check domain\n    if not has_domain(data):\n        errors.append(\"domain required\")\n    \n    # Check location OR locations (not both required)\n    if not has_location(data):\n        errors.append(\"location or locations required\")\n    \n    # Check upstreams - MUST have at least main with IPs\n    if not has_upstreams(data):\n        errors.append(\"upstreams with IP addresses required\")\n    \n    return errors\n\n```\n**Example - VALID:**\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"domain\": \"aip.mos.ru\",\n  \"location\": null,\n  \"locations\": [\"/api_V2/\", \"/api_V3/\"],\n  \"upstreams\": [\n    {{\"upstream_type\": \"main\", \"ip_addresses\": [\"10.10.10.10\"]}}\n  ]\n}}\n\n→ `validation_status: \"COMPLETE\"` ✅\n\n---\n\n### MODIFY_LOCATION_PATH\n\n**Required:** domain + from_location + to_location\n**NOT Required:** location, locations\n\n```python\ndef validate_modify_location_path(data):\n    errors = []\n    \n    if not has_domain(data):\n        errors.append(\"domain required\")\n    \n    # ONLY check from/to, NOT location/locations!\n    if not is_field_present(data[\"from_location\"]):\n        errors.append(\"from_location required\")\n    if not is_field_present(data[\"to_location\"]):\n        errors.append(\"to_location required\")\n    \n    return errors\n```\n\n**Example - VALID:**\n\n{{\n  \"operation\": \"MODIFY_LOCATION_PATH\",\n  \"domain\": \"mobile-newmos.mos.ru\",\n  \"location\": null,\n  \"locations\": [],\n  \"from_location\": \"/relay\",\n  \"to_location\": \"/relay/\"\n}}\n\n→ `validation_status: \"COMPLETE\"` ✅\n\n---\n\n### MODIFY_UPSTREAM\n\n**Required:** domains + locations + upstreams with IPs\n⚠️ ВАЖНО: Если `locations` — пустой массив ([]), то данные НЕПОЛНЫЕ. Такая конфигурация недопустима, даже если все остальные поля заполнены.\n\n```python\n\ndef check_MODIFY_UPSTREAM(data):\n    missing = []\n    \n    # 1. Проверь domain/domains\n    if not (data.get(\"domain\") or data.get(\"domains\")):\n        missing.append(\"domain: required\")\n    \n    # 2. Проверь location/locations ← ЭТО ОБЯЗАТЕЛЬНО!\n    if not (data.get(\"location\") or data.get(\"locations\")):\n        missing.append(\"location: Neither location nor locations specified\")\n    \n    # 3. Проверь upstreams\n    if not data.get(\"upstreams\"):\n        missing.append(\"upstreams: required\")\n    \n    return missing\n```\n{{\n  \"operation\": \"MODIFY_UPSTREAM\",\n  \"domain\": \"school.mos.ru\",\n  \"location\": \"/\",\n  \"upstreams\": [\n    {{\"upstream_type\": \"main\", \"ip_addresses\": [\"10.10.10.10:80\", \"10.10.10.11:80\"]}},\n    {{\"upstream_type\": \"backup\", \"ip_addresses\": [\"10.10.10.12\"]}}\n  ],\n  \"data_complete\": true\n}}\n\n**Output:**\n\n{{\n  \"validation_status\": \"COMPLETE\",\n  \"data_complete\": true,\n  \"missing_fields\": [],\n  \"syntax_errors\": [],\n  \"clarification_questions\": [],\n  \"parameter_validation\": {{\n    \"validated_parameters\": [\n      \"main upstream IPs: 10.10.10.10:80 (valid), 10.10.10.11:80 (valid)\",\n      \"backup upstream IPs: 10.10.10.12 (valid - assuming :80)\"\n    ],\n    \"invalid_parameters\": [],\n    \"warnings\": [\"No port for 10.10.10.12 - Defaults to 80\"]\n  }},\n  \"kms_rules\": {{\"locations_need_kms\": [], \"locations_public\": [], \"note\": null}},\n  \"risk_assessment\": {{\"risk_level\": \"low\", \"warnings\": []}},\n  \"cross_referenced\": {{\"note\": null}},\n  \"ready_for_next_agent\": true\n}}\n---\n\n### ADD_PARAMETERS / MODIFY_PARAMETERS\n\n**Required:** domain + (location OR locations OR server_block) + parameters\n**Exception:** KMS-only operations don't need parameters\n\n```python\ndef validate_add_modify_params(data):\n    errors = []\n    \n    if not has_domain(data):\n        errors.append(\"domain required\")\n    \n    # Location check (unless server_block level)\n    has_server_block = is_field_present(data[\"server_block_parameters\"])\n    if not has_location(data) and not has_server_block:\n        errors.append(\"location, locations, or server_block_parameters required\")\n    \n    # Parameters check (unless KMS-only)\n    has_any_params = (is_field_present(data[\"parameters\"]) or \n                      is_field_present(data[\"location_parameters\"]) or\n                      has_server_block)\n    is_kms_only = data[\"kms_mentioned\"] and is_field_present(data[\"kms_locations\"])\n    \n    if not has_any_params and not is_kms_only:\n        errors.append(\"parameters required\")\n    \n    return errors\n```\n\n---\n\n### DELETE_PARAMETERS\n\n**Required:** domain + (location OR locations) + parameter names\n**Note:** Parameter VALUES not required for deletion\n\n```python\ndef validate_delete_params(data):\n    errors = []\n    \n    if not has_domain(data):\n        errors.append(\"domain required\")\n    \n    if not has_location(data):\n        errors.append(\"location or locations required\")\n    \n    # Just need parameter names, values optional\n    if not is_field_present(data[\"parameters\"]):\n        errors.append(\"parameter names to delete required\")\n    \n    return errors\n\n```\n---\n\n### DELETE_LOCATION\n\n**Required:** domain + (location OR locations)\n\n```python\ndef validate_delete_location(data):\n    errors = []\n    \n    if not has_domain(data):\n        errors.append(\"domain required\")\n    \n    if not has_location(data):\n        errors.append(\"location or locations required\")\n    \n    return errors\n```\n\n---\n\n### MAKE_PROTECTED / MAKE_PUBLIC\n\n**Required:** domain + (location OR locations OR kms_locations/public_locations)\n\n```python\ndef validate_kms_operation(data):\n    errors = []\n    \n    if not has_domain(data):\n        errors.append(\"domain required\")\n    \n    has_loc = has_location(data)\n    has_kms_loc = is_field_present(data[\"kms_locations\"])\n    has_pub_loc = is_field_present(data.get(\"public_locations\", []))\n    \n    if not has_loc and not has_kms_loc and not has_pub_loc:\n        errors.append(\"location, locations, or kms_locations required\")\n    \n    return errors\n\n```\n---\n\n## ⚠️ WARNINGS vs MISSING FIELDS\n\n### What is a WARNING (does NOT block COMPLETE):\n\n| Condition | Warning Text |\n|-----------|--------------|\n| Same IPs in main/backup upstreams | \"Failover may not work with duplicate IPs\" |\n| No port in IP address | \"No port specified, defaults to :80\" |\n| High client_max_body_size | \"Large body size may pose security risks\" |\n| Empty parameters for CREATE_LOCATION | \"Consider adding timeout/buffer settings\" |\n| Low timeout values | \"Timeout < 10s may cause issues\" |\n\n### What is MISSING FIELD (DOES block COMPLETE):\n\n| Condition | Missing Field |\n|-----------|---------------|\n| No domain and no domains | \"domain: required\" |\n| No location and no locations (when needed) | \"location: required\" |\n| No upstreams for CREATE_LOCATION | \"upstreams: required\" |\n| No from_location for MODIFY_LOCATION_PATH | \"from_location: required\" |\n| No parameters for ADD_PARAMETERS | \"parameters: required\" |\n\n---\n\n## 📊 STATUS DETERMINATION\n\n```python\ndef determine_validation_status(missing_fields, syntax_errors, risk_level):\n    # Priority 1: High risk\n    if risk_level == \"high\":\n        return \"HIGH_RISK\"\n    \n    # Priority 2: Missing data or syntax errors\n    if missing_fields or syntax_errors:\n        return \"INCOMPLETE\"\n    \n    # Priority 3: Everything OK (warnings don't block!)\n    return \"COMPLETE\"\n\ndef is_ready_for_next_agent(status):\n    return status == \"COMPLETE\"\n```\n\n---\n\n## 📖 NGINX PARAMETERS DATABASE\n\n### Size Parameters (lowercase k/m/g only)\n\n| Parameter | Format | Example |\n|-----------|--------|---------|\n| `proxy_buffer_size` | SIZE | 32k, 64k |\n| `proxy_buffers` | COUNT SIZE | 4 32k |\n| `client_max_body_size` | SIZE or 0 | 50m, 0 |\n| `client_header_buffer_size` | SIZE | 128k |\n| `large_client_header_buffers` | COUNT SIZE | 4 32k |\n\n### Timeout Parameters (seconds or lowercase s/m)\n\n| Parameter | Format | Example |\n|-----------|--------|---------|\n| `proxy_connect_timeout` | TIME | 60, 60s, 5m |\n| `proxy_send_timeout` | TIME | 60, 600 |\n| `proxy_read_timeout` | TIME | 60s |\n\n### Boolean Parameters (lowercase on/off only)\n\n| Parameter | Values |\n|-----------|--------|\n| `gzip` | on, off |\n| `underscores_in_headers` | on, off |\n| `http2` | on, off |\n\n### Special Parameters\n\n| Parameter | Validation |\n|-----------|------------|\n| `proxy_pass` | **SKIP** - always valid |\n| `allow` | IP/CIDR format |\n| `deny` | IP/CIDR/all |\n\n---\n\n## ✅ VALIDATION EXAMPLES\n\n### Example 1: CREATE_LOCATION with locations array\n\n**Input:**\n\n{{\n  \"operation\": \"CREATE_LOCATION\",\n  \"domain\": \"aip.mos.ru\",\n  \"location\": null,\n  \"locations\": [\"/api_V2/\", \"/api_V3/\", \"/api_V4/\"],\n  \"upstreams\": [\n    {{\"upstream_type\": \"main\", \"ip_addresses\": [\"10.10.10.10\", \"10.10.10.11\"]}},\n    {{\"upstream_type\": \"backup\", \"ip_addresses\": [\"10.10.10.10\", \"10.10.10.11\"]}}\n  ]\n}}\n\n\n**Validation Check:**\n- ✅ domain: \"aip.mos.ru\" → PRESENT\n- ✅ location: null, BUT locations: [3 items] → PRESENT\n- ✅ upstreams: has main with 2 IPs → PRESENT\n- ⚠️ Warning: same IPs in main/backup\n\n**Output:**\n\n{{\n  \"validation_status\": \"COMPLETE\",\n  \"data_complete\": true,\n  \"missing_fields\": [],\n  \"syntax_errors\": [],\n  \"clarification_questions\": [],\n  \"upstream_validation\": {{\n    \"valid_upstreams\": [\n      {{\"type\": \"main\", \"ips\": [\"10.10.10.10\", \"10.10.10.11\"], \"status\": \"valid\"}},\n      {{\"type\": \"backup\", \"ips\": [\"10.10.10.10\", \"10.10.10.11\"], \"status\": \"valid\"}}\n    ],\n    \"warnings\": [\"Same IPs in main and backup - failover may not work as expected\"]\n  }},\n  \"risk_assessment\": {{\n    \"risk_level\": \"low\",\n    \"warnings\": [\"Consider different IPs for backup upstreams\"]\n  }},\n  \"ready_for_next_agent\": true\n}}\n\n\n---\n\n### Example 2: MODIFY_LOCATION_PATH\n\n**Input:**\n\n{{\n  \"operation\": \"MODIFY_LOCATION_PATH\",\n  \"domain\": \"mobile-newmos.mos.ru\",\n  \"location\": null,\n  \"locations\": [],\n  \"from_location\": \"/relay\",\n  \"to_location\": \"/relay/\"\n}}\n\n\n**Validation Check:**\n- ✅ domain: \"mobile-newmos.mos.ru\" → PRESENT\n- ✅ from_location: \"/relay\" → PRESENT\n- ✅ to_location: \"/relay/\" → PRESENT\n- ⏭️ location/locations: NOT CHECKED for this operation\n\n**Output:**\n\n{{\n  \"validation_status\": \"COMPLETE\",\n  \"data_complete\": true,\n  \"missing_fields\": [],\n  \"syntax_errors\": [],\n  \"clarification_questions\": [],\n  \"ready_for_next_agent\": true\n}}\n\n\n---\n\n### Example 3: ADD_PARAMETERS server block level\n\n**Input:**\n\n{{\n  \"operation\": \"ADD_PARAMETERS\",\n  \"domain\": \"api.mos.ru\",\n  \"location\": null,\n  \"locations\": [],\n  \"server_block_parameters\": [\"gzip:on\", \"client_max_body_size:50m\"]\n}}\n\n\n**Validation Check:**\n- ✅ domain: \"api.mos.ru\" → PRESENT\n- ✅ server_block_parameters: [2 items] → PRESENT (location not needed)\n- ✅ Parameters syntax: valid\n\n**Output:**\n\n{{\n  \"validation_status\": \"COMPLETE\",\n  \"data_complete\": true,\n  \"missing_fields\": [],\n  \"ready_for_next_agent\": true\n}}\n\n\n---\n\n### Example 4: Multiple domains with server_block_parameters\n\n**Input:**\n\n{{\n  \"operation\": \"ADD_PARAMETERS\",\n  \"domain\": null,\n  \"domains\": [\"aip.mos.ru\", \"dchelper.mos.ru\"],\n  \"location\": null,\n  \"locations\": [],\n  \"server_block_parameters\": [\n    \"proxy_buffer_size:32k\",\n    \"proxy_buffers:4 32k\",\n    \"large_client_header_buffers:4 32k\"\n  ]\n}}\n\n\n**Validation Check:**\n- ✅ domain: null, BUT domains: [\"aip.mos.ru\", \"dchelper.mos.ru\"] → PRESENT\n- ✅ location: null, BUT server_block_parameters: [3 items] → SERVER BLOCK LEVEL (location not needed)\n- ✅ Parameters syntax: all valid (lowercase k)\n\n**Output:**\n\n{{\n  \"validation_status\": \"COMPLETE\",\n  \"data_complete\": true,\n  \"missing_fields\": [],\n  \"syntax_errors\": [],\n  \"clarification_questions\": [],\n  \"parameter_validation\": {{\n    \"validated_parameters\": [\n      \"proxy_buffer_size: 32k (valid)\",\n      \"proxy_buffers: 4 32k (valid)\",\n      \"large_client_header_buffers: 4 32k (valid)\"\n    ],\n    \"invalid_parameters\": [],\n    \"warnings\": [],\n    \"recommendations\": [\"Consider setting proxy_busy_buffers_size for buffer consistency\"]\n  }},\n  \"ready_for_next_agent\": true\n}}\n\n\n---\n\n## 🚫 ANTI-PATTERNS (DO NOT DO THIS!)\n\n### ❌ Bug 1: Ignoring locations array\n\nInput: {{\"location\": null, \"locations\": [\"/api\", \"/v2\"]}}\n\nWRONG output:\n{{\n  \"missing_fields\": [\"location: required\"],\n  \"validation_status\": \"INCOMPLETE\"\n}}\n\nCORRECT output:\n{{\n  \"missing_fields\": [],\n  \"validation_status\": \"COMPLETE\"\n}}\n\n\n### ❌ Bug 2: Not parsing upstreams\n\n\nInput: {{\n  \"upstreams\": [\n    {{\"upstream_type\": \"main\", \"ip_addresses\": [\"10.0.0.1:80\"]}}\n  ]\n}}\n\nWRONG output:\n{{\n  \"missing_fields\": [\"upstreams: required\"],\n  \"validation_status\": \"INCOMPLETE\"\n}}\n\nCORRECT output:\n{{\n  \"missing_fields\": [],\n  \"validation_status\": \"COMPLETE\"\n}}\n\n\n### ❌ Bug 3: Warnings blocking completion\n\n\nInput: upstreams with same IPs in main/backup\n\nWRONG output:\n{{\n  \"missing_fields\": [\"upstreams: should have different IPs\"],\n  \"validation_status\": \"INCOMPLETE\"\n}}\n\nCORRECT output:\n{{\n  \"missing_fields\": [],\n  \"warnings\": [\"Same IPs in main/backup\"],\n  \"validation_status\": \"COMPLETE\"\n}}\n\n\n### ❌ Bug 4: Wrong fields for MODIFY_LOCATION_PATH\n\n\nInput: {{\n  \"operation\": \"MODIFY_LOCATION_PATH\",\n  \"location\": null,\n  \"from_location\": \"/old\",\n  \"to_location\": \"/new\"\n}}\n\nWRONG output:\n{{\n  \"missing_fields\": [\"location: required\"],\n  \"validation_status\": \"INCOMPLETE\"\n}}\n\nCORRECT output:\n{{\n  \"missing_fields\": [],\n  \"validation_status\": \"COMPLETE\"\n}}\n\n\n### ❌ Bug 5: Ignoring domains array\n\nInput: {{\"domain\": null, \"domains\": [\"aip.mos.ru\", \"dchelper.mos.ru\"]}}\n\nWRONG output:\n{{\n  \"missing_fields\": [\"domain: No domain or domains specified\"],\n  \"validation_status\": \"INCOMPLETE\"\n}}\n\nCORRECT output:\n{{\n  \"missing_fields\": [],\n  \"validation_status\": \"COMPLETE\"\n}}\n\n\n### ❌ Bug 6: Requiring location for server_block operations\n\n\nInput: {{\n  \"operation\": \"ADD_PARAMETERS\",\n  \"location\": null,\n  \"locations\": [],\n  \"server_block_parameters\": [\"gzip:on\"]\n}}\n\nWRONG output:\n{{\n  \"missing_fields\": [\"location: required\"],\n  \"validation_status\": \"INCOMPLETE\"\n}}\n\nCORRECT output:\n{{\n  \"missing_fields\": [],\n  \"validation_status\": \"COMPLETE\"\n  // server_block_parameters means server-level, no location needed\n}}\n\n\n---\n\n## 📊 OUTPUT SCHEMA\n\n\n{{\n  \"validation_status\": \"COMPLETE | INCOMPLETE | HIGH_RISK\",\n  \"data_complete\": true | false,\n  \"missing_fields\": [],\n  \"syntax_errors\": [],\n  \"clarification_questions\": [],\n  \"parameter_validation\": {{\n    \"validated_parameters\": [],\n    \"invalid_parameters\": [],\n    \"warnings\": [],\n    \"recommendations\": []\n  }},\n  \"kms_rules\": {{\n    \"locations_need_kms\": [],\n    \"locations_public\": [],\n    \"note\": null\n  }},\n  \"upstream_validation\": {{\n    \"valid_upstreams\": [],\n    \"invalid_upstreams\": [],\n    \"warnings\": []\n  }},\n  \"risk_assessment\": {{\n    \"risk_level\": \"low | medium | high\",\n    \"risk_factors\": [],\n    \"warnings\": [],\n    \"requires_confirmation\": false\n  }},\n  \"cross_referenced\": {{\n    \"applied\": false,\n    \"note\": null,\n    \"inherited_fields\": []\n  }},\n  \"ready_for_next_agent\": true | false,\n  \"validation_summary\": {{\n    \"total_parameters\": 0,\n    \"valid_parameters\": 0,\n    \"invalid_parameters\": 0,\n    \"skipped_parameters\": 0\n  }}\n}}\n\n\n---\n\n## 🧠 MANDATORY REASONING PROCESS\n\nBefore outputting JSON, think step by step:\n\n\n<thinking>\n1. PARSE INPUT\n   - Operation: [operation]\n   - Domain present? [check domain AND domains]\n   - Location present? [check location AND locations]\n   - From/to location? [for MODIFY_LOCATION_PATH]\n   - Upstreams present? [check array contents]\n   - Parameters present? [check all param fields]\n\n2. DETERMINE REQUIRED FIELDS\n   - For [operation], required fields are: [list]\n   - Checking each:\n     - Field X: [present/missing]\n     - Field Y: [present/missing]\n\n3. VALIDATE SYNTAX (if parameters present)\n   - Parameter A: [valid/invalid]\n   - Parameter B: [valid/invalid]\n\n4. IDENTIFY WARNINGS (do not block completion!)\n   - [list any warnings]\n\n5. DETERMINE STATUS\n   - Missing fields: [count]\n   - Syntax errors: [count]\n   - High risk: [yes/no]\n   - Final status: [COMPLETE/INCOMPLETE/HIGH_RISK]\n\n6. SET READY FLAG\n   - Status is COMPLETE? [yes/no]\n   - ready_for_next_agent: [true/false]\n</thinking>\n\n\n---\n\n## ❗ CRITICAL RULES\n\n1. **ALWAYS check both `domain` AND `domains`** — either one being present is valid\n2. **ALWAYS check both `location` AND `locations`** — either one being present is valid\n3. **ALWAYS parse `upstreams` array contents** — check ip_addresses inside\n4. **NEVER treat warnings as missing fields** — warnings don't block COMPLETE\n5. **For MODIFY_LOCATION_PATH** — check from_location/to_location, NOT location/locations\n6. **For server_block_parameters** — location NOT required when operating at server level\n7. **Skip proxy_pass validation** — always mark as valid\n8. **Consistency check** — if missing_fields is empty, status should be COMPLETE\n\n---\n\n## NOW VALIDATE\n\n**AGENT 1 OUTPUT:**\n{agent1_json}\n\n**ORIGINAL REQUEST:**\n{original_question}\n\n---\n\n**Output ONLY valid JSON:**\n"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-e5PJD",
        "measured": {
          "height": 441,
          "width": 320
        },
        "position": {
          "x": -3823.261016282711,
          "y": 794.8529229848791
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONCleaner-fufw1",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.",
            "display_name": "JSON Cleaner",
            "documentation": "",
            "edited": false,
            "field_order": [
              "json_str",
              "remove_control_chars",
              "normalize_unicode",
              "validate_json"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "JSONCleaner",
            "legacy": true,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Cleaned JSON String",
                "group_outputs": false,
                "method": "clean_json",
                "name": "output",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "replacement": [
              "processing.ParserComponent"
            ],
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport unicodedata\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass JSONCleaner(Component):\n    icon = \"braces\"\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n    legacy = True\n    replacement = [\"processing.ParserComponent\"]\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with `pip install json_repair`.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        start = json_str.find(\"{\")\n        end = json_str.rfind(\"}\")\n        if start == -1 or end == -1:\n            msg = \"Invalid JSON string: Missing '{' or '}'\"\n            raise ValueError(msg)\n        try:\n            json_str = json_str[start : end + 1]\n\n            if remove_control_chars:\n                json_str = self._remove_control_characters(json_str)\n            if normalize_unicode:\n                json_str = self._normalize_unicode(json_str)\n            if validate_json:\n                json_str = self._validate_json(json_str)\n\n            cleaned_json_str = repair_json(json_str)\n            result = str(cleaned_json_str)\n\n            self.status = result\n            return Message(text=result)\n        except Exception as e:\n            msg = f\"Error cleaning JSON string: {e}\"\n            raise ValueError(msg) from e\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return s.translate(self.translation_table)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def _validate_json(self, s: str) -> str:\n        \"\"\"Validate the JSON string.\"\"\"\n        try:\n            json.loads(s)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON string: {e}\"\n            raise ValueError(msg) from e\n        return s\n\n    def __init__(self, *args, **kwargs):\n        # Create a translation table that maps control characters to None\n        super().__init__(*args, **kwargs)\n        self.translation_table = str.maketrans(\"\", \"\", \"\".join(chr(i) for i in range(32)) + chr(127))\n"
              },
              "json_str": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "The JSON string to be cleaned.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "json_str",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "normalize_unicode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Normalize Unicode",
                "dynamic": false,
                "info": "Normalize Unicode characters in the JSON string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "normalize_unicode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "remove_control_chars": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Remove Control Characters",
                "dynamic": false,
                "info": "Remove control characters from the JSON string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "remove_control_chars",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "validate_json": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Validate JSON",
                "dynamic": false,
                "info": "Validate the JSON string to ensure it is well-formed.",
                "list": false,
                "list_add_label": "Add More",
                "name": "validate_json",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONCleaner"
        },
        "id": "JSONCleaner-fufw1",
        "measured": {
          "height": 440,
          "width": 320
        },
        "position": {
          "x": -2755.850443650163,
          "y": 1076.075658991974
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ArbitratorComponent-QAA61",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Проверяет validation_status от Agent2 и возвращает JSON от Agent1 если COMPLETE",
            "display_name": "JSON Arbitrator",
            "documentation": "",
            "edited": true,
            "field_order": [
              "agent1_output",
              "agent2_output"
            ],
            "frozen": false,
            "icon": "check-circle",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Result",
                "group_outputs": false,
                "hidden": null,
                "method": "process",
                "name": "result",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Needs Clarification",
                "group_outputs": false,
                "hidden": null,
                "method": "get_clarification",
                "name": "needs_clarification",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "agent1_output": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Agent 1 Output",
                "dynamic": false,
                "info": "JSON от первого агента (парсер)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "agent1_output",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "agent2_output": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Agent 2 Output",
                "dynamic": false,
                "info": "JSON от второго агента (валидатор)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "agent2_output",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema.data import Data\nimport json\n\n\nclass ArbitratorComponent(Component):\n    display_name = \"JSON Arbitrator\"\n    description = \"Проверяет validation_status от Agent2 и возвращает JSON от Agent1 если COMPLETE\"\n    icon = \"check-circle\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"agent1_output\",\n            display_name=\"Agent 1 Output\",\n            info=\"JSON от первого агента (парсер)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"agent2_output\",\n            display_name=\"Agent 2 Output\",\n            info=\"JSON от второго агента (валидатор)\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Result\",\n            name=\"result\",\n            method=\"process\",\n        ),\n        Output(\n            display_name=\"Needs Clarification\",\n            name=\"needs_clarification\",\n            method=\"get_clarification\",\n        ),\n    ]\n\n    def _parse_json(self, text: str) -> dict:\n        \"\"\"Парсит JSON, убирая markdown обёртки если есть\"\"\"\n        text = text.strip()\n        # Убираем ```json ... ``` если есть\n        if text.startswith(\"```\"):\n            lines = text.split(\"\\n\")\n            # Убираем первую и последнюю строку с ```\n            lines = [l for l in lines if not l.strip().startswith(\"```\")]\n            text = \"\\n\".join(lines)\n        return json.loads(text)\n\n    def _is_valid(self, agent2_data: dict) -> bool:\n        \"\"\"Проверяет статус валидации\"\"\"\n        status = agent2_data.get(\"validation_status\", \"\").upper()\n        return status == \"COMPLETE\"\n\n    def process(self) -> Data:\n        \"\"\"Основной выход — возвращает agent1 JSON напрямую, если валидация прошла\"\"\"\n        try:\n            agent1_data = self._parse_json(self.agent1_output)\n            agent2_data = self._parse_json(self.agent2_output)\n    \n            if self._is_valid(agent2_data):\n                # Возвращаем именно payload-структуру, без мета-обёртки\n                return Data(data=agent1_data)\n            else:\n                return Data(data={\n                    \"status\": \"VALIDATION_FAILED\",\n                    \"payload\": None,\n                    \"ready_for_execution\": False,\n                    \"missing_fields\": agent2_data.get(\"missing_fields\", []),\n                    \"clarification_questions\": agent2_data.get(\"clarification_questions\", [])\n                })\n    \n        except json.JSONDecodeError as e:\n            return Data(data={\n                \"status\": \"PARSE_ERROR\",\n                \"error\": str(e),\n                \"ready_for_execution\": False\n            })\n\n    def get_clarification(self) -> Data:\n        \"\"\"Второй выход — вопросы для уточнения если нужны\"\"\"\n        try:\n            agent2_data = self._parse_json(self.agent2_output)\n\n            if not self._is_valid(agent2_data):\n                questions = agent2_data.get(\"clarification_questions\", [])\n                missing = agent2_data.get(\"missing_fields\", [])\n                \n                return Data(data={\n                    \"needs_clarification\": True,\n                    \"questions\": questions,\n                    \"missing_fields\": missing,\n                    \"message\": self._format_clarification_message(questions, missing)\n                })\n            else:\n                return Data(data={\n                    \"needs_clarification\": False,\n                    \"questions\": [],\n                    \"missing_fields\": [],\n                    \"message\": None\n                })\n\n        except json.JSONDecodeError:\n            return Data(data={\n                \"needs_clarification\": True,\n                \"questions\": [],\n                \"missing_fields\": [],\n                \"message\": \"Ошибка парсинга JSON от агентов\"\n            })\n\n    def _format_clarification_message(self, questions: list, missing: list) -> str:\n        \"\"\"Форматирует сообщение для пользователя\"\"\"\n        parts = []\n        \n        if missing:\n            parts.append(\"Не хватает данных:\")\n            for field in missing:\n                parts.append(f\"  • {field}\")\n        \n        if questions:\n            parts.append(\"\\nУточняющие вопросы:\")\n            for q in questions:\n                parts.append(f\"  • {q}\")\n        \n        return \"\\n\".join(parts) if parts else \"Требуется уточнение запроса\""
              }
            },
            "tool_mode": false
          },
          "selected_output": "result",
          "showNode": true,
          "type": "ArbitratorComponent"
        },
        "dragging": false,
        "id": "ArbitratorComponent-QAA61",
        "measured": {
          "height": 301,
          "width": 320
        },
        "position": {
          "x": -2094.9199896549108,
          "y": 833.7505998288807
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-qCqZS",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "logic",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "https://docs.langflow.org/components-logic#conditional-router-if-else-component",
            "edited": false,
            "field_order": [
              "input_text",
              "operator",
              "match_text",
              "case_sensitive",
              "true_case_message",
              "false_case_message",
              "max_iterations",
              "default_route"
            ],
            "frozen": false,
            "icon": "split",
            "key": "ConditionalRouter",
            "last_updated": "2025-11-30T12:21:17.327Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "group_outputs": true,
                "method": "true_response",
                "name": "true_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "group_outputs": true,
                "method": "false_response",
                "name": "false_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    documentation: str = \"https://docs.langflow.org/components-logic#conditional-router-if-else-component\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\n                \"equals\",\n                \"not equals\",\n                \"contains\",\n                \"starts with\",\n                \"ends with\",\n                \"regex\",\n                \"less than\",\n                \"less than or equal\",\n                \"greater than\",\n                \"greater than or equal\",\n            ],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=True,\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"true_case_message\",\n            display_name=\"Case True\",\n            info=\"The message to pass if the condition is True.\",\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"false_case_message\",\n            display_name=\"Case False\",\n            info=\"The message to pass if the condition is False.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\", group_outputs=True),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\", group_outputs=True),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n            try:\n                input_num = float(input_text)\n                match_num = float(match_text)\n                if operator == \"less than\":\n                    return input_num < match_num\n                if operator == \"less than or equal\":\n                    return input_num <= match_num\n                if operator == \"greater than\":\n                    return input_num > match_num\n                if operator == \"greater than or equal\":\n                    return input_num >= match_num\n            except ValueError:\n                return False  # Invalid number format for comparison\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        \"\"\"Handles cycle iteration counting and branch exclusion.\n\n        Uses two complementary mechanisms:\n        1. stop() - ACTIVE/INACTIVE state for cycle management (gets reset each iteration)\n        2. exclude_branch_conditionally() - Persistent exclusion for conditional routing\n\n        When max_iterations is reached, breaks the cycle by allowing the default_route to execute.\n        \"\"\"\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n\n            # Check if max iterations reached and we're trying to stop the default route\n            if current_iteration >= self.max_iterations and route_to_stop == self.default_route:\n                # Clear ALL conditional exclusions to allow default route to execute\n                if self._id in self.graph.conditional_exclusion_sources:\n                    previous_exclusions = self.graph.conditional_exclusion_sources[self._id]\n                    self.graph.conditionally_excluded_vertices -= previous_exclusions\n                    del self.graph.conditional_exclusion_sources[self._id]\n\n                # Switch which route to stop - stop the NON-default route to break the cycle\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n\n                # Call stop to break the cycle\n                self.stop(route_to_stop)\n                # Don't apply conditional exclusion when breaking cycle\n                return\n\n            # Normal case: Use BOTH mechanisms\n            # 1. stop() for cycle management (marks INACTIVE, updates run manager, gets reset)\n            self.stop(route_to_stop)\n\n            # 2. Conditional exclusion for persistent routing (doesn't get reset except by this router)\n            self.graph.exclude_branch_conditionally(self._id, output_name=route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        # Check if we should force output due to max_iterations on default route\n        current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n        force_output = current_iteration >= self.max_iterations and self.default_route == \"true_result\"\n\n        if result or force_output:\n            self.status = self.true_case_message\n            if not force_output:  # Only stop the other branch if not forcing due to max iterations\n                self.iterate_and_stop_once(\"false_result\")\n            return self.true_case_message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        if not result:\n            self.status = self.false_case_message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.false_case_message\n\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "external_options": {},
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "false_case_message": {
                "_input_type": "MessageInput",
                "advanced": true,
                "display_name": "Case False",
                "dynamic": false,
                "info": "The message to pass if the condition is False.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "false_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ".*(ADD_PARAMETERS|MODIFY_PARAMETERS|DELETE_PARAMETERS|DELETE_LOCATION|CREATE_LOCATION|MODIFY_LOCATION_PATH|MAKE_PROTECTED|MAKE_PUBLIC).*"
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "external_options": {},
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex",
                  "less than",
                  "less than or equal",
                  "greater than",
                  "greater than or equal"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "regex"
              },
              "true_case_message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Case True",
                "dynamic": false,
                "info": "The message to pass if the condition is True.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "true_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-qCqZS",
        "measured": {
          "height": 509,
          "width": 320
        },
        "position": {
          "x": -304.8371924001824,
          "y": 925.35154674653
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-vf90w",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "logic",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "https://docs.langflow.org/components-logic#conditional-router-if-else-component",
            "edited": false,
            "field_order": [
              "input_text",
              "operator",
              "match_text",
              "case_sensitive",
              "true_case_message",
              "false_case_message",
              "max_iterations",
              "default_route"
            ],
            "frozen": false,
            "icon": "split",
            "key": "ConditionalRouter",
            "last_updated": "2025-11-30T12:02:50.362Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "group_outputs": true,
                "method": "true_response",
                "name": "true_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "group_outputs": true,
                "method": "false_response",
                "name": "false_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    documentation: str = \"https://docs.langflow.org/components-logic#conditional-router-if-else-component\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\n                \"equals\",\n                \"not equals\",\n                \"contains\",\n                \"starts with\",\n                \"ends with\",\n                \"regex\",\n                \"less than\",\n                \"less than or equal\",\n                \"greater than\",\n                \"greater than or equal\",\n            ],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=True,\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"true_case_message\",\n            display_name=\"Case True\",\n            info=\"The message to pass if the condition is True.\",\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"false_case_message\",\n            display_name=\"Case False\",\n            info=\"The message to pass if the condition is False.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\", group_outputs=True),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\", group_outputs=True),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n            try:\n                input_num = float(input_text)\n                match_num = float(match_text)\n                if operator == \"less than\":\n                    return input_num < match_num\n                if operator == \"less than or equal\":\n                    return input_num <= match_num\n                if operator == \"greater than\":\n                    return input_num > match_num\n                if operator == \"greater than or equal\":\n                    return input_num >= match_num\n            except ValueError:\n                return False  # Invalid number format for comparison\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        \"\"\"Handles cycle iteration counting and branch exclusion.\n\n        Uses two complementary mechanisms:\n        1. stop() - ACTIVE/INACTIVE state for cycle management (gets reset each iteration)\n        2. exclude_branch_conditionally() - Persistent exclusion for conditional routing\n\n        When max_iterations is reached, breaks the cycle by allowing the default_route to execute.\n        \"\"\"\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n\n            # Check if max iterations reached and we're trying to stop the default route\n            if current_iteration >= self.max_iterations and route_to_stop == self.default_route:\n                # Clear ALL conditional exclusions to allow default route to execute\n                if self._id in self.graph.conditional_exclusion_sources:\n                    previous_exclusions = self.graph.conditional_exclusion_sources[self._id]\n                    self.graph.conditionally_excluded_vertices -= previous_exclusions\n                    del self.graph.conditional_exclusion_sources[self._id]\n\n                # Switch which route to stop - stop the NON-default route to break the cycle\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n\n                # Call stop to break the cycle\n                self.stop(route_to_stop)\n                # Don't apply conditional exclusion when breaking cycle\n                return\n\n            # Normal case: Use BOTH mechanisms\n            # 1. stop() for cycle management (marks INACTIVE, updates run manager, gets reset)\n            self.stop(route_to_stop)\n\n            # 2. Conditional exclusion for persistent routing (doesn't get reset except by this router)\n            self.graph.exclude_branch_conditionally(self._id, output_name=route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        # Check if we should force output due to max_iterations on default route\n        current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n        force_output = current_iteration >= self.max_iterations and self.default_route == \"true_result\"\n\n        if result or force_output:\n            self.status = self.true_case_message\n            if not force_output:  # Only stop the other branch if not forcing due to max iterations\n                self.iterate_and_stop_once(\"false_result\")\n            return self.true_case_message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        if not result:\n            self.status = self.false_case_message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.false_case_message\n\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "external_options": {},
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "false_case_message": {
                "_input_type": "MessageInput",
                "advanced": true,
                "display_name": "Case False",
                "dynamic": false,
                "info": "The message to pass if the condition is False.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "false_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ".*(DELETE_LOCATION|CREATE_LOCATION|MODIFY_UPSTREAM).*"
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "external_options": {},
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex",
                  "less than",
                  "less than or equal",
                  "greater than",
                  "greater than or equal"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "regex"
              },
              "true_case_message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Case True",
                "dynamic": false,
                "info": "The message to pass if the condition is True.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "true_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-vf90w",
        "measured": {
          "height": 509,
          "width": 320
        },
        "position": {
          "x": -301.9423582441287,
          "y": 1617.0785552048737
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-GDJZu",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "ParserComponent",
            "last_updated": "2025-12-08T19:35:28.674Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Clean Data",
                "dynamic": false,
                "info": "Enable to clean the data by removing empty rows and lines in each cell of the DataFrame/ Data object.",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Stringify"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": false,
                "show": false,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{payload}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-GDJZu",
        "measured": {
          "height": 245,
          "width": 320
        },
        "position": {
          "x": -1493.2483126092316,
          "y": 1275.092166277196
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "JSONCleaner-Zb1tD",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.",
            "display_name": "JSON Cleaner",
            "documentation": "",
            "edited": false,
            "field_order": [
              "json_str",
              "remove_control_chars",
              "normalize_unicode",
              "validate_json"
            ],
            "frozen": false,
            "icon": "braces",
            "key": "JSONCleaner",
            "legacy": true,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Cleaned JSON String",
                "group_outputs": false,
                "method": "clean_json",
                "name": "output",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "replacement": [
              "processing.ParserComponent"
            ],
            "score": 0.007568328950209746,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport unicodedata\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass JSONCleaner(Component):\n    icon = \"braces\"\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n    legacy = True\n    replacement = [\"processing.ParserComponent\"]\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with `pip install json_repair`.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        start = json_str.find(\"{\")\n        end = json_str.rfind(\"}\")\n        if start == -1 or end == -1:\n            msg = \"Invalid JSON string: Missing '{' or '}'\"\n            raise ValueError(msg)\n        try:\n            json_str = json_str[start : end + 1]\n\n            if remove_control_chars:\n                json_str = self._remove_control_characters(json_str)\n            if normalize_unicode:\n                json_str = self._normalize_unicode(json_str)\n            if validate_json:\n                json_str = self._validate_json(json_str)\n\n            cleaned_json_str = repair_json(json_str)\n            result = str(cleaned_json_str)\n\n            self.status = result\n            return Message(text=result)\n        except Exception as e:\n            msg = f\"Error cleaning JSON string: {e}\"\n            raise ValueError(msg) from e\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return s.translate(self.translation_table)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def _validate_json(self, s: str) -> str:\n        \"\"\"Validate the JSON string.\"\"\"\n        try:\n            json.loads(s)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON string: {e}\"\n            raise ValueError(msg) from e\n        return s\n\n    def __init__(self, *args, **kwargs):\n        # Create a translation table that maps control characters to None\n        super().__init__(*args, **kwargs)\n        self.translation_table = str.maketrans(\"\", \"\", \"\".join(chr(i) for i in range(32)) + chr(127))\n"
              },
              "json_str": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "JSON String",
                "dynamic": false,
                "info": "The JSON string to be cleaned.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "json_str",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "normalize_unicode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Normalize Unicode",
                "dynamic": false,
                "info": "Normalize Unicode characters in the JSON string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "normalize_unicode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "remove_control_chars": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Remove Control Characters",
                "dynamic": false,
                "info": "Remove control characters from the JSON string.",
                "list": false,
                "list_add_label": "Add More",
                "name": "remove_control_chars",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "validate_json": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Validate JSON",
                "dynamic": false,
                "info": "Validate the JSON string to ensure it is well-formed.",
                "list": false,
                "list_add_label": "Add More",
                "name": "validate_json",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "JSONCleaner"
        },
        "dragging": false,
        "id": "JSONCleaner-Zb1tD",
        "measured": {
          "height": 440,
          "width": 320
        },
        "position": {
          "x": -1002.2438280070185,
          "y": 1121.2320175295094
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-T79uA",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "https://docs.langflow.org/components-io#chat-input",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatInput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0020353564437605998,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        # Ensure files is a list and filter out empty/None values\n        files = self.files if self.files else []\n        if files and not isinstance(files, list):\n            files = [files]\n        files = [f for f in files if f is not None and f != \"\"]\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "csv",
                  "json",
                  "pdf",
                  "txt",
                  "md",
                  "mdx",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-T79uA",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": -5856.291632166402,
          "y": 1262.4353058239337
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-8UqlH",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extract 'warnings' and 'error' from operation result dict or JSON string and omit empty fields.",
            "display_name": "Extract Warnings/Error",
            "documentation": "https://docs.langflow.org/components-custom-components",
            "edited": true,
            "field_order": [
              "result_input"
            ],
            "frozen": false,
            "icon": "code",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Warnings and Error",
                "group_outputs": false,
                "hidden": null,
                "method": "build_output",
                "name": "output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema.data import Data\nimport json\nimport logging\nfrom typing import Any, Dict, List, Optional\n\nlog = logging.getLogger(__name__)\n\nclass ExtractWarningsErrorComponent(Component):\n    display_name = \"Extract Warnings/Error\"\n    description = \"Extract 'warnings' and 'error' from operation result dict or JSON string and omit empty fields.\"\n    documentation = \"https://docs.langflow.org/components-custom-components\"\n    icon = \"code\"\n    name = \"ExtractWarningsError\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"result_input\",\n            display_name=\"Result (dict or JSON)\",\n            info=\"Operation result as Python dict or JSON string\",\n            value=\"{}\",  # default\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Warnings and Error\", name=\"output\", method=\"build_output\"),\n    ]\n\n    def _parse_input(self, raw: Any) -> Dict[str, Any]:\n        if isinstance(raw, dict):\n            return raw\n        if isinstance(raw, str):\n            try:\n                return json.loads(raw)\n            except json.JSONDecodeError:\n                log.warning(\"Input is a non-JSON string; returning empty dict\")\n                return {}\n        return {}\n\n    def _normalize_warnings(self, w: Any) -> List[str]:\n        if w is None:\n            return []\n        if isinstance(w, list):\n            return [str(x) for x in w if x is not None and str(x).strip() != \"\"]\n        return [str(w)] if str(w).strip() != \"\" else []\n\n    def build_output(self) -> Data:\n        parsed = self._parse_input(self.result_input)\n        out: Dict[str, Any] = {}\n\n        # Извлечь и нормализовать warnings\n        if \"warnings\" in parsed:\n            warnings = self._normalize_warnings(parsed.get(\"warnings\"))\n            if warnings:  # добавляем только если есть ненулевые элементы\n                out[\"warnings\"] = warnings\n            else:\n                log.debug(\"'warnings' present but empty; omitting from output\")\n        else:\n            log.debug(\"No 'warnings' field found in input\")\n\n        # Извлечь и нормализовать error\n        if \"error\" in parsed:\n            err = parsed.get(\"error\")\n            if err is not None:\n                err_str = str(err).strip()\n                if err_str != \"\":\n                    out[\"error\"] = err_str\n                else:\n                    log.debug(\"'error' field present but empty; omitting from output\")\n            else:\n                log.debug(\"'error' is explicitly null; omitting from output\")\n        else:\n            log.debug(\"No 'error' field found in input\")\n\n        # Если out пустой — вернуть пустой dict (а не ключи с пустыми значениями)\n        data = Data(value=out)\n        self.status = data\n        return data\n"
              },
              "result_input": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Result (dict or JSON)",
                "dynamic": false,
                "info": "Operation result as Python dict or JSON string",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "result_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ExtractWarningsError"
        },
        "dragging": false,
        "id": "CustomComponent-8UqlH",
        "measured": {
          "height": 219,
          "width": 320
        },
        "position": {
          "x": 2431.5426094158192,
          "y": 158.90239262187865
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-XRXIr",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-XRXIr",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 3217.36629377099,
          "y": 416.11070446651655
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-EwEbV",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{value}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-EwEbV",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": 2818.4442353647314,
          "y": 135.9802795309928
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -636.7979306173484,
      "y": -411.98259380877175,
      "zoom": 0.7515807390327814
    }
  },
  "description": "Empowering Language Engineering.",
  "endpoint_name": null,
  "id": "f29f03b3-877b-40a1-aa10-add2498b140b",
  "is_component": false,
  "last_tested_version": "1.6.0",
  "name": "Yaml Sub Locations",
  "tags": []
}