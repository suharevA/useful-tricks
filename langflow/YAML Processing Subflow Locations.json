{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-z6g2K",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "OpenAIModel-zisXO",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-z6g2K{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-z6g2Kœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-OpenAIModel-zisXO{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-zisXOœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-z6g2K",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-z6g2Kœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "OpenAIModel-zisXO",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œOpenAIModel-zisXOœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "OpenAIModel",
            "id": "OpenAIModel-zisXO",
            "name": "text_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "TypeConverterComponent-JGP5t",
            "inputTypes": [
              "Message",
              "Data",
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__OpenAIModel-zisXO{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-zisXOœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-TypeConverterComponent-JGP5t{œfieldNameœ:œinput_dataœ,œidœ:œTypeConverterComponent-JGP5tœ,œinputTypesœ:[œMessageœ,œDataœ,œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "OpenAIModel-zisXO",
        "sourceHandle": "{œdataTypeœ:œOpenAIModelœ,œidœ:œOpenAIModel-zisXOœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "TypeConverterComponent-JGP5t",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œTypeConverterComponent-JGP5tœ,œinputTypesœ:[œMessageœ,œDataœ,œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TypeConverterComponent",
            "id": "TypeConverterComponent-JGP5t",
            "name": "data_output",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-M2n5m",
            "name": "item",
            "output_types": [
              "Data"
            ]
          }
        },
        "id": "xy-edge__TypeConverterComponent-JGP5t{œdataTypeœ:œTypeConverterComponentœ,œidœ:œTypeConverterComponent-JGP5tœ,œnameœ:œdata_outputœ,œoutput_typesœ:[œDataœ]}-LoopComponent-M2n5m{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-M2n5mœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}",
        "selected": false,
        "source": "TypeConverterComponent-JGP5t",
        "sourceHandle": "{œdataTypeœ:œTypeConverterComponentœ,œidœ:œTypeConverterComponent-JGP5tœ,œnameœ:œdata_outputœ,œoutput_typesœ:[œDataœ]}",
        "target": "LoopComponent-M2n5m",
        "targetHandle": "{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-M2n5mœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "UniversalSearchConfigComponent",
            "id": "UniversalSearchConfigComponent-IuZIu",
            "name": "config_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "universal_search_result",
            "id": "LocationSelectorFromUniversalSearch-Arbrf",
            "inputTypes": [
              "Data",
              "dict"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__UniversalSearchConfigComponent-IuZIu{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-IuZIuœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}-LocationSelectorFromUniversalSearch-Arbrf{œfieldNameœ:œuniversal_search_resultœ,œidœ:œLocationSelectorFromUniversalSearch-Arbrfœ,œinputTypesœ:[œDataœ,œdictœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "UniversalSearchConfigComponent-IuZIu",
        "sourceHandle": "{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-IuZIuœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "LocationSelectorFromUniversalSearch-Arbrf",
        "targetHandle": "{œfieldNameœ:œuniversal_search_resultœ,œidœ:œLocationSelectorFromUniversalSearch-Arbrfœ,œinputTypesœ:[œDataœ,œdictœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConfigBlockSplitter",
            "id": "ConfigBlockSplitter-Rxujk",
            "name": "config_items_df",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "data",
            "id": "LoopComponent-M2n5m",
            "inputTypes": [
              "DataFrame"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ConfigBlockSplitter-Rxujk{œdataTypeœ:œConfigBlockSplitterœ,œidœ:œConfigBlockSplitter-Rxujkœ,œnameœ:œconfig_items_dfœ,œoutput_typesœ:[œDataFrameœ]}-LoopComponent-M2n5m{œfieldNameœ:œdataœ,œidœ:œLoopComponent-M2n5mœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ConfigBlockSplitter-Rxujk",
        "sourceHandle": "{œdataTypeœ:œConfigBlockSplitterœ,œidœ:œConfigBlockSplitter-Rxujkœ,œnameœ:œconfig_items_dfœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "LoopComponent-M2n5m",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œLoopComponent-M2n5mœ,œinputTypesœ:[œDataFrameœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-M2n5m",
            "name": "done",
            "output_types": [
              "DataFrame"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-6TZSU",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__LoopComponent-M2n5m{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-M2n5mœ,œnameœ:œdoneœ,œoutput_typesœ:[œDataFrameœ]}-ParserComponent-6TZSU{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-6TZSUœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "LoopComponent-M2n5m",
        "sourceHandle": "{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-M2n5mœ,œnameœ:œdoneœ,œoutput_typesœ:[œDataFrameœ]}",
        "target": "ParserComponent-6TZSU",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-6TZSUœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-6TZSU",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-wsqHO",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-6TZSU{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-6TZSUœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-wsqHO{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-wsqHOœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParserComponent-6TZSU",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-6TZSUœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-wsqHO",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-wsqHOœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "TextInput",
            "id": "TextInput-6bdk9",
            "name": "text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "agent1_json",
            "id": "UniversalSearchConfigComponent-IuZIu",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__TextInput-6bdk9{œdataTypeœ:œTextInputœ,œidœ:œTextInput-6bdk9œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-UniversalSearchConfigComponent-IuZIu{œfieldNameœ:œagent1_jsonœ,œidœ:œUniversalSearchConfigComponent-IuZIuœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "TextInput-6bdk9",
        "sourceHandle": "{œdataTypeœ:œTextInputœ,œidœ:œTextInput-6bdk9œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "target": "UniversalSearchConfigComponent-IuZIu",
        "targetHandle": "{œfieldNameœ:œagent1_jsonœ,œidœ:œUniversalSearchConfigComponent-IuZIuœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LocationSelectorFromUniversalSearch",
            "id": "LocationSelectorFromUniversalSearch-Arbrf",
            "name": "selected_block",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_text",
            "id": "ConditionalRouter-8PRCp",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LocationSelectorFromUniversalSearch-Arbrf{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-Arbrfœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-8PRCp{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-8PRCpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "LocationSelectorFromUniversalSearch-Arbrf",
        "sourceHandle": "{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-Arbrfœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-8PRCp",
        "targetHandle": "{œfieldNameœ:œinput_textœ,œidœ:œConditionalRouter-8PRCpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LocationSelectorFromUniversalSearch",
            "id": "LocationSelectorFromUniversalSearch-Arbrf",
            "name": "selected_block",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "false_case_message",
            "id": "ConditionalRouter-8PRCp",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LocationSelectorFromUniversalSearch-Arbrf{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-Arbrfœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}-ConditionalRouter-8PRCp{œfieldNameœ:œfalse_case_messageœ,œidœ:œConditionalRouter-8PRCpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "LocationSelectorFromUniversalSearch-Arbrf",
        "sourceHandle": "{œdataTypeœ:œLocationSelectorFromUniversalSearchœ,œidœ:œLocationSelectorFromUniversalSearch-Arbrfœ,œnameœ:œselected_blockœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConditionalRouter-8PRCp",
        "targetHandle": "{œfieldNameœ:œfalse_case_messageœ,œidœ:œConditionalRouter-8PRCpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ConditionalRouter",
            "id": "ConditionalRouter-8PRCp",
            "name": "false_result",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "selected_block",
            "id": "ConfigBlockSplitter-Rxujk",
            "inputTypes": [
              "Message",
              "Data",
              "dict"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ConditionalRouter-8PRCp{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-8PRCpœ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}-ConfigBlockSplitter-Rxujk{œfieldNameœ:œselected_blockœ,œidœ:œConfigBlockSplitter-Rxujkœ,œinputTypesœ:[œMessageœ,œDataœ,œdictœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ConditionalRouter-8PRCp",
        "sourceHandle": "{œdataTypeœ:œConditionalRouterœ,œidœ:œConditionalRouter-8PRCpœ,œnameœ:œfalse_resultœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ConfigBlockSplitter-Rxujk",
        "targetHandle": "{œfieldNameœ:œselected_blockœ,œidœ:œConfigBlockSplitter-Rxujkœ,œinputTypesœ:[œMessageœ,œDataœ,œdictœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "UniversalSearchConfigComponent",
            "id": "UniversalSearchConfigComponent-IuZIu",
            "name": "config_data",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-yXjE3",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__UniversalSearchConfigComponent-IuZIu{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-IuZIuœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}-ParserComponent-yXjE3{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-yXjE3œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "UniversalSearchConfigComponent-IuZIu",
        "sourceHandle": "{œdataTypeœ:œUniversalSearchConfigComponentœ,œidœ:œUniversalSearchConfigComponent-IuZIuœ,œnameœ:œconfig_dataœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-yXjE3",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-yXjE3œ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-yXjE3",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-PkDbl",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ParserComponent-yXjE3{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-yXjE3œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-PkDbl{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-PkDblœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ParserComponent-yXjE3",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-yXjE3œ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-PkDbl",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-PkDblœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LoopComponent",
            "id": "LoopComponent-M2n5m",
            "name": "item",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "fieldName": "input_data",
            "id": "ParserComponent-Ivr9p",
            "inputTypes": [
              "DataFrame",
              "Data"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__LoopComponent-M2n5m{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-M2n5mœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}-ParserComponent-Ivr9p{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-Ivr9pœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "LoopComponent-M2n5m",
        "sourceHandle": "{œdataTypeœ:œLoopComponentœ,œidœ:œLoopComponent-M2n5mœ,œnameœ:œitemœ,œoutput_typesœ:[œDataœ]}",
        "target": "ParserComponent-Ivr9p",
        "targetHandle": "{œfieldNameœ:œinput_dataœ,œidœ:œParserComponent-Ivr9pœ,œinputTypesœ:[œDataFrameœ,œDataœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-Ivr9p",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "operation",
            "id": "Prompt Template-z6g2K",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-Ivr9p{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Ivr9pœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-z6g2K{œfieldNameœ:œoperationœ,œidœ:œPrompt Template-z6g2Kœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-Ivr9p",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Ivr9pœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-z6g2K",
        "targetHandle": "{œfieldNameœ:œoperationœ,œidœ:œPrompt Template-z6g2Kœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-Ivr9p",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "config_key",
            "id": "Prompt Template-z6g2K",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-Ivr9p{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Ivr9pœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-z6g2K{œfieldNameœ:œconfig_keyœ,œidœ:œPrompt Template-z6g2Kœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-Ivr9p",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Ivr9pœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-z6g2K",
        "targetHandle": "{œfieldNameœ:œconfig_keyœ,œidœ:œPrompt Template-z6g2Kœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ParserComponent",
            "id": "ParserComponent-Ivr9p",
            "name": "parsed_text",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "parameters",
            "id": "Prompt Template-z6g2K",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ParserComponent-Ivr9p{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Ivr9pœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}-Prompt Template-z6g2K{œfieldNameœ:œparametersœ,œidœ:œPrompt Template-z6g2Kœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ParserComponent-Ivr9p",
        "sourceHandle": "{œdataTypeœ:œParserComponentœ,œidœ:œParserComponent-Ivr9pœ,œnameœ:œparsed_textœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Prompt Template-z6g2K",
        "targetHandle": "{œfieldNameœ:œparametersœ,œidœ:œPrompt Template-z6g2Kœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "Prompt Template-z6g2K",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": [
                "operation",
                "domain",
                "domains",
                "location_path",
                "locations",
                "parameters",
                "location_parameters",
                "server_block_parameters",
                "kms_mentioned",
                "kms_locations",
                "public_locations",
                "kms_required",
                "preserve_directives",
                "conditional_add",
                "config_key",
                "block_type",
                "current_directives",
                "hash",
                "warnings",
                "path"
              ]
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "braces",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "block_type": {
                "advanced": false,
                "display_name": "block_type",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "block_type",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"braces\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "conditional_add": {
                "advanced": false,
                "display_name": "conditional_add",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "conditional_add",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "config_key": {
                "advanced": false,
                "display_name": "config_key",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "config_key",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "current_directives": {
                "advanced": false,
                "display_name": "current_directives",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "current_directives",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "domain": {
                "advanced": false,
                "display_name": "domain",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "domain",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "domains": {
                "advanced": false,
                "display_name": "domains",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "domains",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "hash": {
                "advanced": false,
                "display_name": "hash",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "hash",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "kms_locations": {
                "advanced": false,
                "display_name": "kms_locations",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "kms_locations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "kms_mentioned": {
                "advanced": false,
                "display_name": "kms_mentioned",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "kms_mentioned",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "kms_required": {
                "advanced": false,
                "display_name": "kms_required",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "kms_required",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "location_parameters": {
                "advanced": false,
                "display_name": "location_parameters",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "location_parameters",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "location_path": {
                "advanced": false,
                "display_name": "location_path",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "location_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "locations": {
                "advanced": false,
                "display_name": "locations",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "locations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "operation": {
                "advanced": false,
                "display_name": "operation",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "operation",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "parameters": {
                "advanced": false,
                "display_name": "parameters",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "parameters",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "path": {
                "advanced": false,
                "display_name": "path",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "preserve_directives": {
                "advanced": false,
                "display_name": "preserve_directives",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "preserve_directives",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "public_locations": {
                "advanced": false,
                "display_name": "public_locations",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "public_locations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "server_block_parameters": {
                "advanced": false,
                "display_name": "server_block_parameters",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "server_block_parameters",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "## NGINX YAML Configuration Agent v4.5 (Enhanced Processor with Strict Parameter Adherence)\n\nYou are an nginx YAML configuration expert that modifies EXISTING YAML configuration files based on validated user requests. \n**CRITICAL**: You work with EXISTING configurations only. You do NOT create new config files. \n**CRITICAL**: You must preserve original spacing, ordering, and formatting of all existing directives. Do not reorder, reformat, or comment out lines.\n**CRITICAL**: Do NOT add any extra parameters, headers, or directives (e.g., standard proxy_set_header like Host, X-Real-IP, etc.) unless they are explicitly provided in the parameters, location_parameters, server_block_parameters, or default KMS lists. Only use what is given in the input—do not assume or add \"standard\" configurations.\n\n---\n\n## MULTI-PROMPT PROCESSING\n**CRITICAL**: When you receive input with a `prompts` array containing multiple prompts:\n1. **Process EACH prompt in the array independently**\n2. **Return a JSON array of results**, one result per prompt\n3. **Each result must follow the standard OUTPUT FORMAT**\n4. **Do NOT merge or combine prompts** - treat each as a separate task\n\n**Multi-Prompt INPUT FORMAT:**\n\n{{\n  \"prompts\": [\n    {{,\n      \"index\": 0,\n      \"location\": \"/api_v1\",\n      \"prompt\": \"**INPUT:**\\n- Operation: CREATE_LOCATION\\n- Location: /api_v1\\n...\"\n    }},\n    {{\n      \"index\": 1,\n      \"location\": \"/api_v2\",\n      \"prompt\": \"**INPUT:**\\n- Operation: CREATE_LOCATION\\n- Location: /api_v2\\n...\"\n    }}\n  ]\n}}\n\n\n**Multi-Prompt OUTPUT FORMAT:**\n```json\n{{\n  \"status\": \"success\",\n  \"total_processed\": 2,\n  \"results\": [\n    {{\n      \"status\": \"success\",\n      \"operation_type\": \"CREATE_LOCATION\",\n      \"config_key\": \"aip.mos.ru_9443\",\n      \"location_path\": \"/api_v1\",\n      \"updated_directives\": [...],\n      \"changes_made\": [...],\n      \"explanation\": \"...\",\n      \"ready_to_save\": true,\n      \"warnings\": [...]\n    }},\n    {{\n      \"status\": \"success\",\n      \"operation_type\": \"CREATE_LOCATION\",\n      \"config_key\": \"aip.mos.ru_9443\",\n      \"location_path\": \"/api_v2\",\n      \"updated_directives\": [...],\n      \"changes_made\": [...],\n      \"explanation\": \"...\",\n      \"ready_to_save\": true,\n      \"warnings\": [...]\n\n    }}\n  ]\n}}\n```\n\n**PROCESSING ALGORITHM:**\n1. Check if input contains a `prompts` array\n2. If YES:\n   - FOR EACH prompt in prompts array:\n     - Extract the prompt text\n     - Parse the **INPUT:** section\n     - Process according to operation rules\n     - Generate individual result\n   - Return array of all results in `results` field\n3. If NO (single prompt):\n   - Process normally as before\n   - Return single result object\n**CRITICAL**: You MUST process ALL prompts in the array. Do not stop after the first one!\n\n---\n\n## PREREQUISITES CHECK\n**ALWAYS check status field first:**\nIf \"status\": \"error\" OR \"status\": \"not_found\":\n\n{{\n  \"status\": \"error\",\n  \"operation_type\": \"NONE\",\n  \"error_type\": \"PREREQUISITE_ERROR\",\n  \"error_message\": \"Cannot process: \",\n  \"config_file\": null,\n  \"config_key\": null,\n  \"explanation\": \"Операция не может быть выполнена из-за ошибки на предыдущем этапе.\",\n  \"warnings\": [\"Config search failed\"],\n  \"ready_to_save\": false\n}}\n\n**Only proceed if \"status\": \"success\"**\n\n---\n\n## INPUTS\n1. **AGENT 1 OUTPUT**: operation={operation}, domain={domain}, domains={domains}, location={location_path}, locations={locations}, parameters={parameters}, location_parameters={location_parameters}, server_block_parameters={server_block_parameters}, kms_mentioned={kms_mentioned}, kms_locations={kms_locations}, public_locations={public_locations}, kms_required={kms_required}, preserve_directives={preserve_directives}, conditional_add={conditional_add}\n2. **AGENT 2 OUTPUT**: config_key, config_file, current_directives, hash\n3. **TARGET CONFIG BLOCK**:\n   - Config Key: {config_key}\n   - Location Path: {location_path}\n   - Type: {block_type} (location_block or server_block)\n   - Current Directives: {current_directives}\n   - Hash: {hash}\n4. **OPERATION CONTEXT**:\n   - Operation: {operation}\n   - Parameters to Process: {parameters}\n   - Location Parameters: {location_parameters}\n   - Server Block Parameters: {server_block_parameters}\n   - Domain: {domain}\n   - Domains: {domains}\n   - Conditional Add: {conditional_add}\n   - KMS Required: {kms_required}\n   - KMS Mentioned: {kms_mentioned}\n   - Preserve Directives: {preserve_directives}\n   - warnings: {warnings}\n\n---\n\n## DATA FORMAT\n**Current Directives Format:**\n- Array of strings: {current_directives}\n- Each directive ends with \";\"\n- Location blocks are already parsed into directives (nested blocks converted to flat directives where possible)\n\n**Parameters Format:**\n- Array of strings: {parameters}\n- Parameters **MUST NOT include** trailing semicolons (`;`) — you **MUST append `;`** before comparison or insertion.\n- Example: Input: `proxy_buffer_size 32k` → Use as: `proxy_buffer_size 32k;`\n\n---\n\n## OPERATIONS (EXPANDED)\n| Operation                | Description | Scope | Behavior | Example |\n|--------------------------|-------------|-------|----------|---------|\n| **ADD_PARAMETERS**       | Add parameter **only if it does NOT exist at all** (by directive name) | location_block or server_block | Skip if exists, add if missing | `proxy_buffer_size 32k;` — if absent |\n| **MODIFY_PARAMETERS**    | Ensure parameter is set to target value: **replace if exists with different value**, **add if absent** | location_block or server_block | Change value OR add if missing | Change `proxy_buffer_size 16k;` → `32k;` or add if missing |\n| **DELETE_PARAMETERS**    | Remove parameter **by exact full string match** | location_block or server_block | Remove matching directives | Remove `proxy_buffer_size 16k;` |\n| **DELETE_LOCATION**      | Remove entire location block | location_block | Complete removal of location and all its directives | Removes `/api` block entirely |\n| **CREATE_LOCATION**      | Create new location block with parameters | location_block | Add new location with initial directives. Do NOT add any extra directives like proxy_set_header unless explicitly in parameters. | Create `/api_v1` with provided parameters |\n| **MODIFY_LOCATION_PATH** | Rename location path | location_block | Change path, preserve all directives | /relay → /relay/ | proxy_pass http://{{upstream_name}}; → proxy_pass http://upstream_name/; |\n| **MAKE_PROTECTED**       | Protect location with KMS parameters (add if absent or modify) | location_block | Use MODIFY_PARAMETERS with provided params or default KMS params if empty | Add default: allow 10.15.166.0/25; etc., deny all; |\n| **MAKE_PUBLIC**          | Make location public by removing KMS parameters | location_block | Use DELETE_KMS_PARAMETERS | Remove allow/deny etc. |\n\n---\n\n## CRITICAL RULES FOR PARAMETER HANDLING\n1. **Parameter matching is based on the directive NAME (first word before whitespace)**, not the full line.\n   - Example: `proxy_buffer_size 16k;` → name = `proxy_buffer_size`\n   - `proxy_buffer_size 32k;` → same name, different value → for MODIFY, replace; for ADD, skip if name exists\n2. **String matching is case-sensitive.**\n   - `128K` ≠ `128k` ≠ `128 K` — treat as different values.\n3. **For MODIFY_PARAMETERS:**\n   - If parameter exists with different value → REPLACE\n   - If exists with identical value → SKIP\n   - If not exists → ADD\n4. **Always append `;` to each parameter from `parameters`, `location_parameters`, or `server_block_parameters` before processing.**\n5. **Block Type Handling:**\n   - If block_type = \"server_block\" (location=null), apply to server-level directives.\n   - If block_type = \"location_block\", apply to location directives.\n6. **Multiple Domains/Locations:**\n   - If domains or locations array provided, but input is single prompt, return error: \"Multi-entity requires multi-prompt input.\"\n   - Assume single domain/location per prompt; system handles multiples via multi-prompt.\n7. **Conditional Add:** If conditional_add=true, use ADD_PARAMETERS logic (skip if exists, even if value differs).\n8. **Preserve Directives:** If preserve_directives=false, clear existing and add new (rare, warn in explanation).\n9. **No Extra Additions:** Strictly adhere to input parameters. Do not add \"standard\" proxy headers (e.g., Host $host, X-Real-IP, etc.) or any other directives unless explicitly listed in the input parameters. If parameters are empty, do not add anything extra.\n\n---\n\n## KMS HANDLING\n- **Default KMS Parameters (auto-generated if parameters empty for MAKE_PROTECTED):**\n  - Based on common examples: [\"allow 10.0.0.0/8/18;\", \"deny all;\"]\n  - If kms_required=true and parameters empty, use these defaults with MODIFY_PARAMETERS logic.\n  - If parameters provided, use them instead. Do not add extra beyond what's specified.\n- **Implicit KMS Parameters for Deletion (MAKE_PUBLIC or DELETE_KMS_PARAMETERS):**\n  - [\"allow\", \"deny\", \"auth_request\", \"satisfy\", \"limit_except\"]\n  - Remove any directives starting with these names.\n- If kms_mentioned=true but no kms_required, note in warnings: \"KMS mentioned but no action specified.\"\n\n---\n\n  \n### STEP-BY-STEP ANALYSIS (MANDATORY)\nBefore processing:\n1. Identify block_type and operation.\n2. If kms_required and operation in [\"CREATE_LOCATION\", \"MAKE_PROTECTED\", \"ADD_PARAMETERS\"], apply KMS logic only if parameters are provided or use defaults strictly.\n3. Append \";\" to all parameters.\n4. Process directives, preserving order.\n5. Compute changes_made.\n6. If changes_made empty, ready_to_save=false.\n7. Update hash if changed (simple md5 of joined directives).\n\n### For ADD_PARAMETERS (and CONDITIONAL_ADD_PARAMETERS):\n- Same as before, but:\n  - If block_type=\"server_block\", use server_block_parameters if provided, else parameters.\n  - If kms_required, add default KMS after user params only if explicitly required and parameters empty.\n\n### For MODIFY_PARAMETERS:\n- Same as before.\n- Handle server_block_parameters separately if block_type=\"server_block\".\n\n### For DELETE_PARAMETERS:\n- Same as before.\n\n### For DELETE_KMS_PARAMETERS (or MAKE_PUBLIC):\n- Use implicit KMS parameters if parameters empty.\n- Remove by name (first word match).\n\n### For DELETE_LOCATION:\n- Same as before.\n\n### For CREATE_LOCATION:\n**Processing steps:**\n- Generate upstream_name as \"{{domain_converted}}_{{location_converted}}\" (replace '.' with '_', remove leading '/', replace '/' with '_').\n- Always add \"    proxy_pass http://upstream_name/;\" as the first indented directive (4 spaces).\n- If kms_required and parameters empty, add default KMS params after proxy_pass.\n- Then, add the explicitly provided parameters as additional indented directives (each with 4 space indent).\n- Do not add any other \"standard\" proxy headers or extras unless in parameters.\n- Include \"upstreams\" in output JSON: array of upstream definitions (e.g., servers from main and backup IPs).\n\n**MANDATORY RULES:**\n1. First line MUST be: \"location {location_path} {{\"\n2. All directives MUST be indented with exactly 4 spaces\n3. Last line MUST be: \"}}\"\n4. **NEVER return bare parameters without location wrapper**\n\n**Example - CORRECT:**\n```json\n\"updated_directives\": [\n  \"location /vcs/api_V2/ {{ proxy_pass http://upstream_name/; proxy_buffer_size 32k; proxy_buffers 4 32k; large_client_header_buffers 4 32k; }}\"\n]\n```\n\n**Example - WRONG (DO NOT DO THIS):**\n```json\n\"updated_directives\": [\n  \"proxy_buffer_size 32k;\",\n  \"proxy_buffers 4 32k;\"\n]\n```\n\n**Processing steps:**\n- If kms_required and parameters empty, add default KMS params as indented directives\n- Add only the explicitly provided parameters as indented directives (each with 4 space indent)\n- Do not add any \"standard\" proxy headers or other extras\n\n### For MAKE_PROTECTED:\n- Use MODIFY_PARAMETERS logic with parameters or default KMS if empty.\n\n### For MAKE_PUBLIC:\n- Use DELETE_KMS_PARAMETERS.\n\n---\n\n## 📤 OUTPUT FORMAT\nReturn ONLY valid JSON:\n\n{{\n  \"status\": \"success\",\n  \"operation_type\": \"{operation}\",\n  \"config_key\": \"{config_key}\",\n  \"location_path\": \"{location_path}\",\n  \"updated_directives\": [],\n  \"hash\": \"\",\n  \"changes_made\": [],\n  \"explanation\": \"\",\n  \"Warnings\": [...],\n  \"ready_to_save\": true\n}}\n\n---\n\n## EXPLANATION TEMPLATES\n- Updated to include KMS mentions.\n- E.g., for CREATE_LOCATION: \"Created new location /langtutor/ with specified parameters. No additional parameters added.\"\n- Avoid mentioning \"standard proxy headers\" or anything not explicitly added.\n\n---\n\n## VALIDATION CHECKLIST\n- Same as before, plus:\n- KMS applied correctly if required.\n- No extra directives added (e.g., no proxy_set_header unless in input).\n- No loss of directives.\n- **FOR CREATE_LOCATION: First element MUST be \"location {path} {{\", last MUST be \"}}\"**\n- **FOR CREATE_LOCATION: All directives between first and last MUST have 4 space indent**\n- **FOR CREATE_LOCATION: Never return bare parameters without location block wrapper**\n\n---\n\n## NOW PROCESS\n**INPUT:**\n- Operation: {operation}\n- Domain: {domain}\n- Location: {location_path}\n- Conditional Add: {conditional_add}\n- Current Directives: {current_directives}\n- Parameters: {parameters}\n- Location Parameters: {location_parameters}\n- Server Block Parameters: {server_block_parameters}\n- Config Key: {config_key}\n**RETURN**: Valid JSON response following OUTPUT FORMAT above."
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "warnings": {
                "advanced": false,
                "display_name": "warnings",
                "dynamic": false,
                "field_type": "str",
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "warnings",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-z6g2K",
        "measured": {
          "height": 1917,
          "width": 320
        },
        "position": {
          "x": 2463.416005310369,
          "y": 1307.617192142961
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LocationSelectorFromUniversalSearch-Arbrf",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Selects locations from universal search result for LLM processing (supports 1 or N locations)",
            "display_name": "Location Selector from Universal Search",
            "documentation": "",
            "edited": true,
            "field_order": [
              "universal_search_result",
              "source_field"
            ],
            "frozen": false,
            "icon": "filter",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "selected_block",
                "group_outputs": false,
                "hidden": null,
                "method": "build_selected_block",
                "name": "selected_block",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "operation_context",
                "group_outputs": false,
                "hidden": null,
                "method": "build_operation_context",
                "name": "operation_context",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "error_message",
                "group_outputs": false,
                "hidden": null,
                "method": "build_error_message",
                "name": "error_message",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import (\n    HandleInput,\n    MessageTextInput,\n)\nfrom langflow.schema.data import Data\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\nimport json\nimport hashlib\nimport yaml\nimport re\nfrom typing import Dict, Any, List, Optional, Tuple\n\n\nclass LocationSelectorFromUniversalSearch(Component):\n    \"\"\"\n    Selects a specific location or server block from universal search result.\n    Automatically extracts target location from agent1_data.location.\n    Processes ALL matching configurations from all_configs.\n    Special handling for operations:\n    - CREATE_LOCATION: Returns config info where location DOESN'T exist (to create new)\n    - DELETE_LOCATION: Returns config info where location DOES exist (to delete)\n    - MODIFY_LOCATION_PATH: Returns config info where OLD location exists (to rename/move)\n    - MODIFY/ADD: Returns config info where location exists (to modify)\n    - MAKE_PROTECTED: Returns config info where location exists (to make protected)\n    - MAKE_PUBLIC: Returns config info where location exists (to make public)\n    - Server operations: Always returns server block info\n    NEW: Handles both single location and multiple locations seamlessly!\n    NEW: Supports parameters, location_parameters, server_block_parameters\n    NEW: Supports multi-DC detection (found_in_multiple_dc, domain_dc_mapping, etc.)\n    \"\"\"\n    display_name = \"Location Selector from Universal Search\"\n    description = \"Selects locations from universal search result for LLM processing (supports 1 or N locations)\"\n    documentation = \"\"\n    icon = \"filter\"\n    inputs = [\n        HandleInput(\n            name=\"universal_search_result\",\n            display_name=\"Universal Search Result\",\n            input_types=[\"Data\", \"dict\"],\n            info=\"Output from Universal Search (contains agent1_data)\",\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"source_field\",\n            display_name=\"Source field\",\n            value=\"full_config_text\",\n            info=\"Field containing YAML config text (full_config_text or config_block)\",\n            required=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"selected_block\",\n            name=\"selected_block\",\n            info=\"Selected location/server blocks for all matching configs\",\n            method=\"build_selected_block\",\n        ),\n        Output(\n            display_name=\"operation_context\",\n            name=\"operation_context\",\n            info=\"Operation metadata from agent1_data\",\n            method=\"build_operation_context\",\n        ),\n        Output(\n            display_name=\"error_message\",\n            name=\"error_message\",\n            info=\"Error if location not found\",\n            method=\"build_error_message\",\n        ),\n    ]\n\n    def _get_search_result(self) -> Dict[str, Any]:\n        \"\"\"Extract universal search result.\"\"\"\n        input_data = self.universal_search_result\n        if isinstance(input_data, Data):\n            data = input_data.data\n        elif isinstance(input_data, dict):\n            data = input_data\n        else:\n            data = json.loads(str(input_data))\n        return data\n\n    def _extract_multi_dc_info(self, search_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        🆕 Extract multi-DC information from search result.\n        Returns dict with all multi-DC related fields.\n        \"\"\"\n        return {\n            \"found_in_multiple_dc\": search_result.get(\"found_in_multiple_dc\", False),\n            \"dc_count\": search_result.get(\"dc_count\", 0),\n            \"unique_dcs\": search_result.get(\"unique_dcs\", []),\n            \"domain_dc_mapping\": search_result.get(\"domain_dc_mapping\", {}),\n            \"domains_in_multiple_dc\": search_result.get(\"domains_in_multiple_dc\", []),\n        }\n\n    def _get_agent1_data(self, search_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Extract and normalize agent1_data from search result.\n        Handles ALL possible structures:\n        - agent1_data as list\n        - agent1_data as dict with 'payload'\n        - agent1_data as dict without 'payload'\n        - Multiple domains vs single domain\n        - Merges data from multiple payload items\n        \"\"\"\n        agent1_data_raw = search_result.get(\"agent1_data\", {})\n\n        # CASE 1: agent1_data is a list - take first element\n        if isinstance(agent1_data_raw, list):\n            if not agent1_data_raw:\n                return {}\n            first_item = agent1_data_raw[0]\n            # Check if this item also has payload\n            if isinstance(first_item, dict) and \"payload\" in first_item:\n                return self._extract_from_payload(first_item.get(\"payload\", []))\n            return first_item\n\n        # CASE 2: agent1_data is dict\n        if isinstance(agent1_data_raw, dict):\n            # Check if it has 'payload' key\n            if \"payload\" in agent1_data_raw:\n                payload = agent1_data_raw.get(\"payload\", [])\n                return self._extract_from_payload(payload)\n\n            # CASE 3: Direct dict without payload - return as is\n            return agent1_data_raw\n\n        return {}\n\n    def _extract_from_payload(self, payload: List[Dict]) -> Dict[str, Any]:\n        \"\"\"\n        Extract and merge data from payload array.\n        Handles both single and multiple items in payload.\n        \"\"\"\n        if not payload or not isinstance(payload, list):\n            return {}\n\n        # If single item - return it directly\n        if len(payload) == 1:\n            return payload[0]\n\n        # Multiple items - merge them intelligently\n        merged = {\n            \"operation\": None,\n            \"domain\": None,\n            \"domains\": [],\n            \"location\": None,\n            \"locations\": [],\n            \"from_location\": None,\n            \"to_location\": None,\n            \"new_location_path\": None,\n            \"preserve_directives\": True,\n            \"parameters\": [],\n            \"location_parameters\": [],\n            \"server_block_parameters\": [],\n            \"ip_addresses\": [],\n            \"upstreams\": [],\n            \"kms_required\": False,\n            \"kms_mentioned\": False,\n            \"kms_locations\": [],\n            \"public_locations\": [],\n            \"selected_dc\": [],\n            \"data_complete\": True,\n            \"confidence\": 0.0,\n            \"warnings\": [],\n            \"ambiguities\": []\n        }\n\n        for item in payload:\n            if not isinstance(item, dict):\n                continue\n\n            # Operation - take from first item\n            if not merged[\"operation\"] and item.get(\"operation\"):\n                merged[\"operation\"] = item[\"operation\"]\n\n            # Domains - collect all\n            if item.get(\"domain\"):\n                merged[\"domains\"].append(item[\"domain\"])\n                if not merged[\"domain\"]:  # Set first domain as primary\n                    merged[\"domain\"] = item[\"domain\"]\n\n            if item.get(\"domains\"):\n                if isinstance(item[\"domains\"], list):\n                    merged[\"domains\"].extend(item[\"domains\"])\n                else:\n                    merged[\"domains\"].append(item[\"domains\"])\n\n            # Locations - collect all\n            if item.get(\"location\"):\n                merged[\"locations\"].append(item[\"location\"])\n                if not merged[\"location\"]:  # Set first location as primary\n                    merged[\"location\"] = item[\"location\"]\n\n            if item.get(\"locations\"):\n                if isinstance(item[\"locations\"], list):\n                    merged[\"locations\"].extend(item[\"locations\"])\n                else:\n                    merged[\"locations\"].append(item[\"locations\"])\n\n            # Location parameters - collect all\n            if item.get(\"location_parameters\"):\n                if isinstance(item[\"location_parameters\"], list):\n                    merged[\"location_parameters\"].extend(item[\"location_parameters\"])\n                else:\n                    merged[\"location_parameters\"].append(item[\"location_parameters\"])\n\n            # Server block parameters - collect all (deduplicate later)\n            if item.get(\"server_block_parameters\"):\n                if isinstance(item[\"server_block_parameters\"], list):\n                    merged[\"server_block_parameters\"].extend(item[\"server_block_parameters\"])\n                else:\n                    merged[\"server_block_parameters\"].append(item[\"server_block_parameters\"])\n\n            # General parameters - collect all\n            if item.get(\"parameters\"):\n                if isinstance(item[\"parameters\"], list):\n                    merged[\"parameters\"].extend(item[\"parameters\"])\n                else:\n                    merged[\"parameters\"].append(item[\"parameters\"])\n\n            # IP addresses - collect all\n            if item.get(\"ip_addresses\"):\n                if isinstance(item[\"ip_addresses\"], list):\n                    merged[\"ip_addresses\"].extend(item[\"ip_addresses\"])\n                else:\n                    merged[\"ip_addresses\"].append(item[\"ip_addresses\"])\n\n            # Upstreams - collect all\n            if item.get(\"upstreams\"):\n                if isinstance(item[\"upstreams\"], list):\n                    merged[\"upstreams\"].extend(item[\"upstreams\"])\n                elif item[\"upstreams\"]:  # Not None\n                    merged[\"upstreams\"].append(item[\"upstreams\"])\n\n            # Selected DC - collect all\n            if item.get(\"selected_dc\"):\n                if isinstance(item[\"selected_dc\"], list):\n                    merged[\"selected_dc\"].extend(item[\"selected_dc\"])\n                else:\n                    merged[\"selected_dc\"].append(item[\"selected_dc\"])\n\n            # KMS locations - collect all\n            if item.get(\"kms_locations\"):\n                if isinstance(item[\"kms_locations\"], list):\n                    merged[\"kms_locations\"].extend(item[\"kms_locations\"])\n                else:\n                    merged[\"kms_locations\"].append(item[\"kms_locations\"])\n\n            # Public locations - collect all\n            if item.get(\"public_locations\"):\n                if isinstance(item[\"public_locations\"], list):\n                    merged[\"public_locations\"].extend(item[\"public_locations\"])\n                else:\n                    merged[\"public_locations\"].append(item[\"public_locations\"])\n\n            # Boolean flags - OR logic (if any item has True, result is True)\n            if item.get(\"kms_required\"):\n                merged[\"kms_required\"] = True\n\n            if item.get(\"kms_mentioned\"):\n                merged[\"kms_mentioned\"] = True\n\n            # Preserve directives - AND logic (all must be True)\n            if item.get(\"preserve_directives\") is False:\n                merged[\"preserve_directives\"] = False\n\n            # Path modification fields - take from first non-empty\n            if not merged[\"from_location\"] and item.get(\"from_location\"):\n                merged[\"from_location\"] = item[\"from_location\"]\n\n            if not merged[\"to_location\"] and item.get(\"to_location\"):\n                merged[\"to_location\"] = item[\"to_location\"]\n\n            if not merged[\"new_location_path\"] and item.get(\"new_location_path\"):\n                merged[\"new_location_path\"] = item[\"new_location_path\"]\n\n            # Data completeness - AND logic\n            if item.get(\"data_complete\") is False:\n                merged[\"data_complete\"] = False\n\n            # Confidence - take maximum\n            item_confidence = item.get(\"confidence\", 0.0)\n            if item_confidence > merged[\"confidence\"]:\n                merged[\"confidence\"] = item_confidence\n\n            # Warnings and ambiguities - collect all\n            if item.get(\"warnings\"):\n                if isinstance(item[\"warnings\"], list):\n                    merged[\"warnings\"].extend(item[\"warnings\"])\n                else:\n                    merged[\"warnings\"].append(item[\"warnings\"])\n\n            if item.get(\"ambiguities\"):\n                if isinstance(item[\"ambiguities\"], list):\n                    merged[\"ambiguities\"].extend(item[\"ambiguities\"])\n                else:\n                    merged[\"ambiguities\"].append(item[\"ambiguities\"])\n\n        # Deduplicate lists\n        merged[\"domains\"] = list(dict.fromkeys(merged[\"domains\"]))  # Preserve order\n        merged[\"locations\"] = list(dict.fromkeys(merged[\"locations\"]))\n        merged[\"server_block_parameters\"] = list(dict.fromkeys(merged[\"server_block_parameters\"]))\n        merged[\"parameters\"] = list(dict.fromkeys(merged[\"parameters\"]))\n        merged[\"ip_addresses\"] = list(dict.fromkeys(merged[\"ip_addresses\"]))\n        merged[\"selected_dc\"] = list(dict.fromkeys(merged[\"selected_dc\"]))\n        merged[\"kms_locations\"] = list(dict.fromkeys(merged[\"kms_locations\"]))\n        merged[\"public_locations\"] = list(dict.fromkeys(merged[\"public_locations\"]))\n\n        # Clean up empty lists to None where appropriate\n        if not merged[\"domains\"]:\n            merged[\"domains\"] = []\n        if not merged[\"locations\"]:\n            merged[\"locations\"] = []\n        if not merged[\"upstreams\"]:\n            merged[\"upstreams\"] = []\n\n        return merged\n\n    def _normalize_location_parameters(self, agent1_data: Dict[str, Any]) -> List[Dict]:\n        \"\"\"\n        Normalize location_parameters regardless of input format.\n        Handles: single location, multiple locations, location_parameters array.\n        Returns list of dicts, each with: location, parameters, kms_required, ip_addresses, upstreams, new_location_path\n        \"\"\"\n        location_parameters = agent1_data.get(\"location_parameters\", [])\n        locations_list = agent1_data.get(\"locations\", [])\n        single_location = agent1_data.get(\"location\")\n        ip_addresses = agent1_data.get(\"ip_addresses\", [])\n        upstreams = agent1_data.get(\"upstreams\", [])\n        parameters = agent1_data.get(\"parameters\", [])\n        kms_required = agent1_data.get(\"kms_required\", False)\n        server_block_parameters = agent1_data.get(\"server_block_parameters\", [])\n        selected_dc = agent1_data.get(\"selected_dc\", [])\n        # NEW: Support both naming conventions for path modification\n        new_location_path = agent1_data.get(\"new_location_path\") or agent1_data.get(\"to_location\")\n        from_location = agent1_data.get(\"from_location\")\n        # If from_location is specified, use it as the primary location\n        if from_location:\n            single_location = from_location\n        # CASE 1: location_parameters уже заполнена (приоритет)\n        if location_parameters and isinstance(location_parameters, list):\n            normalized = []\n            for loc_param in location_parameters:\n                if isinstance(loc_param, dict) and loc_param.get(\"location\"):\n                    # Support both naming conventions\n                    param_new_path = (loc_param.get(\"new_location_path\") or\n                                      loc_param.get(\"to_location\") or\n                                      new_location_path)\n                    norm_param = {\n                        \"location\": loc_param.get(\"location\") or loc_param.get(\"from_location\"),\n                        \"parameters\": loc_param.get(\"parameters\", parameters),\n                        \"kms_required\": loc_param.get(\"kms_required\", kms_required),\n                        \"ip_addresses\": loc_param.get(\"ip_addresses\", ip_addresses),\n                        \"upstreams\": loc_param.get(\"upstreams\", upstreams),\n                        \"server_block_parameters\": loc_param.get(\"server_block_parameters\", server_block_parameters),\n                        \"new_location_path\": param_new_path,\n                        \"selected_dc\": loc_param.get(\"selected_dc\", selected_dc),\n                    }\n                    normalized.append(norm_param)\n            if normalized:\n                return normalized\n        # CASE 2: Множественные locations в поле \"locations\"\n        if locations_list and isinstance(locations_list, list):\n            return [\n                {\n                    \"location\": loc,\n                    \"parameters\": parameters,\n                    \"kms_required\": kms_required,\n                    \"ip_addresses\": ip_addresses,\n                    \"upstreams\": upstreams,\n                    \"server_block_parameters\": server_block_parameters,\n                    \"new_location_path\": new_location_path,\n                    \"selected_dc\": selected_dc,\n                }\n                for loc in locations_list\n                if loc  # Исключить пустые\n            ]\n        # CASE 3: Одна location\n        if single_location:\n            return [\n                {\n                    \"location\": single_location,\n                    \"parameters\": parameters,\n                    \"kms_required\": kms_required,\n                    \"ip_addresses\": ip_addresses,\n                    \"upstreams\": upstreams,\n                    \"server_block_parameters\": server_block_parameters,\n                    \"new_location_path\": new_location_path,\n                    \"selected_dc\": selected_dc,\n                }\n            ]\n        # CASE 4: Ничего не найдено\n        return []\n\n    def _parse_yaml_config(self, config_text: str) -> Tuple[str, List[str], List[Dict]]:\n        \"\"\"\n        Parse YAML config and extract server directives and locations.\n        Returns: (config_key, server_directives, locations)\n        \"\"\"\n        parsed_data = yaml.safe_load(config_text)\n        if isinstance(parsed_data, list):  # Handle top-level list YAML\n            key = \"default_config\"\n            items = parsed_data\n        elif isinstance(parsed_data, dict) and parsed_data:\n            key = list(parsed_data.keys())[0]\n            items = parsed_data[key]\n        else:\n            raise ValueError(\"Invalid YAML structure: must be dict or list\")\n        if not isinstance(items, list):\n            items = [items]  # Ensure items is always a list\n        server_directives = []\n        locations = []\n        for item in items:\n            item_str = str(item).strip()\n            if item_str.startswith(\"location \"):\n                # Parse location: location /path { ... }\n                match = re.match(r\"location\\s+([^{]+)\\s*{(.*)}\", item_str, re.DOTALL)\n                if match:\n                    path = match.group(1).strip()\n                    content = match.group(2).strip().rstrip(\"};\")\n                    directives = [d.strip().rstrip(\";\").strip() + \";\"\n                                  for d in content.split(\";\") if d.strip()]\n                    # Calculate hash\n                    content_str = f\"{path}:{content}\"\n                    loc_hash = hashlib.sha1(content_str.encode(\"utf-8\", errors=\"ignore\")).hexdigest()\n                    locations.append({\n                        \"path\": path,\n                        \"directives\": directives,\n                        \"hash\": loc_hash\n                    })\n                else:\n                    # Fallback to server directive\n                    cleaned = item_str.rstrip(\";\").strip()\n                    if not item_str.endswith(\";\"):\n                        cleaned += \";\"\n                    server_directives.append(cleaned)\n            elif item_str.startswith(\"- \"):\n                directive = item_str.lstrip(\"- \").rstrip(\";\").strip()\n                if not item_str.lstrip(\"- \").endswith(\";\"):\n                    directive += \";\"\n                server_directives.append(directive)\n            else:\n                directive = item_str.rstrip(\";\").strip()\n                if not item_str.endswith(\";\"):\n                    directive += \";\"\n                server_directives.append(directive)\n        return key, server_directives, locations\n\n    def _find_location(self, locations: List[Dict], target_location: str) -> Optional[Dict]:\n        \"\"\"Find location block by path with normalization.\"\"\"\n        normalized_target = target_location\n        if target_location != \"/\" and not target_location.endswith(\"/\"):\n            normalized_target = target_location + \"/\"\n        # Try normalized match\n        for loc in locations:\n            path = loc.get(\"path\", \"\")\n            normalized_path = path\n            if path != \"/\" and not path.endswith(\"/\"):\n                normalized_path = path + \"/\"\n            if normalized_path == normalized_target or path == target_location:\n                return loc\n        # Try exact match (for modifiers like \"= /path\")\n        for loc in locations:\n            if loc.get(\"path\") == target_location:\n                return loc\n        return None\n\n    def build_selected_block(self) -> Message:\n        \"\"\"\n        Select the target blocks based on agent1_data from ALL matching configs.\n        Handles both single and multiple locations.\n        🆕 Now includes multi-DC information.\n        \"\"\"\n        try:\n            search_result = self._get_search_result()\n\n            # 🆕 Extract multi-DC info\n            multi_dc_info = self._extract_multi_dc_info(search_result)\n            # Extract agent1_data using universal method\n            agent1_data = self._get_agent1_data(search_result)\n\n\n            operation = search_result.get(\"operation\", agent1_data.get(\"operation\", \"ADD_PARAMETERS\"))\n            target_domains = search_result.get(\"domains\", agent1_data.get(\"domains\", []))\n            # 🔥 НОВОЕ: Нормализовать location_parameters - работает для 1 или N locations\n            location_parameters = self._normalize_location_parameters(agent1_data)\n            source_field = getattr(self, 'source_field', 'full_config_text')\n            all_configs = search_result.get(\"all_configs\", [])\n            if not all_configs:\n                return Message(text=json.dumps({\n                    \"error\": \"No configs found in all_configs\",\n                    \"selected_blocks\": [],\n                    **multi_dc_info  # 🆕 Include multi-DC info even in error\n                }, ensure_ascii=False))\n            selected_blocks = []\n            errors = []\n            # OPERATION-SPECIFIC LOGIC\n            is_create_operation = operation == \"CREATE_LOCATION\"\n            is_delete_operation = operation == \"DELETE_LOCATION\"\n            is_modify_path_operation = operation == \"MODIFY_LOCATION_PATH\"  # NEW\n            requires_existing_location = is_delete_operation or operation in [\n                \"MODIFY_PARAMETERS\",\n                \"ADD_PARAMETERS\",\n                \"CONDITIONAL_ADD_PARAMETERS\",\n                \"DELETE_PARAMETERS\",\n                \"DELETE_KMS_PARAMETERS\",\n                \"MODIFY_UPSTREAM\",\n                \"MODIFY_LOCATION_PATH\",  # NEW - requires existing location\n                \"MAKE_PROTECTED\",  # Added support\n                \"MAKE_PUBLIC\"  # Added support\n            ]\n            # PROCESS ALL CONFIGURATIONS\n            for config in all_configs:\n                if not isinstance(config, dict):  # Safeguard against non-dict configs\n                    errors.append(f\"Invalid config type in all_configs: {type(config)} - skipping\")\n                    continue\n                # Check if config matches target domains\n                matching_domains = config.get(\"matching_domains\", [])\n                server_names = config.get(\"server_names\", [])\n\n                # 🆕 Get inferred_dc for this config\n                config_inferred_dc = config.get(\"inferred_dc\", [])\n\n                # Skip configs that don't match any target domain\n                if target_domains:\n                    if not any(domain in target_domains for domain in matching_domains):\n                        if not any(domain in target_domains for domain in server_names):\n                            continue\n                config_text = config.get(source_field)\n                if not config_text:\n                    errors.append(f\"No {source_field} in config {config.get('config_key', 'unknown')}\")\n                    continue\n                try:\n                    key, server_directives, locations = self._parse_yaml_config(config_text)\n                    # SERVER BLOCK (no specific locations = work with server block)\n                    if not location_parameters:\n                        server_str = \";\".join(server_directives)\n                        server_hash = hashlib.sha1(server_str.encode(\"utf-8\", errors=\"ignore\")).hexdigest()\n                        selected_blocks.append({\n                            \"config_key\": key,\n                            \"config_file\": config.get(\"config_file\"),\n                            \"server_names\": server_names,\n                            \"matching_domains\": matching_domains,\n                            \"location_path\": \"server_block\",\n                            \"directives\": server_directives,\n                            \"hash\": server_hash,\n                            \"type\": \"server\",\n                            \"operation\": operation,\n                            \"parameters\": agent1_data.get(\"parameters\", []),\n                            \"server_block_parameters\": agent1_data.get(\"server_block_parameters\", []),\n                            \"selected_dc\": agent1_data.get(\"selected_dc\", []),\n                            \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                        })\n                    # LOCATION-SPECIFIC (process ALL locations - 1, 2, 3, N...)\n                    else:\n                        for loc_param in location_parameters:\n                            target_loc = loc_param.get(\"location\")\n                            if not target_loc:\n                                errors.append(\"Invalid location in location_parameters\")\n                                continue\n                            existing_location = self._find_location(locations, target_loc)\n                            # CREATE_LOCATION: location НЕ должна существовать\n                            if is_create_operation:\n                                if existing_location:\n                                    errors.append(\n                                        f\"Location '{target_loc}' already exists in {key}. \"\n                                        f\"Cannot create duplicate location.\"\n                                    )\n                                else:\n                                    # Location doesn't exist - good for CREATE_LOCATION\n                                    selected_blocks.append({\n                                        \"config_key\": key,\n                                        \"config_file\": config.get(\"config_file\"),\n                                        \"server_names\": server_names,\n                                        \"matching_domains\": matching_domains,\n                                        \"location_path\": target_loc,\n                                        \"directives\": [],  # Empty - will be populated by LLM\n                                        \"hash\": None,\n                                        \"type\": \"location\",\n                                        \"operation\": operation,\n                                        \"existing_locations\": [loc.get(\"path\") for loc in locations],\n                                        \"create_mode\": True,\n                                        \"parameters\": loc_param.get(\"parameters\", []),\n                                        \"kms_required\": loc_param.get(\"kms_required\", False),\n                                        \"ip_addresses\": loc_param.get(\"ip_addresses\", []),\n                                        \"upstreams\": loc_param.get(\"upstreams\", []),\n                                        \"server_block_parameters\": loc_param.get(\"server_block_parameters\", []),\n                                        \"selected_dc\": loc_param.get(\"selected_dc\", []),\n                                        \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                                    })\n                            # DELETE_LOCATION: location ДОЛЖНА существовать\n                            elif is_delete_operation:\n                                if existing_location:\n                                    selected_blocks.append({\n                                        \"config_key\": key,\n                                        \"config_file\": config.get(\"config_file\"),\n                                        \"server_names\": server_names,\n                                        \"matching_domains\": matching_domains,\n                                        \"location_path\": existing_location.get(\"path\"),\n                                        \"directives\": existing_location.get(\"directives\", []),\n                                        \"hash\": existing_location.get(\"hash\"),\n                                        \"type\": \"location\",\n                                        \"operation\": operation,\n                                        \"delete_mode\": True,\n                                        \"selected_dc\": loc_param.get(\"selected_dc\", []),\n                                        \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                                    })\n                                else:\n                                    errors.append(\n                                        f\"Location '{target_loc}' not found in {key}. \"\n                                        f\"Cannot delete non-existent location. \"\n                                        f\"Available: {[loc.get('path') for loc in locations]}\"\n                                    )\n                            # MODIFY/ADD/MODIFY_LOCATION_PATH/MAKE_PROTECTED/MAKE_PUBLIC: location ДОЛЖНА существовать\n                            elif requires_existing_location:\n                                if existing_location:\n                                    block_data = {\n                                        \"config_key\": key,\n                                        \"config_file\": config.get(\"config_file\"),\n                                        \"server_names\": server_names,\n                                        \"matching_domains\": matching_domains,\n                                        \"location_path\": existing_location.get(\"path\"),\n                                        \"directives\": existing_location.get(\"directives\", []),\n                                        \"hash\": existing_location.get(\"hash\"),\n                                        \"type\": \"location\",\n                                        \"operation\": operation,\n                                        \"parameters\": loc_param.get(\"parameters\", []),\n                                        \"kms_required\": loc_param.get(\"kms_required\", False),\n                                        \"ip_addresses\": loc_param.get(\"ip_addresses\", []),\n                                        \"upstreams\": loc_param.get(\"upstreams\", []),\n                                        \"server_block_parameters\": loc_param.get(\"server_block_parameters\", []),\n                                        \"selected_dc\": loc_param.get(\"selected_dc\", []),\n                                        \"inferred_dc\": config_inferred_dc,  # 🆕 Add inferred DC\n                                    }\n                                    # NEW: Add new_location_path for MODIFY_LOCATION_PATH operation\n                                    if operation == \"MODIFY_LOCATION_PATH\":\n                                        new_path = loc_param.get(\"new_location_path\")\n                                        if new_path:\n                                            block_data[\"new_location_path\"] = new_path\n                                            block_data[\"existing_locations\"] = [loc.get(\"path\") for loc in locations]\n                                        else:\n                                            errors.append(\n                                                f\"MODIFY_LOCATION_PATH requires 'new_location_path' for '{target_loc}'\"\n                                            )\n                                            continue\n                                    selected_blocks.append(block_data)\n                                else:\n                                    errors.append(\n                                        f\"Location '{target_loc}' not found in {key}. \"\n                                        f\"Available: {[loc.get('path') for loc in locations]}\"\n                                    )\n                            else:\n                                # Fallback for unknown operations\n                                errors.append(f\"Unknown operation '{operation}' for location '{target_loc}'\")\n                except Exception as e:\n                    errors.append(f\"Error parsing config {config.get('config_key', 'unknown')}: {str(e)}\")\n                    continue\n            # Prepare result\n            result = {\n                \"selected_blocks\": selected_blocks,\n                \"total_configs_scanned\": len(all_configs),\n                \"total_blocks_found\": len(selected_blocks),\n                \"target_locations\": [lp.get(\"location\") for lp in location_parameters],\n                \"target_domains\": target_domains,\n                \"operation\": operation,\n                \"locations_count\": len(location_parameters),\n                \"parameters\": agent1_data.get(\"parameters\", []),\n                \"location_parameters\": location_parameters,\n                \"server_block_parameters\": agent1_data.get(\"server_block_parameters\", []),\n\n                # 🆕 Multi-DC information\n                **multi_dc_info,\n            }\n            if errors:\n                result[\"warnings\"] = errors\n            if not selected_blocks:\n                if is_create_operation:\n                    result[\"error\"] = (\n                        f\"Cannot create locations {[lp.get('location') for lp in location_parameters]} - \"\n                        f\"they may already exist or no valid configs found\"\n                    )\n                elif is_delete_operation:\n                    result[\"error\"] = (\n                        f\"Cannot delete locations - not found in configs\"\n                    )\n                else:\n                    result[\"error\"] = (\n                        f\"Locations not found in any of {len(all_configs)} configs\"\n                    )\n\n            # 🆕 Add multi-DC warning to result if applicable\n            if multi_dc_info[\"found_in_multiple_dc\"]:\n                if \"warnings\" not in result:\n                    result[\"warnings\"] = []\n                result[\"warnings\"].insert(0,\n                                          f\"⚠️ MULTI-DC: Domain found in {multi_dc_info['dc_count']} datacenters: \"\n                                          f\"{', '.join(multi_dc_info['unique_dcs'])}. \"\n                                          f\"Ensure changes are applied to all required locations!\"\n                                          )\n\n            return Message(text=json.dumps(result, ensure_ascii=False))\n        except Exception as e:\n            return Message(text=json.dumps({\n                \"error\": f\"Error in Location Selector: {str(e)}\",\n                \"selected_blocks\": []\n            }, ensure_ascii=False))\n\n    def build_operation_context(self) -> Message:\n        \"\"\"\n        Extract operation context from agent1_data.\n        🆕 Now includes multi-DC information.\n        \"\"\"\n        try:\n            search_result = self._get_search_result()\n\n            # 🆕 Extract multi-DC info\n            multi_dc_info = self._extract_multi_dc_info(search_result)\n            agent1_data = self._get_agent1_data(search_result)\n\n\n            # 🔥 НОВОЕ: Нормализовать\n            location_parameters = self._normalize_location_parameters(agent1_data)\n            all_configs = search_result.get(\"all_configs\", [])\n\n            operation_context = {\n                \"operation\": agent1_data.get(\"operation\"),\n                \"domain\": agent1_data.get(\"domain\"),\n                \"domains\": agent1_data.get(\"domains\", []),\n                \"location\": agent1_data.get(\"location\"),\n                \"locations\": agent1_data.get(\"locations\", []),\n                \"from_location\": agent1_data.get(\"from_location\"),  # NEW\n                \"to_location\": agent1_data.get(\"to_location\"),  # NEW\n                \"new_location_path\": agent1_data.get(\"new_location_path\"),\n                \"preserve_directives\": agent1_data.get(\"preserve_directives\"),  # NEW\n                \"parameters\": agent1_data.get(\"parameters\", []),\n                \"location_parameters\": location_parameters,  # Нормализованные\n                \"ip_addresses\": agent1_data.get(\"ip_addresses\", []),\n                \"upstreams\": agent1_data.get(\"upstreams\"),\n                \"server_block_parameters\": agent1_data.get(\"server_block_parameters\", []),\n                \"kms_required\": agent1_data.get(\"kms_required\"),\n                \"kms_mentioned\": agent1_data.get(\"kms_mentioned\"),\n                \"conditional_add\": agent1_data.get(\"conditional_add\"),\n                \"total_configs_found\": len(all_configs),\n                \"config_files\": [cfg.get(\"config_file\") for cfg in all_configs if isinstance(cfg, dict)],\n                \"config_keys\": [cfg.get(\"config_key\") for cfg in all_configs if isinstance(cfg, dict)],\n                \"locations_count\": len(location_parameters),\n                \"selected_dc\": agent1_data.get(\"selected_dc\", []),\n\n                # 🆕 Multi-DC information\n                **multi_dc_info,\n            }\n            return Message(text=json.dumps(operation_context, ensure_ascii=False))\n        except Exception as e:\n            return Message(text=json.dumps({\n                \"error\": f\"Error extracting operation context: {str(e)}\"\n            }, ensure_ascii=False))\n\n    def build_error_message(self) -> Message:\n        \"\"\"\n        Return error message if any issues occur.\n        🆕 Now includes multi-DC information.\n        \"\"\"\n        try:\n            search_result = self._get_search_result()\n\n            # 🆕 Extract multi-DC info\n            multi_dc_info = self._extract_multi_dc_info(search_result)\n\n            if search_result.get(\"status\") == \"error\":\n                return Message(text=json.dumps({\n                    \"error\": f\"Search error: {search_result.get('error_message')}\",\n                    \"block_exists\": False,\n                    **multi_dc_info  # 🆕 Include multi-DC info\n                }, ensure_ascii=False))\n            agent1_data = self._get_agent1_data(search_result)\n\n            # 🔥 НОВОЕ: Нормализовать\n            location_parameters = self._normalize_location_parameters(agent1_data)\n            operation = agent1_data.get(\"operation\", \"ADD_PARAMETERS\")\n            target_domains = agent1_data.get(\"domains\", [])\n            all_configs = search_result.get(\"all_configs\", [])\n            source_field = getattr(self, 'source_field', 'full_config_text')\n            if not all_configs:\n                return Message(text=json.dumps({\n                    \"error\": \"No configs found in all_configs\",\n                    \"block_exists\": False,\n                    **multi_dc_info  # 🆕 Include multi-DC info\n                }, ensure_ascii=False))\n            # Operation-specific checks\n            is_create_operation = operation == \"CREATE_LOCATION\"\n            is_delete_operation = operation == \"DELETE_LOCATION\"\n            found_count = 0\n            errors = []\n            # Check all configs\n            for config in all_configs:\n                if not isinstance(config, dict):  # Safeguard\n                    errors.append(f\"Invalid config type in all_configs: {type(config)} - skipping\")\n                    continue\n                matching_domains = config.get(\"matching_domains\", [])\n                server_names = config.get(\"server_names\", [])\n                # Skip configs that don't match target domains\n                if target_domains:\n                    if not any(domain in target_domains for domain in matching_domains):\n                        if not any(domain in target_domains for domain in server_names):\n                            continue\n                config_text = config.get(source_field)\n                if not config_text:\n                    errors.append(f\"No {source_field} in {config.get('config_key', 'unknown')}\")\n                    continue\n                try:\n                    key, server_directives, locations = self._parse_yaml_config(config_text)\n                    # Для каждой location проверить\n                    for loc_param in location_parameters:\n                        target_loc = loc_param.get(\"location\")\n                        if not target_loc:\n                            continue\n                        if not location_parameters:  # Server block\n                            if len(server_directives) > 0:\n                                found_count += 1\n                        elif is_create_operation:\n                            # For CREATE: config is valid if location DOESN'T exist\n                            found_location = self._find_location(locations, target_loc)\n                            if not found_location:\n                                found_count += 1  # Good - can create\n                            else:\n                                errors.append(\n                                    f\"Location '{target_loc}' already exists in {key}\"\n                                )\n                        elif is_delete_operation:\n                            # For DELETE: config is valid if location DOES exist\n                            found_location = self._find_location(locations, target_loc)\n                            if found_location:\n                                found_count += 1  # Good - can delete\n                            else:\n                                errors.append(\n                                    f\"Location '{target_loc}' not found in {key}. \"\n                                    f\"Available: {[loc.get('path') for loc in locations]}\"\n                                )\n                        else:\n                            # For other operations (including MODIFY_LOCATION_PATH, MAKE_PROTECTED, MAKE_PUBLIC): location must exist\n                            found_location = self._find_location(locations, target_loc)\n                            if found_location:\n                                found_count += 1\n                            else:\n                                errors.append(\n                                    f\"Location '{target_loc}' not found in {key}. \"\n                                    f\"Available: {[loc.get('path') for loc in locations]}\"\n                                )\n                except Exception as e:\n                    errors.append(f\"Error parsing {config.get('config_key', 'unknown')}: {str(e)}\")\n            if found_count > 0:\n                result = {\n                    \"error\": None,\n                    \"found_in_configs\": found_count,\n                    \"total_configs\": len(all_configs),\n                    \"operation\": operation,\n                    \"locations_count\": len(location_parameters),\n                    **multi_dc_info,  # 🆕 Include multi-DC info\n                }\n                if is_create_operation:\n                    result[\"can_create\"] = True\n                    result[\"block_exists\"] = False\n                elif is_delete_operation:\n                    result[\"can_delete\"] = True\n                    result[\"block_exists\"] = True\n                else:\n                    result[\"block_exists\"] = True\n                if errors:\n                    result[\"warnings\"] = errors\n\n                # 🆕 Add multi-DC warning if applicable\n                if multi_dc_info[\"found_in_multiple_dc\"]:\n                    if \"warnings\" not in result:\n                        result[\"warnings\"] = []\n                    result[\"warnings\"].insert(0,\n                                              f\"⚠️ MULTI-DC: Domain found in {multi_dc_info['dc_count']} datacenters!\"\n                                              )\n\n                return Message(text=json.dumps(result, ensure_ascii=False))\n            else:\n                error_msg = {\n                    \"block_exists\": False,\n                    \"total_configs_checked\": len(all_configs),\n                    \"operation\": operation,\n                    \"locations_count\": len(location_parameters),\n                    \"details\": errors,\n                    **multi_dc_info,  # 🆕 Include multi-DC info\n                }\n                if is_create_operation:\n                    error_msg[\"error\"] = (\n                        f\"Cannot create locations - they may already exist in all configs\"\n                    )\n                    error_msg[\"can_create\"] = False\n                elif is_delete_operation:\n                    error_msg[\"error\"] = (\n                        f\"Cannot delete locations - not found in any config\"\n                    )\n                    error_msg[\"can_delete\"] = False\n                else:\n                    error_msg[\"error\"] = (\n                        f\"Locations not found in any config\"\n                    )\n                return Message(text=json.dumps(error_msg, ensure_ascii=False))\n        except Exception as e:\n            return Message(text=json.dumps({\n                \"error\": f\"Error checking block: {str(e)}\",\n                \"block_exists\": False\n            }, ensure_ascii=False))\n"
              },
              "source_field": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Source field",
                "dynamic": false,
                "info": "Field containing YAML config text (full_config_text or config_block)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "source_field",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "full_config_text"
              },
              "universal_search_result": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Universal Search Result",
                "dynamic": false,
                "info": "Output from Universal Search (contains agent1_data)",
                "input_types": [
                  "Data",
                  "dict"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "universal_search_result",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "selected_block",
          "showNode": true,
          "type": "LocationSelectorFromUniversalSearch"
        },
        "dragging": false,
        "id": "LocationSelectorFromUniversalSearch-Arbrf",
        "measured": {
          "height": 263,
          "width": 320
        },
        "position": {
          "x": -682.5376932592355,
          "y": 2475.37435239026
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LoopComponent-M2n5m",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "category": "logic",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.",
            "display_name": "Loop",
            "documentation": "https://docs.langflow.org/components-logic#loop",
            "edited": false,
            "field_order": [
              "data"
            ],
            "frozen": false,
            "icon": "infinity",
            "key": "LoopComponent",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": true,
                "cache": true,
                "display_name": "Item",
                "group_outputs": true,
                "method": "item_output",
                "name": "item",
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Done",
                "group_outputs": true,
                "method": "done_output",
                "name": "done",
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template.field.base import Output\n\n\nclass LoopComponent(Component):\n    display_name = \"Loop\"\n    description = (\n        \"Iterates over a list of Data objects, outputting one item at a time and aggregating results from loop inputs.\"\n    )\n    documentation: str = \"https://docs.langflow.org/components-logic#loop\"\n    icon = \"infinity\"\n\n    inputs = [\n        HandleInput(\n            name=\"data\",\n            display_name=\"Inputs\",\n            info=\"The initial list of Data objects or DataFrame to iterate over.\",\n            input_types=[\"DataFrame\"],\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Item\", name=\"item\", method=\"item_output\", allows_loop=True, group_outputs=True),\n        Output(display_name=\"Done\", name=\"done\", method=\"done_output\", group_outputs=True),\n    ]\n\n    def initialize_data(self) -> None:\n        \"\"\"Initialize the data list, context index, and aggregated list.\"\"\"\n        if self.ctx.get(f\"{self._id}_initialized\", False):\n            return\n\n        # Ensure data is a list of Data objects\n        data_list = self._validate_data(self.data)\n\n        # Store the initial data and context variables\n        self.update_ctx(\n            {\n                f\"{self._id}_data\": data_list,\n                f\"{self._id}_index\": 0,\n                f\"{self._id}_aggregated\": [],\n                f\"{self._id}_initialized\": True,\n            }\n        )\n\n    def _validate_data(self, data):\n        \"\"\"Validate and return a list of Data objects.\"\"\"\n        if isinstance(data, DataFrame):\n            return data.to_data_list()\n        if isinstance(data, Data):\n            return [data]\n        if isinstance(data, list) and all(isinstance(item, Data) for item in data):\n            return data\n        msg = \"The 'data' input must be a DataFrame, a list of Data objects, or a single Data object.\"\n        raise TypeError(msg)\n\n    def evaluate_stop_loop(self) -> bool:\n        \"\"\"Evaluate whether to stop item or done output.\"\"\"\n        current_index = self.ctx.get(f\"{self._id}_index\", 0)\n        data_length = len(self.ctx.get(f\"{self._id}_data\", []))\n        return current_index > data_length\n\n    def item_output(self) -> Data:\n        \"\"\"Output the next item in the list or stop if done.\"\"\"\n        self.initialize_data()\n        current_item = Data(text=\"\")\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n        else:\n            # Get data list and current index\n            data_list, current_index = self.loop_variables()\n            if current_index < len(data_list):\n                # Output current item and increment index\n                try:\n                    current_item = data_list[current_index]\n                except IndexError:\n                    current_item = Data(text=\"\")\n            self.aggregated_output()\n            self.update_ctx({f\"{self._id}_index\": current_index + 1})\n\n        # Now we need to update the dependencies for the next run\n        self.update_dependency()\n        return current_item\n\n    def update_dependency(self):\n        item_dependency_id = self.get_incoming_edge_by_target_param(\"item\")\n        if item_dependency_id not in self.graph.run_manager.run_predecessors[self._id]:\n            self.graph.run_manager.run_predecessors[self._id].append(item_dependency_id)\n\n    def done_output(self) -> DataFrame:\n        \"\"\"Trigger the done output when iteration is complete.\"\"\"\n        self.initialize_data()\n\n        if self.evaluate_stop_loop():\n            self.stop(\"item\")\n            self.start(\"done\")\n\n            aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n\n            return DataFrame(aggregated)\n        self.stop(\"done\")\n        return DataFrame([])\n\n    def loop_variables(self):\n        \"\"\"Retrieve loop variables from context.\"\"\"\n        return (\n            self.ctx.get(f\"{self._id}_data\", []),\n            self.ctx.get(f\"{self._id}_index\", 0),\n        )\n\n    def aggregated_output(self) -> list[Data]:\n        \"\"\"Return the aggregated list once all items are processed.\"\"\"\n        self.initialize_data()\n\n        # Get data list and aggregated list\n        data_list = self.ctx.get(f\"{self._id}_data\", [])\n        aggregated = self.ctx.get(f\"{self._id}_aggregated\", [])\n        loop_input = self.item\n        if loop_input is not None and not isinstance(loop_input, str) and len(aggregated) <= len(data_list):\n            aggregated.append(loop_input)\n            self.update_ctx({f\"{self._id}_aggregated\": aggregated})\n        return aggregated\n"
              },
              "data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "The initial list of Data objects or DataFrame to iterate over.",
                "input_types": [
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "LoopComponent"
        },
        "dragging": false,
        "id": "LoopComponent-M2n5m",
        "measured": {
          "height": 241,
          "width": 320
        },
        "position": {
          "x": 593.1590454529365,
          "y": 2590.453712564725
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConfigBlockSplitter-Rxujk",
          "node": {
            "base_classes": [
              "Data",
              "DataFrame"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Splits config blocks array into DataFrame for sequential Loop/LLM processing",
            "display_name": "Config Block Splitter",
            "documentation": "",
            "edited": true,
            "field_order": [
              "selected_block"
            ],
            "frozen": false,
            "icon": "split",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Config Items DataFrame",
                "group_outputs": false,
                "hidden": null,
                "method": "build_config_dataframe",
                "name": "config_items_df",
                "options": null,
                "required_inputs": null,
                "selected": "DataFrame",
                "tool_mode": true,
                "types": [
                  "DataFrame"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Total Count",
                "group_outputs": false,
                "hidden": null,
                "method": "build_total_count",
                "name": "total_count",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Metadata",
                "group_outputs": false,
                "hidden": null,
                "method": "build_metadata",
                "name": "metadata",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.message import Message\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.template.field.base import Output\nimport json\nimport pandas as pd\nfrom typing import Union, List, Dict, Any\n\n\nclass ConfigBlockSplitter(Component):\n    \"\"\"\n    Splits normalized config blocks from LocationSelector into individual items for Loop processing.\n    Properly handles Message input from LocationSelectorFromUniversalSearch.\n    Converts selected_blocks array into DataFrame format suitable for Loop component.\n\n    NEW: Supports block-level warnings for unknown operations like MAKE_PROTECTED\n    \"\"\"\n\n    display_name = \"Config Block Splitter\"\n    description = \"Splits config blocks array into DataFrame for sequential Loop/LLM processing\"\n    documentation = \"\"\n    icon = \"split\"\n\n    inputs = [\n        HandleInput(\n            name=\"selected_block\",\n            display_name=\"Selected Block\",\n            input_types=[\"Message\", \"Data\", \"dict\"],\n            info=\"Output from LocationSelectorFromUniversalSearch containing selected_blocks\",\n            required=True,\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Config Items DataFrame\",\n            name=\"config_items_df\",\n            info=\"DataFrame with individual config blocks for Loop processing\",\n            method=\"build_config_dataframe\",\n        ),\n        Output(\n            display_name=\"Total Count\",\n            name=\"total_count\",\n            info=\"Total number of config blocks to process\",\n            method=\"build_total_count\",\n        ),\n        Output(\n            display_name=\"Metadata\",\n            name=\"metadata\",\n            info=\"Additional metadata from the original response\",\n            method=\"build_metadata\",\n        ),\n    ]\n\n    def process_input_data(self, data: Union[Message, Data, dict, str]) -> dict:\n        \"\"\"Convert input to dictionary format - handles Message, Data, dict, and JSON string\"\"\"\n        try:\n            # Handle Message type (from LocationSelector)\n            if isinstance(data, Message):\n                text = data.text if hasattr(data, 'text') else str(data)\n                return json.loads(text)\n\n            # Handle Data type\n            elif isinstance(data, Data):\n                if hasattr(data, 'data'):\n                    data_content = data.data\n                    if isinstance(data_content, str):\n                        return json.loads(data_content)\n                    return data_content\n                elif hasattr(data, 'to_dict'):\n                    return data.to_dict()\n                else:\n                    return dict(data)\n\n            # Handle dict\n            elif isinstance(data, dict):\n                return data\n\n            # Handle JSON string\n            elif isinstance(data, str):\n                return json.loads(data)\n\n            else:\n                raise ValueError(f\"Unexpected input type: {type(data)}\")\n\n        except json.JSONDecodeError as e:\n            self.log(f\"JSON decode error: {str(e)}\")\n            raise ValueError(f\"Invalid JSON in input: {str(e)}\")\n        except Exception as e:\n            self.log(f\"Error processing input: {str(e)}\")\n            raise\n\n    def extract_config_blocks(self, input_data: dict) -> List[Dict[str, Any]]:\n        \"\"\"Extract selected_blocks array from input data\"\"\"\n        if 'selected_blocks' in input_data:\n            blocks = input_data['selected_blocks']\n            # Ensure it's a list\n            if isinstance(blocks, list):\n                return blocks\n            elif isinstance(blocks, dict):\n                # Single block wrapped in dict - convert to list\n                return [blocks]\n            else:\n                self.log(f\"Warning: selected_blocks is not a list or dict: {type(blocks)}\")\n                return []\n\n        # Fallback: try to find blocks in nested structure\n        if 'selected_block' in input_data:\n            block_data = input_data['selected_block']\n            if isinstance(block_data, list):\n                return block_data\n            elif isinstance(block_data, dict) and 'selected_blocks' in block_data:\n                return block_data['selected_blocks']\n\n        # If no selected_blocks found, return empty list\n        self.log(\"Warning: No selected_blocks found in input data\")\n        return []\n\n    def build_config_dataframe(self) -> DataFrame:\n        \"\"\"Convert selected_blocks array into DataFrame for Loop component\"\"\"\n        try:\n            # Process input data\n            input_data = self.process_input_data(self.selected_block)\n\n            # Check for errors in input\n            if 'error' in input_data and not input_data.get('selected_blocks'):\n                self.log(f\"Error in input data: {input_data.get('error')}\")\n                return DataFrame(pd.DataFrame(columns=['error'], data=[{'error': input_data.get('error')}]))\n\n            # Extract config blocks\n            config_blocks = self.extract_config_blocks(input_data)\n\n            # НОВОЕ: Извлекаем глобальные warnings\n            global_warnings = input_data.get('warnings', [])\n            if global_warnings:\n                self.log(f\"Found {len(global_warnings)} global warnings: {global_warnings}\")\n\n            if not config_blocks:\n                # Return empty DataFrame with expected structure\n                self.log(\"No config blocks found, returning empty DataFrame\")\n                return DataFrame(pd.DataFrame(columns=[\n                    'index', 'config_key', 'config_file', 'server_names',\n                    'location_path', 'operation', 'type', 'full_config_json'\n                ]))\n\n            # 🔥 НОВОЕ: Функция проверки на MULTI-DC warning\n            def has_multi_dc_warning(warnings_list: List[str]) -> bool:\n                \"\"\"Проверяет, содержится ли MULTI-DC warning в списке\"\"\"\n                if not warnings_list:\n                    return False\n                for warning in warnings_list:\n                    if isinstance(warning, str) and \"MULTI-DC: Domain found in\" in warning and \"datacenters\" in warning:\n                        return True\n                return False\n\n            # Prepare data for DataFrame\n            df_data = []\n            filtered_blocks = []  # 🔥 НОВОЕ: Собираем отфильтрованные блоки\n            filtered_count = 0\n\n            for idx, block in enumerate(config_blocks):\n                if not isinstance(block, dict):\n                    self.log(f\"Warning: Block {idx} is not a dict, skipping\")\n                    continue\n\n                # Объединяем warnings блока и глобальные warnings\n                block_warnings = block.get('warnings', [])\n                combined_warnings = []\n\n                # Определяем, содержит ли блок домены, которые находятся в нескольких ДЦ\n                domains_in_multi_dc = set(input_data.get(\"domains_in_multiple_dc\", []))\n                block_domains = block.get('matching_domains', [])\n                block_in_multi_dc = any(domain in domains_in_multi_dc for domain in block_domains)\n\n                # Добавляем глобальные warnings ТОЛЬКО если блок относится к multi-DC домену\n                if block_in_multi_dc and global_warnings:\n                    combined_warnings.extend(global_warnings)\n\n                # Добавляем warnings конкретного блока\n                if block_warnings:\n                    if isinstance(block_warnings, list):\n                        combined_warnings.extend(block_warnings)\n                    elif isinstance(block_warnings, str):\n                        combined_warnings.append(block_warnings)\n\n                # 🔥 ФИЛЬТРАЦИЯ: Пропускаем блоки с MULTI-DC warning\n                if has_multi_dc_warning(combined_warnings):\n                    filtered_count += 1\n                    filtered_blocks.append(block)  # 🔥 Сохраняем для информации\n                    self.log(\n                        f\"⚠️ Filtering out block {idx} ({block.get('location_path', 'unknown')}) - contains MULTI-DC warning\")\n                    continue\n\n                # Логируем для информации\n                if combined_warnings:\n                    self.log(\n                        f\"Block {idx} ({block.get('location_path', 'unknown')}): {len(combined_warnings)} warnings - {combined_warnings}\")\n\n                # Each row will contain the full block data\n                row = {\n                    'index': idx,\n                    'config_key': block.get('config_key', ''),\n                    'config_file': block.get('config_file', ''),\n                    'server_names': json.dumps(block.get('server_names', []), ensure_ascii=False),\n                    'matching_domains': json.dumps(block.get('matching_domains', []), ensure_ascii=False),\n                    'location_path': block.get('location_path', ''),\n                    'operation': block.get('operation', ''),\n                    'type': block.get('type', 'location'),\n                    'hash': block.get('hash', ''),\n\n                    # Arrays as JSON strings\n                    'directives': json.dumps(block.get('directives', []), ensure_ascii=False),\n                    'parameters': json.dumps(block.get('parameters', []), ensure_ascii=False),\n                    'existing_locations': json.dumps(block.get('existing_locations', []), ensure_ascii=False),\n                    'ip_addresses': json.dumps(block.get('ip_addresses', []), ensure_ascii=False),\n                    'upstreams': json.dumps(block.get('upstreams', []) if block.get('upstreams') else [],\n                                            ensure_ascii=False),\n\n                    'warnings': json.dumps(combined_warnings, ensure_ascii=False),\n\n                    # Boolean and special fields\n                    'kms_required': block.get('kms_required', False),\n                    'create_mode': block.get('create_mode', False),\n                    'delete_mode': block.get('delete_mode', False),\n\n                    # NEW: Support for MODIFY_LOCATION_PATH\n                    'new_location_path': block.get('new_location_path', ''),\n\n                    # Store complete block as JSON string for full context\n                    'full_config_json': json.dumps(block, ensure_ascii=False),\n                }\n                df_data.append(row)\n\n            # 🔥 НОВОЕ: Логируем статистику фильтрации\n            if filtered_count > 0:\n                self.log(\n                    f\"✅ Filtered out {filtered_count} blocks with MULTI-DC warnings. Remaining: {len(df_data)} blocks\")\n\n            # 🔥 НОВОЕ: Если все блоки отфильтрованы, создаём информативную строку\n            if not df_data:\n                self.log(\"No valid blocks after filtering, returning informative DataFrame\")\n\n                # Формируем список отфильтрованных доменов для информации\n                filtered_domains = []\n                for block in filtered_blocks:\n                    filtered_domains.extend(block.get('matching_domains', []))\n                filtered_domains = list(set(filtered_domains))  # Убираем дубликаты\n\n                # Создаём информативную строку вместо ошибки\n                info_row = {\n                    'index': 0,\n                    'config_key': 'FILTERED',\n                    'config_file': 'N/A',\n                    'server_names': json.dumps([], ensure_ascii=False),\n                    'matching_domains': json.dumps(filtered_domains, ensure_ascii=False),\n                    'location_path': 'N/A',\n                    'operation': input_data.get('operation', 'SKIP_MULTI_DC'),\n                    'type': 'filtered',\n                    'hash': '',\n                    'directives': json.dumps([], ensure_ascii=False),\n                    'parameters': json.dumps([], ensure_ascii=False),\n                    'existing_locations': json.dumps([], ensure_ascii=False),\n                    'ip_addresses': json.dumps([], ensure_ascii=False),\n                    'upstreams': json.dumps([], ensure_ascii=False),\n                    'warnings': json.dumps([\n                        f\"All {filtered_count} blocks filtered due to MULTI-DC warnings\",\n                        f\"Affected domains: {', '.join(filtered_domains)}\"\n                    ], ensure_ascii=False),\n                    'kms_required': False,\n                    'create_mode': False,\n                    'delete_mode': False,\n                    'new_location_path': '',\n                    'full_config_json': json.dumps({\n                        \"status\": \"filtered\",\n                        \"reason\": \"MULTI-DC domains detected\",\n                        \"filtered_count\": filtered_count,\n                        \"filtered_domains\": filtered_domains,\n                        \"original_operation\": input_data.get('operation', ''),\n                        \"message\": \"These domains exist in multiple datacenters. Manual intervention required.\"\n                    }, ensure_ascii=False)\n                }\n\n                df = pd.DataFrame([info_row])\n                self.log(f\"Returning informative DataFrame for {filtered_count} filtered blocks\")\n                return DataFrame(df)\n\n            # Create DataFrame\n            df = pd.DataFrame(df_data)\n\n            self.log(f\"Successfully created DataFrame with {len(df)} rows (filtered {filtered_count} MULTI-DC blocks)\")\n\n            # Return as langflow DataFrame\n            return DataFrame(df)\n\n        except Exception as e:\n            error_msg = f\"Error building DataFrame: {str(e)}\"\n            self.log(error_msg)\n            # Return DataFrame with error information\n            return DataFrame(pd.DataFrame(columns=['error'], data=[{'error': error_msg}]))\n\n    def build_total_count(self) -> Data:\n        \"\"\"Return total count of config blocks\"\"\"\n        try:\n            input_data = self.process_input_data(self.selected_block)\n            config_blocks = self.extract_config_blocks(input_data)\n\n            count_data = {\n                \"total_blocks\": len(config_blocks),\n                \"has_data\": len(config_blocks) > 0,\n                \"operation\": input_data.get(\"operation\", \"\"),\n                \"target_domains\": input_data.get(\"target_domains\", []),\n                \"locations_count\": input_data.get(\"locations_count\", 0),\n                \"warnings\": input_data.get(\"warnings\", [])\n            }\n\n            return Data(data=count_data)\n\n        except Exception as e:\n            error_msg = f\"Error getting total count: {str(e)}\"\n            self.log(error_msg)\n            return Data(data={\"total_blocks\": 0, \"has_data\": False, \"error\": error_msg})\n\n    def build_metadata(self) -> Data:\n        \"\"\"Extract and return metadata from the original response\"\"\"\n        try:\n            input_data = self.process_input_data(self.selected_block)\n\n            # Extract metadata fields\n            metadata = {\n                \"total_configs_scanned\": input_data.get(\"total_configs_scanned\", 0),\n                \"total_blocks_found\": input_data.get(\"total_blocks_found\", 0),\n                \"target_locations\": input_data.get(\"target_locations\", []),\n                \"target_domains\": input_data.get(\"target_domains\", []),\n                \"operation\": input_data.get(\"operation\", \"\"),\n                \"locations_count\": input_data.get(\"locations_count\", 0),\n                \"warnings\": input_data.get(\"warnings\", [])\n            }\n\n            # Add error if present\n            if 'error' in input_data:\n                metadata['error'] = input_data['error']\n\n            return Data(data=metadata)\n\n        except Exception as e:\n            error_msg = f\"Error extracting metadata: {str(e)}\"\n            self.log(error_msg)\n            return Data(data={\"error\": error_msg})"
              },
              "selected_block": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Selected Block",
                "dynamic": false,
                "info": "Output from LocationSelectorFromUniversalSearch containing selected_blocks",
                "input_types": [
                  "Message",
                  "Data",
                  "dict"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "selected_block",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "config_items_df",
          "showNode": true,
          "type": "ConfigBlockSplitter"
        },
        "dragging": false,
        "id": "ConfigBlockSplitter-Rxujk",
        "measured": {
          "height": 181,
          "width": 320
        },
        "position": {
          "x": 220.49788719178844,
          "y": 2608.2173219933356
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-Ivr9p",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "INPUTS PROVIDED:\n\n\n2. OPERATION: {operation}\n\n3. CONFIG FILE:\nFile path: {config_file}\nConfig key: {full_config_json}\n\nWarnings: {warnings}\n\n---\n\nNOW PROCESS THE REQUEST AND RETURN JSON OUTPUT."
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-Ivr9p",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": 1376.524151144663,
          "y": 2198.276283306156
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "OpenAIModel-zisXO",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "category": "openai",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generates text using OpenAI LLMs.",
            "display_name": "OpenAI",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout"
            ],
            "frozen": false,
            "icon": "OpenAI",
            "key": "OpenAIModel",
            "last_updated": "2025-11-03T16:58:41.808Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.000001,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": "TOKEN"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import (\n    OPENAI_CHAT_MODEL_NAMES,\n    OPENAI_REASONING_MODEL_NAMES,\n)\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\nfrom langflow.logging import logger\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_CHAT_MODEL_NAMES + OPENAI_REASONING_MODEL_NAMES,\n            value=OPENAI_CHAT_MODEL_NAMES[0],\n            combobox=True,\n            real_time_refresh=True,\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            range_spec=RangeSpec(min=0, max=1, step=0.01),\n            show=True,\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        IntInput(\n            name=\"max_retries\",\n            display_name=\"Max Retries\",\n            info=\"The maximum number of retries to make when generating.\",\n            advanced=True,\n            value=5,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"The timeout for requests to OpenAI completion API.\",\n            advanced=True,\n            value=700,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        logger.debug(f\"Executing request with model: {self.model_name}\")\n        parameters = {\n            \"api_key\": SecretStr(self.api_key).get_secret_value() if self.api_key else None,\n            \"model_name\": self.model_name,\n            \"max_tokens\": self.max_tokens or None,\n            \"model_kwargs\": self.model_kwargs or {},\n            \"base_url\": self.openai_api_base or \"https://api.openai.com/v1\",\n            \"max_retries\": self.max_retries,\n            \"timeout\": self.timeout,\n        }\n\n        # TODO: Revisit if/once parameters are supported for reasoning models\n        unsupported_params_for_reasoning_models = [\"temperature\", \"seed\"]\n\n        if self.model_name not in OPENAI_REASONING_MODEL_NAMES:\n            parameters[\"temperature\"] = self.temperature if self.temperature is not None else 0.1\n            parameters[\"seed\"] = self.seed\n        else:\n            params_str = \", \".join(unsupported_params_for_reasoning_models)\n            logger.debug(f\"{self.model_name} is a reasoning model, {params_str} are not configurable. Ignoring.\")\n\n        output = ChatOpenAI(**parameters)\n        if self.json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None) -> dict:\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_REASONING_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = False\n            build_config[\"seed\"][\"show\"] = False\n            # Hide system_message for o1 models - currently unsupported\n            if field_value.startswith(\"o1\") and \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = False\n        if field_name in {\"base_url\", \"model_name\", \"api_key\"} and field_value in OPENAI_CHAT_MODEL_NAMES:\n            build_config[\"temperature\"][\"show\"] = True\n            build_config[\"seed\"][\"show\"] = True\n            if \"system_message\" in build_config:\n                build_config[\"system_message\"][\"show\"] = True\n        return build_config\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4.1-mini",
                  "gpt-4.1-nano",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "gpt-5",
                  "gpt-5-mini",
                  "gpt-5-nano",
                  "gpt-5-chat-latest",
                  "o1",
                  "o3-mini",
                  "o3",
                  "o3-pro",
                  "o4-mini",
                  "o4-mini-high"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "local_huggingface/Qwen3-32B"
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://localhost:8000/v1"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are the NGINX YAML Configuration Processor.  \nFollow ENGINE_RULES from the input exactly.  \nNever invent directives. Only modify existing YAML according to parameters.  \nAlways return valid JSON.\n\n"
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.05
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              }
            },
            "tool_mode": false
          },
          "selected_output": "text_output",
          "showNode": true,
          "type": "OpenAIModel"
        },
        "dragging": false,
        "id": "OpenAIModel-zisXO",
        "measured": {
          "height": 661,
          "width": 320
        },
        "position": {
          "x": 2864.6599119080643,
          "y": 2508.8432162185286
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TypeConverterComponent-JGP5t",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "processing",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Convert between different types (Message, Data, DataFrame)",
            "display_name": "Type Convert",
            "documentation": "https://docs.langflow.org/components-processing#type-convert",
            "edited": false,
            "field_order": [
              "input_data",
              "output_type"
            ],
            "frozen": false,
            "icon": "repeat",
            "key": "TypeConverterComponent",
            "last_updated": "2025-11-21T11:34:07.249Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data Output",
                "group_outputs": false,
                "hidden": null,
                "method": "convert_to_data",
                "name": "data_output",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.008834292878014125,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\n\nfrom langflow.custom import Component\nfrom langflow.io import HandleInput, Output, TabInput\nfrom langflow.schema import Data, DataFrame, Message\n\n\ndef convert_to_message(v) -> Message:\n    \"\"\"Convert input to Message type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        Message: Converted Message object\n    \"\"\"\n    return v if isinstance(v, Message) else v.to_message()\n\n\ndef convert_to_data(v: DataFrame | Data | Message | dict) -> Data:\n    \"\"\"Convert input to Data type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        Data: Converted Data object\n    \"\"\"\n    if isinstance(v, dict):\n        return Data(v)\n    if isinstance(v, Message):\n        return v.to_data()\n    return v if isinstance(v, Data) else v.to_data()\n\n\ndef convert_to_dataframe(v: DataFrame | Data | Message | dict) -> DataFrame:\n    \"\"\"Convert input to DataFrame type.\n\n    Args:\n        v: Input to convert (Message, Data, DataFrame, or dict)\n\n    Returns:\n        DataFrame: Converted DataFrame object\n    \"\"\"\n    if isinstance(v, dict):\n        return DataFrame([v])\n    return v if isinstance(v, DataFrame) else v.to_dataframe()\n\n\nclass TypeConverterComponent(Component):\n    display_name = \"Type Convert\"\n    description = \"Convert between different types (Message, Data, DataFrame)\"\n    documentation: str = \"https://docs.langflow.org/components-processing#type-convert\"\n    icon = \"repeat\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Input\",\n            input_types=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Accept Message, Data or DataFrame as input\",\n            required=True,\n        ),\n        TabInput(\n            name=\"output_type\",\n            display_name=\"Output Type\",\n            options=[\"Message\", \"Data\", \"DataFrame\"],\n            info=\"Select the desired output data type\",\n            real_time_refresh=True,\n            value=\"Message\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message Output\",\n            name=\"message_output\",\n            method=\"convert_to_message\",\n        )\n    ]\n\n    def update_outputs(self, frontend_node: dict, field_name: str, field_value: Any) -> dict:\n        \"\"\"Dynamically show only the relevant output based on the selected output type.\"\"\"\n        if field_name == \"output_type\":\n            # Start with empty outputs\n            frontend_node[\"outputs\"] = []\n\n            # Add only the selected output type\n            if field_value == \"Message\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Message Output\",\n                        name=\"message_output\",\n                        method=\"convert_to_message\",\n                    ).to_dict()\n                )\n            elif field_value == \"Data\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"Data Output\",\n                        name=\"data_output\",\n                        method=\"convert_to_data\",\n                    ).to_dict()\n                )\n            elif field_value == \"DataFrame\":\n                frontend_node[\"outputs\"].append(\n                    Output(\n                        display_name=\"DataFrame Output\",\n                        name=\"dataframe_output\",\n                        method=\"convert_to_dataframe\",\n                    ).to_dict()\n                )\n\n        return frontend_node\n\n    def convert_to_message(self) -> Message:\n        \"\"\"Convert input to Message type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_message(input_value)\n        self.status = result\n        return result\n\n    def convert_to_data(self) -> Data:\n        \"\"\"Convert input to Data type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_data(input_value)\n        self.status = result\n        return result\n\n    def convert_to_dataframe(self) -> DataFrame:\n        \"\"\"Convert input to DataFrame type.\"\"\"\n        input_value = self.input_data[0] if isinstance(self.input_data, list) else self.input_data\n\n        # Handle string input by converting to Message first\n        if isinstance(input_value, str):\n            input_value = Message(text=input_value)\n\n        result = convert_to_dataframe(input_value)\n        self.status = result\n        return result\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "Accept Message, Data or DataFrame as input",
                "input_types": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "output_type": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Output Type",
                "dynamic": false,
                "info": "Select the desired output data type",
                "name": "output_type",
                "options": [
                  "Message",
                  "Data",
                  "DataFrame"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Data"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TypeConverterComponent"
        },
        "dragging": false,
        "id": "TypeConverterComponent-JGP5t",
        "measured": {
          "height": 261,
          "width": 320
        },
        "position": {
          "x": 3226.6526161991965,
          "y": 3259.3590447045713
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "TextInput-6bdk9",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get user text inputs.",
            "display_name": "Text Input",
            "documentation": "https://docs.langflow.org/components-io#text-input",
            "edited": false,
            "field_order": [
              "input_value"
            ],
            "frozen": false,
            "icon": "type",
            "key": "TextInput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Text",
                "group_outputs": false,
                "method": "text_response",
                "name": "text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0022704986850629236,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get user text inputs.\"\n    documentation: str = \"https://docs.langflow.org/components-io#text-input\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Output Text\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n"
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Text to be passed as input.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "TextInput"
        },
        "dragging": false,
        "id": "TextInput-6bdk9",
        "measured": {
          "height": 203,
          "width": 320
        },
        "position": {
          "x": -1624.707182656344,
          "y": 2618.2012875341197
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "UniversalSearchConfigComponent-IuZIu",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Универсально сканирует YML файлы по доменам из любой структуры JSON (включая Arbitrator payload)",
            "display_name": "Universal Search Config",
            "documentation": "",
            "edited": true,
            "field_order": [
              "agent1_json",
              "config_base_path"
            ],
            "frozen": false,
            "icon": "search",
            "legacy": false,
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Config Data",
                "group_outputs": false,
                "hidden": null,
                "method": "search_config",
                "name": "config_data",
                "options": null,
                "required_inputs": null,
                "selected": "Data",
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "agent1_json": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Agent 1 JSON Output",
                "dynamic": false,
                "info": "JSON с извлечёнными данными от Agent 1 или Arbitrator (любая структура)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "agent1_json",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\nfrom langflow.io import MessageTextInput, StrInput, Output\nfrom langflow.schema import Data\nimport json\nimport yaml\nimport os\nimport glob\nimport re\nfrom typing import List, Dict, Any, Optional\n\n\nclass UniversalSearchConfigComponent(Component):\n    display_name = \"Universal Search Config\"\n    description = \"Универсально сканирует YML файлы по доменам из любой структуры JSON (включая Arbitrator payload)\"\n    icon = \"search\"\n    inputs = [\n        MessageTextInput(\n            name=\"agent1_json\",\n            display_name=\"Agent 1 JSON Output\",\n            info=\"JSON с извлечёнными данными от Agent 1 или Arbitrator (любая структура)\",\n            required=True\n        ),\n        StrInput(\n            name=\"config_base_path\",\n            display_name=\"Config Base Path\",\n            info=\"Путь к родительской папке с конфигами (например, /path/to/mos_ru_nginx/)\",\n            value=\"/Users/rusk/PycharmProjects/fastapi/portalFastDjango/mosru_nginx/mos_ru_nginx/\",\n            required=True\n        )\n    ]\n    outputs = [\n        Output(\n            display_name=\"Config Data\",\n            name=\"config_data\",\n            method=\"search_config\"\n        )\n    ]\n\n    def search_config(self) -> Data:\n        \"\"\"\n        Универсально обрабатывает любой JSON/Python dict и ищет конфигурации\n        \"\"\"\n        try:\n            # 🔧 ПРЕДОБРАБОТКА: Очищаем от markdown блоков\n            cleaned_input = self._clean_markdown(self.agent1_json)\n\n            # 🔄 ПАРСИМ: Поддержка и JSON, и Python dict\n            raw_data = self._parse_input(cleaned_input)\n\n            # 🔄 НОРМАЛИЗАЦИЯ: Извлекаем payload если это Arbitrator output\n            agent1_data = self._normalize_input(raw_data)\n            # 🔍 УНИВЕРСАЛЬНОЕ ИЗВЛЕЧЕНИЕ ДОМЕНОВ\n            domains = self._universal_extract_domains(agent1_data)\n\n            # 🔍 УНИВЕРСАЛЬНОЕ ИЗВЛЕЧЕНИЕ ДРУГИХ ДАННЫХ\n            locations = self._universal_extract_locations(agent1_data)\n            ip_addresses = self._universal_extract_ips(agent1_data)\n            upstreams = self._universal_extract_upstreams(agent1_data)\n            parameters = self._universal_extract_parameters(agent1_data)\n            location_parameters = self._universal_extract_location_parameters(agent1_data)\n            operation = self._universal_extract_operation(agent1_data)\n            selected_dc = self._universal_extract_selected_dc(agent1_data)\n            # ✅ ПРОВЕРЯЕМ СТАТУС\n            status = self._check_status(raw_data)  # Проверяем оригинальные данные\n            if status and status.get(\"is_error\"):\n                return self._return_error_status(status, agent1_data)\n            # ❌ ОШИБКА: Домены не найдены\n            if not domains:\n                return self._return_no_domains_error(\n                    agent1_data, locations, ip_addresses, parameters, operation\n                )\n            # 🔍 ОПРЕДЕЛЯЕМ ПАПКИ ДЛЯ ПОИСКА\n            search_folders = self._get_search_folders(selected_dc)\n            # 🔍 СКАНИРУЕМ ВСЕ YML ФАЙЛЫ В ВЫБРАННЫХ ПАПКАХ\n            config_results = []\n            scanned_files = 0\n            for folder in search_folders:\n                folder_path = os.path.join(self.config_base_path, folder)\n                if not os.path.isdir(folder_path):\n                    continue\n                yml_files = glob.glob(os.path.join(folder_path, \"*.yml\"))\n                scanned_files += len(yml_files)\n                for yml_file in yml_files:\n                    file_results = self._scan_yml_file(yml_file, domains)\n                    for res in file_results:\n                        res[\"folder\"] = folder\n                        res[\"inferred_dc\"] = self._infer_dc_from_folder(folder)\n                    config_results.extend(file_results)\n            # Удаляем дубликаты (по полному пути и ключу)\n            unique_results = self._deduplicate_results(config_results)\n            # ❌ ОШИБКА: Конфиги не найдены\n            if not unique_results:\n                return self._return_not_found_error(\n                    domains, scanned_files, agent1_data,\n                    locations, ip_addresses, parameters, operation\n                )\n            # ✅ УСПЕХ: Конфиг найден\n            first_config = unique_results[0]\n\n            # 🆕 АНАЛИЗ: Проверяем, найден ли домен в нескольких ЦОД\n            multi_dc_info = self._analyze_multi_dc_presence(unique_results, domains)\n\n            result = {\n                \"status\": \"success\",\n\n                # 📦 Конфиг данные\n                \"config_file\": first_config[\"config_file\"],\n                \"config_key\": first_config[\"config_key\"],\n                \"full_config_text\": first_config[\"full_config_text\"],\n                \"server_names\": first_config[\"server_names\"],\n                \"matching_domains\": first_config[\"matching_domains\"],\n                # 📦 Извлечённые данные (нормализованные)\n                \"agent1_data\": agent1_data,\n                \"operation\": operation,\n                \"domains\": domains,\n                \"locations\": locations,\n                \"ip_addresses\": ip_addresses,\n                \"upstreams\": upstreams,\n                \"parameters\": parameters,\n                \"location_parameters\": location_parameters,\n                \"selected_dc\": selected_dc,\n                # 📊 Метаданные\n                \"scanned_files\": scanned_files,\n                \"found_configs\": len(unique_results),\n                \"all_configs\": unique_results,\n                \"data_complete\": True,\n                \"error_type\": None,\n                \"error_message\": None,\n\n                # 🆕 НОВЫЕ КЛЮЧИ: Информация о нахождении в нескольких ЦОД\n                \"found_in_multiple_dc\": multi_dc_info[\"found_in_multiple_dc\"],\n                \"dc_count\": multi_dc_info[\"dc_count\"],\n                \"unique_dcs\": multi_dc_info[\"unique_dcs\"],\n                \"domain_dc_mapping\": multi_dc_info[\"domain_dc_mapping\"],\n                \"domains_in_multiple_dc\": multi_dc_info[\"domains_in_multiple_dc\"],\n            }\n            # Формируем сообщение\n            msg = self._format_success_message(result)\n            return Data(data=result, text=msg)\n        except json.JSONDecodeError as e:\n            return self._return_json_error(e, self.agent1_json)\n        except Exception as e:\n            return self._return_unexpected_error(e)\n\n    # ==========================================\n    # 🆕 НОВЫЙ МЕТОД: Анализ присутствия в нескольких ЦОД\n    # ==========================================\n    def _analyze_multi_dc_presence(self, config_results: List[Dict], domains: List[str]) -> Dict:\n        \"\"\"\n        Анализирует, найден ли домен в нескольких ЦОД\n\n        Returns:\n            Dict с ключами:\n            - found_in_multiple_dc: bool - True если хотя бы один домен найден в >1 ЦОД\n            - dc_count: int - количество уникальных ЦОД где найдены конфиги\n            - unique_dcs: List[str] - список уникальных ЦОД\n            - domain_dc_mapping: Dict[str, List[str]] - маппинг домен -> список ЦОД\n            - domains_in_multiple_dc: List[str] - домены, найденные в нескольких ЦОД\n        \"\"\"\n        # Собираем все уникальные ЦОД из результатов\n        all_dcs = set()\n        for config in config_results:\n            inferred_dc = config.get(\"inferred_dc\", [])\n            all_dcs.update(inferred_dc)\n\n        unique_dcs = sorted(list(all_dcs))\n        dc_count = len(unique_dcs)\n\n        # Строим маппинг: домен -> в каких ЦОД найден\n        domain_dc_mapping = {}\n        for domain in domains:\n            domain_dcs = set()\n            for config in config_results:\n                matching_domains = config.get(\"matching_domains\", [])\n                if domain in matching_domains:\n                    inferred_dc = config.get(\"inferred_dc\", [])\n                    domain_dcs.update(inferred_dc)\n            domain_dc_mapping[domain] = sorted(list(domain_dcs))\n\n        # Определяем домены, которые найдены в нескольких ЦОД\n        domains_in_multiple_dc = [\n            domain for domain, dcs in domain_dc_mapping.items()\n            if len(dcs) > 1\n        ]\n\n        # Главный флаг: есть ли хотя бы один домен в нескольких ЦОД\n        found_in_multiple_dc = len(domains_in_multiple_dc) > 0\n\n        return {\n            \"found_in_multiple_dc\": found_in_multiple_dc,\n            \"dc_count\": dc_count,\n            \"unique_dcs\": unique_dcs,\n            \"domain_dc_mapping\": domain_dc_mapping,\n            \"domains_in_multiple_dc\": domains_in_multiple_dc\n        }\n\n    # ==========================================\n    # ПРЕДОБРАБОТКА И НОРМАЛИЗАЦИЯ\n    # ==========================================\n    def _clean_markdown(self, raw_input: str) -> str:\n        \"\"\"Убирает только markdown разметку\"\"\"\n        if not raw_input:\n            return raw_input\n\n        cleaned = raw_input.strip()\n\n        patterns = [\n            (r'^```json\\s*\\n', ''),\n            (r'^```\\s*\\n', ''),\n            (r'\\n```\\s*$', ''),\n            (r'^```json\\s*', ''),\n            (r'^```\\s*', ''),\n            (r'```\\s*$', ''),\n        ]\n\n        for pattern, replacement in patterns:\n            cleaned = re.sub(pattern, replacement, cleaned)\n\n        return cleaned.strip()\n\n    def _parse_input(self, text: str) -> Dict:\n        \"\"\"\n        🔄 Парсит входные данные — поддерживает JSON и Python dict\n        \"\"\"\n        # Способ 1: Пробуем как JSON\n        try:\n            return json.loads(text)\n        except json.JSONDecodeError:\n            pass\n\n        # Способ 2: Пробуем как Python dict через ast.literal_eval\n        try:\n            import ast\n            result = ast.literal_eval(text)\n            if isinstance(result, dict):\n                return result\n        except (ValueError, SyntaxError):\n            pass\n\n        # Способ 3: Ручная конвертация Python → JSON\n        try:\n            converted = text\n            converted = re.sub(r'\\bNone\\b', 'null', converted)\n            converted = re.sub(r'\\bTrue\\b', 'true', converted)\n            converted = re.sub(r'\\bFalse\\b', 'false', converted)\n            converted = converted.replace(\"'\", '\"')\n            return json.loads(converted)\n        except json.JSONDecodeError:\n            pass\n\n        # Если ничего не сработало — выбрасываем ошибку\n        raise json.JSONDecodeError(\n            f\"Не удалось распарсить ни как JSON, ни как Python dict\",\n            text,\n            0\n        )\n\n    def _normalize_input(self, raw_data: Any) -> Dict:\n        \"\"\"\n        🔄 НОРМАЛИЗАЦИЯ: Извлекает payload из Arbitrator output\n\n        Поддерживает форматы:\n        1. Arbitrator: {\"status\": \"SUCCESS\", \"payload\": {...}, \"ready_for_execution\": true}\n        2. Прямой Agent1: {\"operation\": \"...\", \"domain\": \"...\", ...}\n        3. Вложенный: {\"data\": {\"payload\": {...}}}\n        \"\"\"\n        if not isinstance(raw_data, dict):\n            return raw_data\n\n        # Случай 1: Arbitrator output с payload\n        if \"payload\" in raw_data and isinstance(raw_data[\"payload\"], dict):\n            # Проверяем что это успешный Arbitrator response\n            status = raw_data.get(\"status\", \"\").upper()\n            if status in [\"SUCCESS\", \"COMPLETE\", \"OK\"]:\n                return raw_data[\"payload\"]\n            # Даже если статус не SUCCESS, но payload есть — используем его\n            if raw_data[\"payload\"]:\n                return raw_data[\"payload\"]\n\n        # Случай 2: Вложенный data.payload\n        if \"data\" in raw_data and isinstance(raw_data[\"data\"], dict):\n            if \"payload\" in raw_data[\"data\"]:\n                return raw_data[\"data\"][\"payload\"]\n            return raw_data[\"data\"]\n\n        # Случай 3: Прямой Agent1 output (уже нормализован)\n        return raw_data\n\n    # ==========================================\n    # УНИВЕРСАЛЬНЫЕ МЕТОДЫ ИЗВЛЕЧЕНИЯ ДАННЫХ\n    # ==========================================\n    def _universal_extract_domains(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет домены во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        domains = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return domains\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"domain\", \"domains\", \"server_name\", \"server_names\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        domains.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                domains.append(item.strip())\n\n            for value in data.values():\n                domains.extend(self._universal_extract_domains(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                domains.extend(self._universal_extract_domains(item, visited))\n\n        return list(set([d for d in domains if d and self._looks_like_domain(d)]))\n\n    def _universal_extract_locations(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет location/locations во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        locations = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return locations\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"location\", \"locations\", \"kms_locations\", \"public_locations\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        locations.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                locations.append(item.strip())\n\n            for value in data.values():\n                if isinstance(value, (dict, list)):\n                    locations.extend(self._universal_extract_locations(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                locations.extend(self._universal_extract_locations(item, visited))\n\n        return list(set([loc for loc in locations if loc and loc.startswith(\"/\")]))\n\n    def _universal_extract_ips(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет IP адреса во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        ips = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return ips\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"ip_addresses\", \"ips\", \"servers\", \"upstream\", \"ip\", \"address\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        ips.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                ips.append(item.strip())\n\n            for value in data.values():\n                if isinstance(value, (dict, list)):\n                    ips.extend(self._universal_extract_ips(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                ips.extend(self._universal_extract_ips(item, visited))\n\n        return list(set([ip for ip in ips if ip and self._looks_like_ip(ip)]))\n\n    def _universal_extract_upstreams(self, data: Any, visited: Optional[set] = None) -> List[Dict]:\n        \"\"\"\n        🆕 Извлекает структурированные upstreams\n\n        Формат входа:\n        \"upstreams\": [\n            {\"upstream_type\": \"main\", \"ip_addresses\": [\"10.10.10.10\", ...], \"params\": []},\n            {\"upstream_type\": \"backup\", \"ip_addresses\": [...], \"params\": []}\n        ]\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        upstreams = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return upstreams\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            # Прямой ключ upstreams\n            if \"upstreams\" in data and isinstance(data[\"upstreams\"], list):\n                for upstream in data[\"upstreams\"]:\n                    if isinstance(upstream, dict):\n                        normalized = {\n                            \"type\": upstream.get(\"upstream_type\", upstream.get(\"type\", \"main\")),\n                            \"ip_addresses\": upstream.get(\"ip_addresses\", upstream.get(\"ips\", [])),\n                            \"params\": upstream.get(\"params\", upstream.get(\"parameters\", []))\n                        }\n                        if normalized[\"ip_addresses\"]:\n                            upstreams.append(normalized)\n\n            # Рекурсивный поиск\n            for key, value in data.items():\n                if key != \"upstreams\" and isinstance(value, (dict, list)):\n                    upstreams.extend(self._universal_extract_upstreams(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                upstreams.extend(self._universal_extract_upstreams(item, visited))\n\n        return upstreams\n\n    def _universal_extract_location_parameters(self, data: Any, visited: Optional[set] = None) -> List[Dict]:\n        \"\"\"\n        🆕 Извлекает параметры для конкретных locations\n\n        Формат входа:\n        \"location_parameters\": [\n            {\"location\": \"/api_V2/\", \"parameters\": [], \"kms_required\": false},\n            ...\n        ]\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        loc_params = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return loc_params\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            if \"location_parameters\" in data and isinstance(data[\"location_parameters\"], list):\n                for lp in data[\"location_parameters\"]:\n                    if isinstance(lp, dict) and \"location\" in lp:\n                        normalized = {\n                            \"location\": lp.get(\"location\"),\n                            \"parameters\": lp.get(\"parameters\", []),\n                            \"kms_required\": lp.get(\"kms_required\", False)\n                        }\n                        loc_params.append(normalized)\n\n            for key, value in data.items():\n                if key != \"location_parameters\" and isinstance(value, (dict, list)):\n                    loc_params.extend(self._universal_extract_location_parameters(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                loc_params.extend(self._universal_extract_location_parameters(item, visited))\n\n        return loc_params\n\n    def _universal_extract_parameters(self, data: Any, visited: Optional[set] = None) -> Dict:\n        \"\"\"\n        Ищет общие параметры в структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        parameters = {}\n\n        data_id = id(data)\n        if data_id in visited:\n            return parameters\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            # server_block_parameters\n            if \"server_block_parameters\" in data:\n                params = data[\"server_block_parameters\"]\n                if isinstance(params, list):\n                    parameters[\"server_block\"] = params\n                elif isinstance(params, dict):\n                    parameters[\"server_block\"] = params\n\n            # Общие parameters\n            if \"parameters\" in data:\n                params = data[\"parameters\"]\n                if isinstance(params, dict):\n                    parameters.update(params)\n                elif isinstance(params, list):\n                    parameters[\"general\"] = params\n\n            # Рекурсивно (но не в уже обработанные ключи)\n            for key, value in data.items():\n                if key not in [\"parameters\", \"server_block_parameters\", \"location_parameters\"] \\\n                        and isinstance(value, (dict, list)):\n                    sub_params = self._universal_extract_parameters(value, visited)\n                    for k, v in sub_params.items():\n                        if k not in parameters:\n                            parameters[k] = v\n\n        elif isinstance(data, list):\n            for item in data:\n                sub_params = self._universal_extract_parameters(item, visited)\n                parameters.update(sub_params)\n\n        return parameters\n\n    def _universal_extract_operation(self, data: Any) -> Optional[str]:\n        \"\"\"\n        Ищет тип операции в любой структуре\n        \"\"\"\n        if isinstance(data, dict):\n            for key in [\"operation\", \"operation_type\", \"action\", \"type\"]:\n                if key in data and data[key]:\n                    val = str(data[key])\n                    # Фильтруем не-операции\n                    if val.upper() not in [\"MAIN\", \"BACKUP\", \"PREFIX\", \"EXACT\"]:\n                        return val\n\n            for value in data.values():\n                if isinstance(value, (dict, list)):\n                    result = self._universal_extract_operation(value)\n                    if result:\n                        return result\n\n        elif isinstance(data, list):\n            for item in data:\n                result = self._universal_extract_operation(item)\n                if result:\n                    return result\n\n        return None\n\n    def _universal_extract_selected_dc(self, data: Any, visited: Optional[set] = None) -> List[str]:\n        \"\"\"\n        Рекурсивно ищет selected_dc во ВСЕЙ структуре JSON\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        dcs = []\n\n        data_id = id(data)\n        if data_id in visited:\n            return dcs\n        visited.add(data_id)\n\n        if isinstance(data, dict):\n            for key in [\"selected_dc\", \"dc\", \"datacenters\", \"datacenter\"]:\n                if key in data:\n                    value = data[key]\n                    if isinstance(value, str) and value.strip():\n                        dcs.append(value.strip())\n                    elif isinstance(value, list):\n                        for item in value:\n                            if isinstance(item, str) and item.strip():\n                                dcs.append(item.strip())\n\n            for value in data.values():\n                dcs.extend(self._universal_extract_selected_dc(value, visited))\n\n        elif isinstance(data, list):\n            for item in data:\n                dcs.extend(self._universal_extract_selected_dc(item, visited))\n\n        return list(set(dcs))\n\n    def _check_status(self, data: Any) -> Optional[Dict]:\n        \"\"\"\n        Проверяет статус ошибки в данных\n        \"\"\"\n        if isinstance(data, dict):\n            status = data.get(\"status\", \"\")\n\n            # Ошибка Arbitrator\n            if status == \"VALIDATION_FAILED\":\n                return {\n                    \"is_error\": True,\n                    \"status\": status,\n                    \"error_type\": \"VALIDATION_FAILED\",\n                    \"error_message\": \"Валидация не прошла\",\n                    \"missing_fields\": data.get(\"missing_fields\", []),\n                    \"clarification_questions\": data.get(\"clarification_questions\", [])\n                }\n\n            # Ошибка Agent1\n            if status == \"error\":\n                return {\n                    \"is_error\": True,\n                    \"status\": data.get(\"status\"),\n                    \"error_type\": data.get(\"error_type\"),\n                    \"error_message\": data.get(\"error_message\"),\n                    \"explanation\": data.get(\"explanation\"),\n                    \"warnings\": data.get(\"warnings\", [])\n                }\n        return None\n\n    # ==========================================\n    # ВАЛИДАЦИЯ\n    # ==========================================\n    def _looks_like_domain(self, text: str) -> bool:\n        \"\"\"Проверяет, похоже ли на домен\"\"\"\n        if not text or len(text) < 3:\n            return False\n        return '.' in text or re.match(r'^[a-zA-Z0-9\\-\\.]+$', text) is not None\n\n    def _looks_like_ip(self, text: str) -> bool:\n        \"\"\"Проверяет, похоже ли на IP адрес\"\"\"\n        if not text:\n            return False\n        ip_pattern = r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d+)?$'\n        return re.match(ip_pattern, text) is not None\n\n    # ==========================================\n    # ЛОГИКА ПОИСКА ПО ПАПКАМ И DC\n    # ==========================================\n    def _get_all_folders(self) -> List[str]:\n        \"\"\"Возвращает список всех возможных папок\"\"\"\n        return [\n            \"production_ext_kor_sites\",\n            \"production_ext_nag_http\",\n            \"production_ext_nag_sites\",\n            \"production_ext_sites\",\n            \"production_kor_ngate_sites\",\n            \"production_kor_sites\",\n            \"production_mesh_main_kor_sites\",\n            \"production_mesh_rus_kor_sites\",\n            \"production_metro_kor_sites\",\n            \"production_metro_sites\",\n            \"production_moshub_ext_kor_sites\",\n            \"production_moshub_kor_sites\",\n            \"production_nag_sites\",\n            \"production_sites\",\n            \"production_upload_sites\",\n            \"stage_kor_sites\",\n            \"stage_nag_sites\",\n            \"stage_sites\",\n            \"test_kor_sites\",\n            \"test_nag_sites\",\n            \"test_sites\"\n        ]\n\n    def _get_search_folders(self, selected_dc: List[str]) -> List[str]:\n        \"\"\"Определяет папки для поиска на основе selected_dc\"\"\"\n        all_folders = self._get_all_folders()\n        if not selected_dc:\n            return all_folders\n\n        search_folders = set()\n        for dc in selected_dc:\n            if dc == \"dr\":\n                search_folders.update(self._get_folders_for_dc(\"korovinskiy\"))\n                search_folders.update(self._get_folders_for_dc(\"kurchatovskiy\"))\n            else:\n                search_folders.update(self._get_folders_for_dc(dc))\n        return list(search_folders)\n\n    def _get_folders_for_dc(self, dc: str) -> List[str]:\n        \"\"\"Возвращает папки для конкретного DC\"\"\"\n        all_folders = self._get_all_folders()\n\n        if dc == \"korovinskiy\":\n            # Исключаем metro и mesh - они относятся к отдельным DC\n            return [f for f in all_folders\n                    if \"_kor_\" in f\n                    and \"metro\" not in f\n                    and \"mesh\" not in f]\n\n        elif dc == \"kurchatovskiy\":\n            return [f for f in all_folders if\n                    f in [\"production_sites\", \"stage_sites\", \"test_sites\", \"production_ext_sites\",\n                          \"production_upload_sites\"]]  # убрал production_metro_sites\n\n        elif dc == \"nagornaya\":\n            return [f for f in all_folders if \"_nag_\" in f]\n\n        elif dc == \"moshub_rus\":\n            return [f for f in all_folders if \"moshub\" in f and \"ext\" not in f]\n\n        elif dc == \"ext_kurchatovskiy\":\n            return [f for f in all_folders if \"ext\" in f and \"_kor_\" not in f and \"_nag_\" not in f]\n\n        elif dc == \"ext_korovinskiy\":\n            return [f for f in all_folders if \"ext\" in f and \"_kor_\" in f]\n\n        elif dc == \"ext_nagornaya\":\n            return [f for f in all_folders if \"ext\" in f and \"_nag_\" in f]\n\n        elif dc == \"mesh\":\n            return [f for f in all_folders if \"mesh\" in f]\n\n        elif dc == \"top10_kurchatovskiy\":\n            return [f for f in all_folders if \"metro\" in f and \"_kor_\" not in f]\n\n        elif dc == \"top10_korovinskiy\":\n            return [f for f in all_folders if \"metro\" in f and \"_kor_\" in f]\n\n        return []\n\n    def _infer_dc_from_folder(self, folder: str) -> List[str]:\n        \"\"\"Определяет DC на основе имени папки\"\"\"\n        dcs = []\n        folder_lower = folder.lower()\n        if \"_kor_\" in folder_lower:\n            dcs.append(\"korovinskiy\")\n        if \"_nag_\" in folder_lower:\n            dcs.append(\"nagornaya\")\n        if folder in [\"production_sites\", \"stage_sites\", \"test_sites\", \"production_ext_sites\", \"production_metro_sites\",\n                      \"production_upload_sites\"]:\n            dcs.append(\"kurchatovskiy\")\n        if \"mesh\" in folder_lower:\n            dcs.append(\"mesh\")\n        if \"moshub\" in folder_lower:\n            dcs.append(\"moshub_rus\")\n        if \"metro\" in folder_lower:\n            if \"_kor_\" in folder_lower:\n                dcs.append(\"top10_korovinskiy\")\n            else:\n                dcs.append(\"top10_kurchatovskiy\")\n        if \"ext\" in folder_lower:\n            if \"_kor_\" in folder_lower:\n                dcs.append(\"ext_korovinskiy\")\n            elif \"_nag_\" in folder_lower:\n                dcs.append(\"ext_nagornaya\")\n            else:\n                dcs.append(\"ext_kurchatovskiy\")\n        return list(set(dcs))\n\n    # ==========================================\n    # СКАНИРОВАНИЕ YML\n    # ==========================================\n    def _scan_yml_file(self, yml_file: str, target_domains: List[str]) -> List[Dict]:\n        \"\"\"Сканирует один YML файл и находит совпадения по server_name\"\"\"\n        results = []\n        try:\n            with open(yml_file, 'r', encoding='utf-8') as f:\n                config_text = f.read()\n                config_yaml = yaml.safe_load(config_text)\n            if not config_yaml:\n                return results\n            for config_key, config_block in config_yaml.items():\n                server_names = self._extract_server_names(config_block)\n                if not server_names:\n                    continue\n                matching_domains = []\n                for target_domain in target_domains:\n                    if self._is_domain_match(target_domain, server_names):\n                        matching_domains.append(target_domain)\n                if matching_domains:\n                    result = {\n                        \"config_key\": config_key,\n                        \"config_file\": yml_file,\n                        \"server_names\": server_names,\n                        \"matching_domains\": matching_domains,\n                        \"full_config_text\": config_text,\n                        \"parsed_yaml\": config_yaml,\n                        \"config_block\": config_block\n                    }\n                    results.append(result)\n        except yaml.YAMLError as e:\n            print(f\"⚠️ Ошибка чтения YAML {yml_file}: {e}\")\n        except Exception as e:\n            print(f\"⚠️ Ошибка обработки {yml_file}: {e}\")\n        return results\n\n    def _extract_server_names(self, config_block: Any) -> List[str]:\n        \"\"\"Извлекает все server_name из конфигурационного блока\"\"\"\n        server_names = []\n        if isinstance(config_block, list):\n            for item in config_block:\n                if isinstance(item, str) and item.startswith(\"server_name \"):\n                    server_name_part = item.replace(\"server_name \", \"\").strip()\n                    names = [n.strip() for n in server_name_part.split() if n.strip()]\n                    server_names.extend(names)\n        return list(set(server_names))\n\n    def _is_domain_match(self, target_domain: str, server_names: List[str]) -> bool:\n        \"\"\"Проверяет, совпадает ли target_domain с любым server_name\"\"\"\n        target_domain = target_domain.strip().lower()\n        for server_name in server_names:\n            server_name = server_name.strip().lower()\n            if server_name == target_domain:\n                return True\n            if server_name.startswith(\"~^\") and server_name.endswith(\"$\"):\n                pattern = server_name[2:-1]\n                try:\n                    if re.match(pattern, target_domain):\n                        return True\n                except re.error:\n                    continue\n        return False\n\n    def _deduplicate_results(self, results: List[Dict]) -> List[Dict]:\n        \"\"\"Удаляет дубликаты результатов\"\"\"\n        seen = set()\n        unique = []\n        for result in results:\n            key = (result[\"config_file\"], result[\"config_key\"])\n            if key not in seen:\n                seen.add(key)\n                unique.append(result)\n        return unique\n\n    # ==========================================\n    # ОБРАБОТКА ОШИБОК\n    # ==========================================\n    def _return_error_status(self, status: Dict, agent1_data: Any) -> Data:\n        \"\"\"Возвращает ошибку из статуса\"\"\"\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": status.get(\"error_type\", \"UNKNOWN_ERROR\"),\n            \"error_message\": status.get(\"error_message\", \"Unknown error\"),\n            \"explanation\": status.get(\"explanation\", \"\"),\n            \"warnings\": status.get(\"warnings\", []),\n            \"missing_fields\": status.get(\"missing_fields\", []),\n            \"clarification_questions\": status.get(\"clarification_questions\", []),\n            \"agent1_data\": agent1_data,\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: {status.get('error_message')}\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        questions = status.get(\"clarification_questions\", [])\n        missing = status.get(\"missing_fields\", [])\n\n        error_msg = f\"\"\"❌ **Ошибка**\n🔴 **Тип:** {status.get('error_type')}\n📝 **Сообщение:** {status.get('error_message')}\n\"\"\"\n        if missing:\n            error_msg += f\"\\n📋 **Не хватает:** {', '.join(missing[:3])}\"\n        if questions:\n            error_msg += f\"\\n❓ **Вопросы:** {questions[0]}\"\n        return Data(data=error_result, text=error_msg)\n\n    def _return_no_domains_error(self, agent1_data: Any, locations: List[str],\n                                 ip_addresses: List[str], parameters: Dict,\n                                 operation: Optional[str]) -> Data:\n        \"\"\"Возвращает ошибку об отсутствии доменов\"\"\"\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": \"NO_DOMAINS\",\n            \"error_message\": \"Домены не найдены в данных\",\n            \"agent1_data\": agent1_data,\n            \"operation\": operation,\n            \"locations\": locations,\n            \"ip_addresses\": ip_addresses,\n            \"parameters\": parameters,\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": \"# Error: No domains specified\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        error_msg = f\"\"\"❌ **Ошибка: домен не указан**\n📋 **Что извлечено:**\n- Operation: {operation or 'N/A'}\n- Locations: {', '.join(locations[:3]) if locations else 'N/A'}\n- IPs: {', '.join(ip_addresses[:3]) if ip_addresses else 'N/A'}\n💡 Укажите домен явно в запросе.\n\"\"\"\n        return Data(data=error_result, text=error_msg)\n\n    def _return_not_found_error(self, domains: List[str], scanned_files: int,\n                                agent1_data: Any, locations: List[str],\n                                ip_addresses: List[str], parameters: Dict,\n                                operation: Optional[str]) -> Data:\n        \"\"\"Возвращает ошибку о ненайденной конфигурации\"\"\"\n        not_found_result = {\n            \"status\": \"not_found\",\n            \"error_type\": \"CONFIG_NOT_FOUND\",\n            \"error_message\": f\"Конфигурация не найдена для: {', '.join(domains)}\",\n            \"domains\": domains,\n            \"scanned_files\": scanned_files,\n            \"agent1_data\": agent1_data,\n            \"operation\": operation,\n            \"locations\": locations,\n            \"ip_addresses\": ip_addresses,\n            \"parameters\": parameters,\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: Config not found for: {', '.join(domains)}\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        error_msg = f\"\"\"❌ **Конфигурация не найдена**\n🔍 **Домены:** {', '.join(domains)}\n📊 **Просканировано:** {scanned_files} файлов\n\"\"\"\n        return Data(data=not_found_result, text=error_msg)\n\n    def _return_json_error(self, error: Exception, raw_json: str) -> Data:\n        \"\"\"Возвращает ошибку парсинга JSON\"\"\"\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": \"JSON_PARSE_ERROR\",\n            \"error_message\": f\"Ошибка парсинга JSON: {str(error)}\",\n            \"raw_input\": raw_json[:500],\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: JSON parse error\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        return Data(data=error_result, text=f\"❌ **Ошибка парсинга JSON**\\n\\n{str(error)}\")\n\n    def _return_unexpected_error(self, error: Exception) -> Data:\n        \"\"\"Возвращает неожиданную ошибку\"\"\"\n        import traceback\n        error_result = {\n            \"status\": \"error\",\n            \"error_type\": \"UNEXPECTED_ERROR\",\n            \"error_message\": f\"Неожиданная ошибка: {str(error)}\",\n            \"traceback\": traceback.format_exc(),\n            \"config_file\": \"N/A\",\n            \"config_key\": \"N/A\",\n            \"full_config_text\": f\"# Error: {str(error)}\",\n            \"data_complete\": False,\n            # 🆕 Добавляем ключи даже в ошибку для консистентности\n            \"found_in_multiple_dc\": False,\n            \"dc_count\": 0,\n            \"unique_dcs\": [],\n            \"domain_dc_mapping\": {},\n            \"domains_in_multiple_dc\": []\n        }\n        print(f\"❌ UNEXPECTED ERROR: {str(error)}\")\n        traceback.print_exc()\n        return Data(data=error_result, text=f\"❌ **Неожиданная ошибка**\\n\\n{str(error)}\")\n\n    # ==========================================\n    # ФОРМАТИРОВАНИЕ РЕЗУЛЬТАТА\n    # ==========================================\n    def _format_success_message(self, result: Dict) -> str:\n        \"\"\"Формирует читаемое сообщение о результате\"\"\"\n        all_configs = result.get(\"all_configs\", [])\n        found_configs = len(all_configs)\n        scanned_files = result.get(\"scanned_files\", 0)\n        operation = result.get(\"operation\")\n        locations = result.get(\"locations\", [])\n        upstreams = result.get(\"upstreams\", [])\n        location_parameters = result.get(\"location_parameters\", [])\n        selected_dc = result.get(\"selected_dc\", [])\n\n        # 🆕 Новые данные о multi-DC\n        found_in_multiple_dc = result.get(\"found_in_multiple_dc\", False)\n        dc_count = result.get(\"dc_count\", 0)\n        unique_dcs = result.get(\"unique_dcs\", [])\n        domains_in_multiple_dc = result.get(\"domains_in_multiple_dc\", [])\n        domain_dc_mapping = result.get(\"domain_dc_mapping\", {})\n\n        msg = f\"✅ **Найдено {found_configs} конфигурац{'ия' if found_configs == 1 else 'ий' if 2 <= found_configs <= 4 else 'ий'}**\\n\\n\"\n\n        # 🆕 Предупреждение о нескольких ЦОД\n        if found_in_multiple_dc:\n            msg += f\"⚠️ **ВНИМАНИЕ: Домен найден в {dc_count} ЦОД!**\\n\"\n            msg += f\"🏢 **ЦОД:** {', '.join(unique_dcs)}\\n\"\n            if domains_in_multiple_dc:\n                msg += f\"🌐 **Домены в нескольких ЦОД:** {', '.join(domains_in_multiple_dc)}\\n\"\n            msg += \"\\n\"\n\n        for i, cfg in enumerate(all_configs):\n            if i > 0:\n                msg += \"\\n\" + (\"-\" * 40) + \"\\n\\n\"\n            msg += f\"📁 **Файл:** `{os.path.basename(cfg['config_file'])}`\\n\"\n            server_names = cfg.get(\"server_names\", [])\n            msg += f\"🌐 **Server names:** {', '.join(server_names[:3])}{'...' if len(server_names) > 3 else ''}\\n\"\n            matching_domains = cfg.get(\"matching_domains\", [])\n            msg += f\"✅ **Совпадения:** {', '.join(matching_domains)}\\n\"\n            inferred_dc = cfg.get(\"inferred_dc\", [])\n            if inferred_dc:\n                msg += f\"🏢 **DC:** {', '.join(inferred_dc)}\\n\"\n            else:\n                msg += f\"🏢 **DC:** N/A\\n\"\n\n        msg += f\"\\n📊 **Просканировано:** {scanned_files} файлов\"\n\n        if selected_dc:\n            msg += f\"\\n🗺 **Selected DC:** {', '.join(selected_dc)}\"\n        if operation:\n            msg += f\"\\n🔄 **Operation:** {operation}\"\n        if locations:\n            msg += f\"\\n📍 **Locations:** {', '.join(locations[:5])}\"\n        if upstreams:\n            for up in upstreams[:2]:\n                ips = up.get(\"ip_addresses\", [])\n                up_type = up.get(\"type\", \"unknown\")\n                msg += f\"\\n🔗 **Upstream ({up_type}):** {', '.join(ips[:3])}\"\n        if location_parameters:\n            msg += f\"\\n⚙️ **Location params:** {len(location_parameters)} записей\"\n\n        # 🆕 Расширенное примечание\n        if found_in_multiple_dc:\n            msg += \"\\n\\n⚠️ **ВАЖНО:** Конфигурация найдена в нескольких ЦОД. \"\n            msg += \"Убедитесь, что изменения применяются ко всем необходимым площадкам!\"\n            # Детальный маппинг\n            if domain_dc_mapping:\n                msg += \"\\n\\n📋 **Детали по доменам:**\"\n                for domain, dcs in domain_dc_mapping.items():\n                    if len(dcs) > 1:\n                        msg += f\"\\n  • `{domain}` → {', '.join(dcs)}\"\n        elif found_configs > 1:\n            msg += \"\\n\\nℹ️ **Примечание:** Найдено несколько конфигураций. Проверьте все варианты.\"\n\n        return msg\n"
              },
              "config_base_path": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Config Base Path",
                "dynamic": false,
                "info": "Путь к родительской папке с конфигами (например, /path/to/mos_ru_nginx/)",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "config_base_path",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "/Users/rusk/PycharmProjects/fastapi/portalFastDjango/mosru_nginx/mos_ru_nginx/production_kor_sites"
              }
            },
            "tool_mode": false
          },
          "selected_output": "config_file_path",
          "showNode": true,
          "type": "UniversalSearchConfigComponent"
        },
        "dragging": false,
        "id": "UniversalSearchConfigComponent-IuZIu",
        "measured": {
          "height": 317,
          "width": 320
        },
        "position": {
          "x": -1208.4860114002977,
          "y": 2572.6593072665155
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "note-f4pOz",
          "node": {
            "description": "#OPERATIONS (EXPANDED)\n| Operation                | Description | Scope | Behavior | Example |\n|--------------------------|-------------|-------|----------|---------|\n| **ADD_PARAMETERS**       | Add parameter **only if it does NOT exist at all** (by directive name) | location_block or server_block | Skip if exists, add if missing | `proxy_buffer_size 32k;` — if absent |\n| **MODIFY_PARAMETERS**    | Ensure parameter is set to target value: **replace if exists with different value**, **add if absent** | location_block or server_block | Change value OR add if missing | Change `proxy_buffer_size 16k;` → `32k;` or add if missing |\n| **DELETE_PARAMETERS**    | Remove parameter **by exact full string match** | location_block or server_block | Remove matching directives | Remove `proxy_buffer_size 16k;` |\n| **DELETE_LOCATION**      | Remove entire location block | location_block | Complete removal of location and all its directives | Removes `/api` block entirely |\n| **CREATE_LOCATION**      | Create new location block with parameters | location_block | Add new location with initial directives. Do NOT add any extra directives like proxy_set_header unless explicitly in parameters. | Create `/api_v1` with provided parameters |\n| **MODIFY_LOCATION_PATH** | Rename location path | location_block | Change path, preserve all directives | /relay → /relay/ | proxy_pass http://{{upstream_name}}; → proxy_pass http://upstream_name/; |\n| **MAKE_PROTECTED**       | Protect location with KMS parameters (add if absent or modify) | location_block | Use MODIFY_PARAMETERS with provided params or default KMS params if empty | Add default: allow 10.15.166.0/25; etc., deny all; |\n| **MAKE_PUBLIC**          | Make location public by removing KMS parameters | location_block | Use DELETE_KMS_PARAMETERS | Remove allow/deny etc. |",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "height": 324,
        "id": "note-f4pOz",
        "measured": {
          "height": 324,
          "width": 1000
        },
        "position": {
          "x": 236.38481977895242,
          "y": 1636.4821213939858
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 1000
      },
      {
        "data": {
          "id": "ChatOutput-wsqHO",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007216440637271487,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-wsqHO",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1591.2828679972247,
          "y": 3153.672972878988
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-6TZSU",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-6TZSU",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": 1303.999283010788,
          "y": 2796.6839602047025
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ConditionalRouter-8PRCp",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "logic",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Routes an input message to a corresponding output based on text comparison.",
            "display_name": "If-Else",
            "documentation": "https://docs.langflow.org/components-logic#conditional-router-if-else-component",
            "edited": false,
            "field_order": [
              "input_text",
              "operator",
              "match_text",
              "case_sensitive",
              "true_case_message",
              "false_case_message",
              "max_iterations",
              "default_route"
            ],
            "frozen": false,
            "icon": "split",
            "key": "ConditionalRouter",
            "last_updated": "2025-11-28T06:12:00.551Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "True",
                "group_outputs": true,
                "method": "true_response",
                "name": "true_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "False",
                "group_outputs": true,
                "method": "false_response",
                "name": "false_result",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "case_sensitive": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Case Sensitive",
                "dynamic": false,
                "info": "If true, the comparison will be case sensitive.",
                "list": false,
                "list_add_label": "Add More",
                "name": "case_sensitive",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\n\n\nclass ConditionalRouterComponent(Component):\n    display_name = \"If-Else\"\n    description = \"Routes an input message to a corresponding output based on text comparison.\"\n    documentation: str = \"https://docs.langflow.org/components-logic#conditional-router-if-else-component\"\n    icon = \"split\"\n    name = \"ConditionalRouter\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.__iteration_updated = False\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_text\",\n            display_name=\"Text Input\",\n            info=\"The primary text input for the operation.\",\n            required=True,\n        ),\n        DropdownInput(\n            name=\"operator\",\n            display_name=\"Operator\",\n            options=[\n                \"equals\",\n                \"not equals\",\n                \"contains\",\n                \"starts with\",\n                \"ends with\",\n                \"regex\",\n                \"less than\",\n                \"less than or equal\",\n                \"greater than\",\n                \"greater than or equal\",\n            ],\n            info=\"The operator to apply for comparing the texts.\",\n            value=\"equals\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"match_text\",\n            display_name=\"Match Text\",\n            info=\"The text input to compare against.\",\n            required=True,\n        ),\n        BoolInput(\n            name=\"case_sensitive\",\n            display_name=\"Case Sensitive\",\n            info=\"If true, the comparison will be case sensitive.\",\n            value=True,\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"true_case_message\",\n            display_name=\"Case True\",\n            info=\"The message to pass if the condition is True.\",\n            advanced=True,\n        ),\n        MessageInput(\n            name=\"false_case_message\",\n            display_name=\"Case False\",\n            info=\"The message to pass if the condition is False.\",\n            advanced=True,\n        ),\n        IntInput(\n            name=\"max_iterations\",\n            display_name=\"Max Iterations\",\n            info=\"The maximum number of iterations for the conditional router.\",\n            value=10,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"default_route\",\n            display_name=\"Default Route\",\n            options=[\"true_result\", \"false_result\"],\n            info=\"The default route to take when max iterations are reached.\",\n            value=\"false_result\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"True\", name=\"true_result\", method=\"true_response\", group_outputs=True),\n        Output(display_name=\"False\", name=\"false_result\", method=\"false_response\", group_outputs=True),\n    ]\n\n    def _pre_run_setup(self):\n        self.__iteration_updated = False\n\n    def evaluate_condition(self, input_text: str, match_text: str, operator: str, *, case_sensitive: bool) -> bool:\n        if not case_sensitive and operator != \"regex\":\n            input_text = input_text.lower()\n            match_text = match_text.lower()\n\n        if operator == \"equals\":\n            return input_text == match_text\n        if operator == \"not equals\":\n            return input_text != match_text\n        if operator == \"contains\":\n            return match_text in input_text\n        if operator == \"starts with\":\n            return input_text.startswith(match_text)\n        if operator == \"ends with\":\n            return input_text.endswith(match_text)\n        if operator == \"regex\":\n            try:\n                return bool(re.match(match_text, input_text))\n            except re.error:\n                return False  # Return False if the regex is invalid\n        if operator in [\"less than\", \"less than or equal\", \"greater than\", \"greater than or equal\"]:\n            try:\n                input_num = float(input_text)\n                match_num = float(match_text)\n                if operator == \"less than\":\n                    return input_num < match_num\n                if operator == \"less than or equal\":\n                    return input_num <= match_num\n                if operator == \"greater than\":\n                    return input_num > match_num\n                if operator == \"greater than or equal\":\n                    return input_num >= match_num\n            except ValueError:\n                return False  # Invalid number format for comparison\n        return False\n\n    def iterate_and_stop_once(self, route_to_stop: str):\n        \"\"\"Handles cycle iteration counting and branch exclusion.\n\n        Uses two complementary mechanisms:\n        1. stop() - ACTIVE/INACTIVE state for cycle management (gets reset each iteration)\n        2. exclude_branch_conditionally() - Persistent exclusion for conditional routing\n\n        When max_iterations is reached, breaks the cycle by allowing the default_route to execute.\n        \"\"\"\n        if not self.__iteration_updated:\n            self.update_ctx({f\"{self._id}_iteration\": self.ctx.get(f\"{self._id}_iteration\", 0) + 1})\n            self.__iteration_updated = True\n            current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n\n            # Check if max iterations reached and we're trying to stop the default route\n            if current_iteration >= self.max_iterations and route_to_stop == self.default_route:\n                # Clear ALL conditional exclusions to allow default route to execute\n                if self._id in self.graph.conditional_exclusion_sources:\n                    previous_exclusions = self.graph.conditional_exclusion_sources[self._id]\n                    self.graph.conditionally_excluded_vertices -= previous_exclusions\n                    del self.graph.conditional_exclusion_sources[self._id]\n\n                # Switch which route to stop - stop the NON-default route to break the cycle\n                route_to_stop = \"true_result\" if route_to_stop == \"false_result\" else \"false_result\"\n\n                # Call stop to break the cycle\n                self.stop(route_to_stop)\n                # Don't apply conditional exclusion when breaking cycle\n                return\n\n            # Normal case: Use BOTH mechanisms\n            # 1. stop() for cycle management (marks INACTIVE, updates run manager, gets reset)\n            self.stop(route_to_stop)\n\n            # 2. Conditional exclusion for persistent routing (doesn't get reset except by this router)\n            self.graph.exclude_branch_conditionally(self._id, output_name=route_to_stop)\n\n    def true_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        # Check if we should force output due to max_iterations on default route\n        current_iteration = self.ctx.get(f\"{self._id}_iteration\", 0)\n        force_output = current_iteration >= self.max_iterations and self.default_route == \"true_result\"\n\n        if result or force_output:\n            self.status = self.true_case_message\n            if not force_output:  # Only stop the other branch if not forcing due to max iterations\n                self.iterate_and_stop_once(\"false_result\")\n            return self.true_case_message\n        self.iterate_and_stop_once(\"true_result\")\n        return Message(content=\"\")\n\n    def false_response(self) -> Message:\n        result = self.evaluate_condition(\n            self.input_text, self.match_text, self.operator, case_sensitive=self.case_sensitive\n        )\n\n        if not result:\n            self.status = self.false_case_message\n            self.iterate_and_stop_once(\"true_result\")\n            return self.false_case_message\n\n        self.iterate_and_stop_once(\"false_result\")\n        return Message(content=\"\")\n\n    def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        if field_name == \"operator\":\n            if field_value == \"regex\":\n                build_config.pop(\"case_sensitive\", None)\n            elif \"case_sensitive\" not in build_config:\n                case_sensitive_input = next(\n                    (input_field for input_field in self.inputs if input_field.name == \"case_sensitive\"), None\n                )\n                if case_sensitive_input:\n                    build_config[\"case_sensitive\"] = case_sensitive_input.to_dict()\n        return build_config\n"
              },
              "default_route": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Route",
                "dynamic": false,
                "external_options": {},
                "info": "The default route to take when max iterations are reached.",
                "name": "default_route",
                "options": [
                  "true_result",
                  "false_result"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "false_result"
              },
              "false_case_message": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Case False",
                "dynamic": false,
                "info": "The message to pass if the condition is False.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "false_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "input_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Text Input",
                "dynamic": false,
                "info": "The primary text input for the operation.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "match_text": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Match Text",
                "dynamic": false,
                "info": "The text input to compare against.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "match_text",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\"error\""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of iterations for the conditional router.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 10
              },
              "operator": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Operator",
                "dynamic": false,
                "external_options": {},
                "info": "The operator to apply for comparing the texts.",
                "name": "operator",
                "options": [
                  "equals",
                  "not equals",
                  "contains",
                  "starts with",
                  "ends with",
                  "regex",
                  "less than",
                  "less than or equal",
                  "greater than",
                  "greater than or equal"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "contains"
              },
              "true_case_message": {
                "_input_type": "MessageInput",
                "advanced": true,
                "display_name": "Case True",
                "dynamic": false,
                "info": "The message to pass if the condition is True.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "true_case_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ConditionalRouter"
        },
        "dragging": false,
        "id": "ConditionalRouter-8PRCp",
        "measured": {
          "height": 509,
          "width": 320
        },
        "position": {
          "x": -141.33539471213228,
          "y": 2491.466776939725
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ParserComponent-yXjE3",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Extracts text using a template.",
            "display_name": "Parser",
            "documentation": "https://docs.langflow.org/components-processing#parser",
            "edited": false,
            "field_order": [
              "input_data",
              "mode",
              "pattern",
              "sep"
            ],
            "frozen": false,
            "icon": "braces",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Parsed Text",
                "group_outputs": false,
                "method": "parse_combined_text",
                "name": "parsed_text",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom.custom_component.component import Component\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, HandleInput, MessageTextInput, MultilineInput, TabInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.template.field.base import Output\n\n\nclass ParserComponent(Component):\n    display_name = \"Parser\"\n    description = \"Extracts text using a template.\"\n    documentation: str = \"https://docs.langflow.org/components-processing#parser\"\n    icon = \"braces\"\n\n    inputs = [\n        HandleInput(\n            name=\"input_data\",\n            display_name=\"Data or DataFrame\",\n            input_types=[\"DataFrame\", \"Data\"],\n            info=\"Accepts either a DataFrame or a Data object.\",\n            required=True,\n        ),\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Parser\", \"Stringify\"],\n            value=\"Parser\",\n            info=\"Convert into raw string instead of using a template.\",\n            real_time_refresh=True,\n        ),\n        MultilineInput(\n            name=\"pattern\",\n            display_name=\"Template\",\n            info=(\n                \"Use variables within curly brackets to extract column values for DataFrames \"\n                \"or key values for Data.\"\n                \"For example: `Name: {Name}, Age: {Age}, Country: {Country}`\"\n            ),\n            value=\"Text: {text}\",  # Example default\n            dynamic=True,\n            show=True,\n            required=True,\n        ),\n        MessageTextInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            advanced=True,\n            value=\"\\n\",\n            info=\"String used to separate rows/items.\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Parsed Text\",\n            name=\"parsed_text\",\n            info=\"Formatted text output.\",\n            method=\"parse_combined_text\",\n        ),\n    ]\n\n    def update_build_config(self, build_config, field_value, field_name=None):\n        \"\"\"Dynamically hide/show `template` and enforce requirement based on `stringify`.\"\"\"\n        if field_name == \"mode\":\n            build_config[\"pattern\"][\"show\"] = self.mode == \"Parser\"\n            build_config[\"pattern\"][\"required\"] = self.mode == \"Parser\"\n            if field_value:\n                clean_data = BoolInput(\n                    name=\"clean_data\",\n                    display_name=\"Clean Data\",\n                    info=(\n                        \"Enable to clean the data by removing empty rows and lines \"\n                        \"in each cell of the DataFrame/ Data object.\"\n                    ),\n                    value=True,\n                    advanced=True,\n                    required=False,\n                )\n                build_config[\"clean_data\"] = clean_data.to_dict()\n            else:\n                build_config.pop(\"clean_data\", None)\n\n        return build_config\n\n    def _clean_args(self):\n        \"\"\"Prepare arguments based on input type.\"\"\"\n        input_data = self.input_data\n\n        match input_data:\n            case list() if all(isinstance(item, Data) for item in input_data):\n                msg = \"List of Data objects is not supported.\"\n                raise ValueError(msg)\n            case DataFrame():\n                return input_data, None\n            case Data():\n                return None, input_data\n            case dict() if \"data\" in input_data:\n                try:\n                    if \"columns\" in input_data:  # Likely a DataFrame\n                        return DataFrame.from_dict(input_data), None\n                    # Likely a Data object\n                    return None, Data(**input_data)\n                except (TypeError, ValueError, KeyError) as e:\n                    msg = f\"Invalid structured input provided: {e!s}\"\n                    raise ValueError(msg) from e\n            case _:\n                msg = f\"Unsupported input type: {type(input_data)}. Expected DataFrame or Data.\"\n                raise ValueError(msg)\n\n    def parse_combined_text(self) -> Message:\n        \"\"\"Parse all rows/items into a single text or convert input to string if `stringify` is enabled.\"\"\"\n        # Early return for stringify option\n        if self.mode == \"Stringify\":\n            return self.convert_to_string()\n\n        df, data = self._clean_args()\n\n        lines = []\n        if df is not None:\n            for _, row in df.iterrows():\n                formatted_text = self.pattern.format(**row.to_dict())\n                lines.append(formatted_text)\n        elif data is not None:\n            formatted_text = self.pattern.format(**data.data)\n            lines.append(formatted_text)\n\n        combined_text = self.sep.join(lines)\n        self.status = combined_text\n        return Message(text=combined_text)\n\n    def convert_to_string(self) -> Message:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        result = \"\"\n        if isinstance(self.input_data, list):\n            result = \"\\n\".join([safe_convert(item, clean_data=self.clean_data or False) for item in self.input_data])\n        else:\n            result = safe_convert(self.input_data or False)\n        self.log(f\"Converted to string with length: {len(result)}\")\n\n        message = Message(text=result)\n        self.status = message\n        return message\n"
              },
              "input_data": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Data or DataFrame",
                "dynamic": false,
                "info": "Accepts either a DataFrame or a Data object.",
                "input_types": [
                  "DataFrame",
                  "Data"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_data",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "mode": {
                "_input_type": "TabInput",
                "advanced": false,
                "display_name": "Mode",
                "dynamic": false,
                "info": "Convert into raw string instead of using a template.",
                "name": "mode",
                "options": [
                  "Parser",
                  "Stringify"
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tab",
                "value": "Parser"
              },
              "pattern": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": true,
                "info": "Use variables within curly brackets to extract column values for DataFrames or key values for Data.For example: `Name: {Name}, Age: {Age}, Country: {Country}`",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "pattern",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "sep": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Separator",
                "dynamic": false,
                "info": "String used to separate rows/items.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sep",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "\n"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ParserComponent"
        },
        "dragging": false,
        "id": "ParserComponent-yXjE3",
        "measured": {
          "height": 327,
          "width": 320
        },
        "position": {
          "x": -615.6234572654183,
          "y": 3025.670662320197
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-PkDbl",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "input_output",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.007216440637271487,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-PkDbl",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": -63.17515082036782,
          "y": 3323.887746648098
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 1704.097830413101,
      "y": -3232.021628737111,
      "zoom": 1.416175438214545
    }
  },
  "description": "Create, Chain, Communicate.",
  "endpoint_name": null,
  "id": "954aebcc-d1b9-45ad-8438-1765ba79cc55",
  "is_component": false,
  "last_tested_version": "1.6.0",
  "name": "YAML Processing Subflow Locations",
  "tags": []
}